 /**
  * Autogenerated by Thrift
  *
  * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
  */
 package org.apache.cassandra.service;
 
 import java.util.List;
 import java.util.ArrayList;
 import java.util.Map;
 import java.util.HashMap;
 import java.util.Set;
 import java.util.HashSet;
 import java.util.Collections;
 import org.apache.log4j.Logger;
 
 import org.apache.thrift.*;
 import org.apache.thrift.meta_data.*;
 import org.apache.thrift.protocol.*;
 
 public class Cassandra {
 
   public interface Iface {
 
     public List<Column> get_slice_by_names(String table, String key, ColumnParent column_parent, List<byte[]> column_names) throws InvalidRequestException, NotFoundException, TException;
 
     public List<Column> get_slice(String table, String key, ColumnParent column_parent, byte[] start, byte[] finish, boolean is_ascending, int count) throws InvalidRequestException, NotFoundException, TException;
 
     public Column get_column(String table, String key, ColumnPath column_path) throws InvalidRequestException, NotFoundException, TException;
 
     public int get_column_count(String table, String key, ColumnParent column_parent) throws InvalidRequestException, TException;
 
     public void insert(String table, String key, ColumnPath column_path, byte[] value, long timestamp, int block_for) throws InvalidRequestException, UnavailableException, TException;
 
     public void batch_insert(String table, BatchMutation batch_mutation, int block_for) throws InvalidRequestException, UnavailableException, TException;
 
     public void remove(String table, String key, ColumnPathOrParent column_path_or_parent, long timestamp, int block_for) throws InvalidRequestException, UnavailableException, TException;
 
     public List<SuperColumn> get_slice_super(String table, String key, String column_family, byte[] start, byte[] finish, boolean is_ascending, int count) throws InvalidRequestException, TException;
 
     public List<SuperColumn> get_slice_super_by_names(String table, String key, String column_family, List<byte[]> super_column_names) throws InvalidRequestException, TException;
 
     public SuperColumn get_super_column(String table, String key, SuperColumnPath super_column_path) throws InvalidRequestException, NotFoundException, TException;
 
     public void batch_insert_super_column(String table, BatchMutationSuper batch_mutation_super, int block_for) throws InvalidRequestException, UnavailableException, TException;
 
    public List<String> get_key_range(String table, String column_family, String startWith, String stopAt, int maxResults) throws InvalidRequestException, TException;
 
    public String getStringProperty(String propertyName) throws TException;
 
    public List<String> getStringListProperty(String propertyName) throws TException;
 
    public Map<String,Map<String,String>> describeTable(String tableName) throws NotFoundException, TException;
 
    public CqlResult executeQuery(String query) throws TException;
 
   }
 
   public static class Client implements Iface {
     public Client(TProtocol prot)
     {
       this(prot, prot);
     }
 
     public Client(TProtocol iprot, TProtocol oprot)
     {
       iprot_ = iprot;
       oprot_ = oprot;
     }
 
     protected TProtocol iprot_;
     protected TProtocol oprot_;
 
     protected int seqid_;
 
     public TProtocol getInputProtocol()
     {
       return this.iprot_;
     }
 
     public TProtocol getOutputProtocol()
     {
       return this.oprot_;
     }
 
     public List<Column> get_slice_by_names(String table, String key, ColumnParent column_parent, List<byte[]> column_names) throws InvalidRequestException, NotFoundException, TException
     {
       send_get_slice_by_names(table, key, column_parent, column_names);
       return recv_get_slice_by_names();
     }
 
     public void send_get_slice_by_names(String table, String key, ColumnParent column_parent, List<byte[]> column_names) throws TException
     {
       oprot_.writeMessageBegin(new TMessage("get_slice_by_names", TMessageType.CALL, seqid_));
       get_slice_by_names_args args = new get_slice_by_names_args();
       args.table = table;
       args.key = key;
       args.column_parent = column_parent;
       args.column_names = column_names;
       args.write(oprot_);
       oprot_.writeMessageEnd();
       oprot_.getTransport().flush();
     }
 
     public List<Column> recv_get_slice_by_names() throws InvalidRequestException, NotFoundException, TException
     {
       TMessage msg = iprot_.readMessageBegin();
       if (msg.type == TMessageType.EXCEPTION) {
         TApplicationException x = TApplicationException.read(iprot_);
         iprot_.readMessageEnd();
         throw x;
       }
       get_slice_by_names_result result = new get_slice_by_names_result();
       result.read(iprot_);
       iprot_.readMessageEnd();
       if (result.isSetSuccess()) {
         return result.success;
       }
       if (result.ire != null) {
         throw result.ire;
       }
       if (result.nfe != null) {
         throw result.nfe;
       }
       throw new TApplicationException(TApplicationException.MISSING_RESULT, "get_slice_by_names failed: unknown result");
     }
 
     public List<Column> get_slice(String table, String key, ColumnParent column_parent, byte[] start, byte[] finish, boolean is_ascending, int count) throws InvalidRequestException, NotFoundException, TException
     {
       send_get_slice(table, key, column_parent, start, finish, is_ascending, count);
       return recv_get_slice();
     }
 
     public void send_get_slice(String table, String key, ColumnParent column_parent, byte[] start, byte[] finish, boolean is_ascending, int count) throws TException
     {
       oprot_.writeMessageBegin(new TMessage("get_slice", TMessageType.CALL, seqid_));
       get_slice_args args = new get_slice_args();
       args.table = table;
       args.key = key;
       args.column_parent = column_parent;
       args.start = start;
       args.finish = finish;
       args.is_ascending = is_ascending;
       args.count = count;
       args.write(oprot_);
       oprot_.writeMessageEnd();
       oprot_.getTransport().flush();
     }
 
     public List<Column> recv_get_slice() throws InvalidRequestException, NotFoundException, TException
     {
       TMessage msg = iprot_.readMessageBegin();
       if (msg.type == TMessageType.EXCEPTION) {
         TApplicationException x = TApplicationException.read(iprot_);
         iprot_.readMessageEnd();
         throw x;
       }
       get_slice_result result = new get_slice_result();
       result.read(iprot_);
       iprot_.readMessageEnd();
       if (result.isSetSuccess()) {
         return result.success;
       }
       if (result.ire != null) {
         throw result.ire;
       }
       if (result.nfe != null) {
         throw result.nfe;
       }
       throw new TApplicationException(TApplicationException.MISSING_RESULT, "get_slice failed: unknown result");
     }
 
     public Column get_column(String table, String key, ColumnPath column_path) throws InvalidRequestException, NotFoundException, TException
     {
       send_get_column(table, key, column_path);
       return recv_get_column();
     }
 
     public void send_get_column(String table, String key, ColumnPath column_path) throws TException
     {
       oprot_.writeMessageBegin(new TMessage("get_column", TMessageType.CALL, seqid_));
       get_column_args args = new get_column_args();
       args.table = table;
       args.key = key;
       args.column_path = column_path;
       args.write(oprot_);
       oprot_.writeMessageEnd();
       oprot_.getTransport().flush();
     }
 
     public Column recv_get_column() throws InvalidRequestException, NotFoundException, TException
     {
       TMessage msg = iprot_.readMessageBegin();
       if (msg.type == TMessageType.EXCEPTION) {
         TApplicationException x = TApplicationException.read(iprot_);
         iprot_.readMessageEnd();
         throw x;
       }
       get_column_result result = new get_column_result();
       result.read(iprot_);
       iprot_.readMessageEnd();
       if (result.isSetSuccess()) {
         return result.success;
       }
       if (result.ire != null) {
         throw result.ire;
       }
       if (result.nfe != null) {
         throw result.nfe;
       }
       throw new TApplicationException(TApplicationException.MISSING_RESULT, "get_column failed: unknown result");
     }
 
     public int get_column_count(String table, String key, ColumnParent column_parent) throws InvalidRequestException, TException
     {
       send_get_column_count(table, key, column_parent);
       return recv_get_column_count();
     }
 
     public void send_get_column_count(String table, String key, ColumnParent column_parent) throws TException
     {
       oprot_.writeMessageBegin(new TMessage("get_column_count", TMessageType.CALL, seqid_));
       get_column_count_args args = new get_column_count_args();
       args.table = table;
       args.key = key;
       args.column_parent = column_parent;
       args.write(oprot_);
       oprot_.writeMessageEnd();
       oprot_.getTransport().flush();
     }
 
     public int recv_get_column_count() throws InvalidRequestException, TException
     {
       TMessage msg = iprot_.readMessageBegin();
       if (msg.type == TMessageType.EXCEPTION) {
         TApplicationException x = TApplicationException.read(iprot_);
         iprot_.readMessageEnd();
         throw x;
       }
       get_column_count_result result = new get_column_count_result();
       result.read(iprot_);
       iprot_.readMessageEnd();
       if (result.isSetSuccess()) {
         return result.success;
       }
       if (result.ire != null) {
         throw result.ire;
       }
       throw new TApplicationException(TApplicationException.MISSING_RESULT, "get_column_count failed: unknown result");
     }
 
     public void insert(String table, String key, ColumnPath column_path, byte[] value, long timestamp, int block_for) throws InvalidRequestException, UnavailableException, TException
     {
       send_insert(table, key, column_path, value, timestamp, block_for);
       recv_insert();
     }
 
     public void send_insert(String table, String key, ColumnPath column_path, byte[] value, long timestamp, int block_for) throws TException
     {
       oprot_.writeMessageBegin(new TMessage("insert", TMessageType.CALL, seqid_));
       insert_args args = new insert_args();
       args.table = table;
       args.key = key;
       args.column_path = column_path;
       args.value = value;
       args.timestamp = timestamp;
       args.block_for = block_for;
       args.write(oprot_);
       oprot_.writeMessageEnd();
       oprot_.getTransport().flush();
     }
 
     public void recv_insert() throws InvalidRequestException, UnavailableException, TException
     {
       TMessage msg = iprot_.readMessageBegin();
       if (msg.type == TMessageType.EXCEPTION) {
         TApplicationException x = TApplicationException.read(iprot_);
         iprot_.readMessageEnd();
         throw x;
       }
       insert_result result = new insert_result();
       result.read(iprot_);
       iprot_.readMessageEnd();
       if (result.ire != null) {
         throw result.ire;
       }
       if (result.ue != null) {
         throw result.ue;
       }
       return;
     }
 
     public void batch_insert(String table, BatchMutation batch_mutation, int block_for) throws InvalidRequestException, UnavailableException, TException
     {
       send_batch_insert(table, batch_mutation, block_for);
       recv_batch_insert();
     }
 
     public void send_batch_insert(String table, BatchMutation batch_mutation, int block_for) throws TException
     {
       oprot_.writeMessageBegin(new TMessage("batch_insert", TMessageType.CALL, seqid_));
       batch_insert_args args = new batch_insert_args();
       args.table = table;
       args.batch_mutation = batch_mutation;
       args.block_for = block_for;
       args.write(oprot_);
       oprot_.writeMessageEnd();
       oprot_.getTransport().flush();
     }
 
     public void recv_batch_insert() throws InvalidRequestException, UnavailableException, TException
     {
       TMessage msg = iprot_.readMessageBegin();
       if (msg.type == TMessageType.EXCEPTION) {
         TApplicationException x = TApplicationException.read(iprot_);
         iprot_.readMessageEnd();
         throw x;
       }
       batch_insert_result result = new batch_insert_result();
       result.read(iprot_);
       iprot_.readMessageEnd();
       if (result.ire != null) {
         throw result.ire;
       }
       if (result.ue != null) {
         throw result.ue;
       }
       return;
     }
 
     public void remove(String table, String key, ColumnPathOrParent column_path_or_parent, long timestamp, int block_for) throws InvalidRequestException, UnavailableException, TException
     {
       send_remove(table, key, column_path_or_parent, timestamp, block_for);
       recv_remove();
     }
 
     public void send_remove(String table, String key, ColumnPathOrParent column_path_or_parent, long timestamp, int block_for) throws TException
     {
       oprot_.writeMessageBegin(new TMessage("remove", TMessageType.CALL, seqid_));
       remove_args args = new remove_args();
       args.table = table;
       args.key = key;
       args.column_path_or_parent = column_path_or_parent;
       args.timestamp = timestamp;
       args.block_for = block_for;
       args.write(oprot_);
       oprot_.writeMessageEnd();
       oprot_.getTransport().flush();
     }
 
     public void recv_remove() throws InvalidRequestException, UnavailableException, TException
     {
       TMessage msg = iprot_.readMessageBegin();
       if (msg.type == TMessageType.EXCEPTION) {
         TApplicationException x = TApplicationException.read(iprot_);
         iprot_.readMessageEnd();
         throw x;
       }
       remove_result result = new remove_result();
       result.read(iprot_);
       iprot_.readMessageEnd();
       if (result.ire != null) {
         throw result.ire;
       }
       if (result.ue != null) {
         throw result.ue;
       }
       return;
     }
 
     public List<SuperColumn> get_slice_super(String table, String key, String column_family, byte[] start, byte[] finish, boolean is_ascending, int count) throws InvalidRequestException, TException
     {
       send_get_slice_super(table, key, column_family, start, finish, is_ascending, count);
       return recv_get_slice_super();
     }
 
     public void send_get_slice_super(String table, String key, String column_family, byte[] start, byte[] finish, boolean is_ascending, int count) throws TException
     {
       oprot_.writeMessageBegin(new TMessage("get_slice_super", TMessageType.CALL, seqid_));
       get_slice_super_args args = new get_slice_super_args();
       args.table = table;
       args.key = key;
       args.column_family = column_family;
       args.start = start;
       args.finish = finish;
       args.is_ascending = is_ascending;
       args.count = count;
       args.write(oprot_);
       oprot_.writeMessageEnd();
       oprot_.getTransport().flush();
     }
 
     public List<SuperColumn> recv_get_slice_super() throws InvalidRequestException, TException
     {
       TMessage msg = iprot_.readMessageBegin();
       if (msg.type == TMessageType.EXCEPTION) {
         TApplicationException x = TApplicationException.read(iprot_);
         iprot_.readMessageEnd();
         throw x;
       }
       get_slice_super_result result = new get_slice_super_result();
       result.read(iprot_);
       iprot_.readMessageEnd();
       if (result.isSetSuccess()) {
         return result.success;
       }
       if (result.ire != null) {
         throw result.ire;
       }
       throw new TApplicationException(TApplicationException.MISSING_RESULT, "get_slice_super failed: unknown result");
     }
 
     public List<SuperColumn> get_slice_super_by_names(String table, String key, String column_family, List<byte[]> super_column_names) throws InvalidRequestException, TException
     {
       send_get_slice_super_by_names(table, key, column_family, super_column_names);
       return recv_get_slice_super_by_names();
     }
 
     public void send_get_slice_super_by_names(String table, String key, String column_family, List<byte[]> super_column_names) throws TException
     {
       oprot_.writeMessageBegin(new TMessage("get_slice_super_by_names", TMessageType.CALL, seqid_));
       get_slice_super_by_names_args args = new get_slice_super_by_names_args();
       args.table = table;
       args.key = key;
       args.column_family = column_family;
       args.super_column_names = super_column_names;
       args.write(oprot_);
       oprot_.writeMessageEnd();
       oprot_.getTransport().flush();
     }
 
     public List<SuperColumn> recv_get_slice_super_by_names() throws InvalidRequestException, TException
     {
       TMessage msg = iprot_.readMessageBegin();
       if (msg.type == TMessageType.EXCEPTION) {
         TApplicationException x = TApplicationException.read(iprot_);
         iprot_.readMessageEnd();
         throw x;
       }
       get_slice_super_by_names_result result = new get_slice_super_by_names_result();
       result.read(iprot_);
       iprot_.readMessageEnd();
       if (result.isSetSuccess()) {
         return result.success;
       }
       if (result.ire != null) {
         throw result.ire;
       }
       throw new TApplicationException(TApplicationException.MISSING_RESULT, "get_slice_super_by_names failed: unknown result");
     }
 
     public SuperColumn get_super_column(String table, String key, SuperColumnPath super_column_path) throws InvalidRequestException, NotFoundException, TException
     {
       send_get_super_column(table, key, super_column_path);
       return recv_get_super_column();
     }
 
     public void send_get_super_column(String table, String key, SuperColumnPath super_column_path) throws TException
     {
       oprot_.writeMessageBegin(new TMessage("get_super_column", TMessageType.CALL, seqid_));
       get_super_column_args args = new get_super_column_args();
       args.table = table;
       args.key = key;
       args.super_column_path = super_column_path;
       args.write(oprot_);
       oprot_.writeMessageEnd();
       oprot_.getTransport().flush();
     }
 
     public SuperColumn recv_get_super_column() throws InvalidRequestException, NotFoundException, TException
     {
       TMessage msg = iprot_.readMessageBegin();
       if (msg.type == TMessageType.EXCEPTION) {
         TApplicationException x = TApplicationException.read(iprot_);
         iprot_.readMessageEnd();
         throw x;
       }
       get_super_column_result result = new get_super_column_result();
       result.read(iprot_);
       iprot_.readMessageEnd();
       if (result.isSetSuccess()) {
         return result.success;
       }
       if (result.ire != null) {
         throw result.ire;
       }
       if (result.nfe != null) {
         throw result.nfe;
       }
       throw new TApplicationException(TApplicationException.MISSING_RESULT, "get_super_column failed: unknown result");
     }
 
     public void batch_insert_super_column(String table, BatchMutationSuper batch_mutation_super, int block_for) throws InvalidRequestException, UnavailableException, TException
     {
       send_batch_insert_super_column(table, batch_mutation_super, block_for);
       recv_batch_insert_super_column();
     }
 
     public void send_batch_insert_super_column(String table, BatchMutationSuper batch_mutation_super, int block_for) throws TException
     {
       oprot_.writeMessageBegin(new TMessage("batch_insert_super_column", TMessageType.CALL, seqid_));
       batch_insert_super_column_args args = new batch_insert_super_column_args();
       args.table = table;
       args.batch_mutation_super = batch_mutation_super;
       args.block_for = block_for;
       args.write(oprot_);
       oprot_.writeMessageEnd();
       oprot_.getTransport().flush();
     }
 
     public void recv_batch_insert_super_column() throws InvalidRequestException, UnavailableException, TException
     {
       TMessage msg = iprot_.readMessageBegin();
       if (msg.type == TMessageType.EXCEPTION) {
         TApplicationException x = TApplicationException.read(iprot_);
         iprot_.readMessageEnd();
         throw x;
       }
       batch_insert_super_column_result result = new batch_insert_super_column_result();
       result.read(iprot_);
       iprot_.readMessageEnd();
       if (result.ire != null) {
         throw result.ire;
       }
       if (result.ue != null) {
         throw result.ue;
       }
       return;
     }
 
    public List<String> get_key_range(String table, String column_family, String startWith, String stopAt, int maxResults) throws InvalidRequestException, TException
     {
      send_get_key_range(table, column_family, startWith, stopAt, maxResults);
       return recv_get_key_range();
     }
 
    public void send_get_key_range(String table, String column_family, String startWith, String stopAt, int maxResults) throws TException
     {
       oprot_.writeMessageBegin(new TMessage("get_key_range", TMessageType.CALL, seqid_));
       get_key_range_args args = new get_key_range_args();
       args.table = table;
       args.column_family = column_family;
      args.startWith = startWith;
      args.stopAt = stopAt;
      args.maxResults = maxResults;
       args.write(oprot_);
       oprot_.writeMessageEnd();
       oprot_.getTransport().flush();
     }
 
     public List<String> recv_get_key_range() throws InvalidRequestException, TException
     {
       TMessage msg = iprot_.readMessageBegin();
       if (msg.type == TMessageType.EXCEPTION) {
         TApplicationException x = TApplicationException.read(iprot_);
         iprot_.readMessageEnd();
         throw x;
       }
       get_key_range_result result = new get_key_range_result();
       result.read(iprot_);
       iprot_.readMessageEnd();
       if (result.isSetSuccess()) {
         return result.success;
       }
       if (result.ire != null) {
         throw result.ire;
       }
       throw new TApplicationException(TApplicationException.MISSING_RESULT, "get_key_range failed: unknown result");
     }
 
    public String getStringProperty(String propertyName) throws TException
     {
      send_getStringProperty(propertyName);
      return recv_getStringProperty();
     }
 
    public void send_getStringProperty(String propertyName) throws TException
     {
      oprot_.writeMessageBegin(new TMessage("getStringProperty", TMessageType.CALL, seqid_));
      getStringProperty_args args = new getStringProperty_args();
      args.propertyName = propertyName;
       args.write(oprot_);
       oprot_.writeMessageEnd();
       oprot_.getTransport().flush();
     }
 
    public String recv_getStringProperty() throws TException
     {
       TMessage msg = iprot_.readMessageBegin();
       if (msg.type == TMessageType.EXCEPTION) {
         TApplicationException x = TApplicationException.read(iprot_);
         iprot_.readMessageEnd();
         throw x;
       }
      getStringProperty_result result = new getStringProperty_result();
       result.read(iprot_);
       iprot_.readMessageEnd();
       if (result.isSetSuccess()) {
         return result.success;
       }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "getStringProperty failed: unknown result");
     }
 
    public List<String> getStringListProperty(String propertyName) throws TException
     {
      send_getStringListProperty(propertyName);
      return recv_getStringListProperty();
     }
 
    public void send_getStringListProperty(String propertyName) throws TException
     {
      oprot_.writeMessageBegin(new TMessage("getStringListProperty", TMessageType.CALL, seqid_));
      getStringListProperty_args args = new getStringListProperty_args();
      args.propertyName = propertyName;
       args.write(oprot_);
       oprot_.writeMessageEnd();
       oprot_.getTransport().flush();
     }
 
    public List<String> recv_getStringListProperty() throws TException
     {
       TMessage msg = iprot_.readMessageBegin();
       if (msg.type == TMessageType.EXCEPTION) {
         TApplicationException x = TApplicationException.read(iprot_);
         iprot_.readMessageEnd();
         throw x;
       }
      getStringListProperty_result result = new getStringListProperty_result();
       result.read(iprot_);
       iprot_.readMessageEnd();
       if (result.isSetSuccess()) {
         return result.success;
       }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "getStringListProperty failed: unknown result");
     }
 
    public Map<String,Map<String,String>> describeTable(String tableName) throws NotFoundException, TException
     {
      send_describeTable(tableName);
      return recv_describeTable();
     }
 
    public void send_describeTable(String tableName) throws TException
     {
      oprot_.writeMessageBegin(new TMessage("describeTable", TMessageType.CALL, seqid_));
      describeTable_args args = new describeTable_args();
      args.tableName = tableName;
       args.write(oprot_);
       oprot_.writeMessageEnd();
       oprot_.getTransport().flush();
     }
 
    public Map<String,Map<String,String>> recv_describeTable() throws NotFoundException, TException
     {
       TMessage msg = iprot_.readMessageBegin();
       if (msg.type == TMessageType.EXCEPTION) {
         TApplicationException x = TApplicationException.read(iprot_);
         iprot_.readMessageEnd();
         throw x;
       }
      describeTable_result result = new describeTable_result();
       result.read(iprot_);
       iprot_.readMessageEnd();
       if (result.isSetSuccess()) {
         return result.success;
       }
       if (result.nfe != null) {
         throw result.nfe;
       }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "describeTable failed: unknown result");
     }
 
    public CqlResult executeQuery(String query) throws TException
     {
      send_executeQuery(query);
      return recv_executeQuery();
     }
 
    public void send_executeQuery(String query) throws TException
     {
      oprot_.writeMessageBegin(new TMessage("executeQuery", TMessageType.CALL, seqid_));
      executeQuery_args args = new executeQuery_args();
       args.query = query;
       args.write(oprot_);
       oprot_.writeMessageEnd();
       oprot_.getTransport().flush();
     }
 
    public CqlResult recv_executeQuery() throws TException
     {
       TMessage msg = iprot_.readMessageBegin();
       if (msg.type == TMessageType.EXCEPTION) {
         TApplicationException x = TApplicationException.read(iprot_);
         iprot_.readMessageEnd();
         throw x;
       }
      executeQuery_result result = new executeQuery_result();
       result.read(iprot_);
       iprot_.readMessageEnd();
       if (result.isSetSuccess()) {
         return result.success;
       }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "executeQuery failed: unknown result");
     }
 
   }
   public static class Processor implements TProcessor {
     private static final Logger LOGGER = Logger.getLogger(Processor.class.getName());
     public Processor(Iface iface)
     {
       iface_ = iface;
       processMap_.put("get_slice_by_names", new get_slice_by_names());
       processMap_.put("get_slice", new get_slice());
       processMap_.put("get_column", new get_column());
       processMap_.put("get_column_count", new get_column_count());
       processMap_.put("insert", new insert());
       processMap_.put("batch_insert", new batch_insert());
       processMap_.put("remove", new remove());
       processMap_.put("get_slice_super", new get_slice_super());
       processMap_.put("get_slice_super_by_names", new get_slice_super_by_names());
       processMap_.put("get_super_column", new get_super_column());
       processMap_.put("batch_insert_super_column", new batch_insert_super_column());
       processMap_.put("get_key_range", new get_key_range());
      processMap_.put("getStringProperty", new getStringProperty());
      processMap_.put("getStringListProperty", new getStringListProperty());
      processMap_.put("describeTable", new describeTable());
      processMap_.put("executeQuery", new executeQuery());
     }
 
     protected static interface ProcessFunction {
       public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException;
     }
 
     private Iface iface_;
     protected final HashMap<String,ProcessFunction> processMap_ = new HashMap<String,ProcessFunction>();
 
     public boolean process(TProtocol iprot, TProtocol oprot) throws TException
     {
       TMessage msg = iprot.readMessageBegin();
       ProcessFunction fn = processMap_.get(msg.name);
       if (fn == null) {
         TProtocolUtil.skip(iprot, TType.STRUCT);
         iprot.readMessageEnd();
         TApplicationException x = new TApplicationException(TApplicationException.UNKNOWN_METHOD, "Invalid method name: '"+msg.name+"'");
         oprot.writeMessageBegin(new TMessage(msg.name, TMessageType.EXCEPTION, msg.seqid));
         x.write(oprot);
         oprot.writeMessageEnd();
         oprot.getTransport().flush();
         return true;
       }
       fn.process(msg.seqid, iprot, oprot);
       return true;
     }
 
     private class get_slice_by_names implements ProcessFunction {
       public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
       {
         get_slice_by_names_args args = new get_slice_by_names_args();
         args.read(iprot);
         iprot.readMessageEnd();
         get_slice_by_names_result result = new get_slice_by_names_result();
         try {
           result.success = iface_.get_slice_by_names(args.table, args.key, args.column_parent, args.column_names);
         } catch (InvalidRequestException ire) {
           result.ire = ire;
         } catch (NotFoundException nfe) {
           result.nfe = nfe;
         } catch (Throwable th) {
           LOGGER.error("Internal error processing get_slice_by_names", th);
           TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing get_slice_by_names");
           oprot.writeMessageBegin(new TMessage("get_slice_by_names", TMessageType.EXCEPTION, seqid));
           x.write(oprot);
           oprot.writeMessageEnd();
           oprot.getTransport().flush();
           return;
         }
         oprot.writeMessageBegin(new TMessage("get_slice_by_names", TMessageType.REPLY, seqid));
         result.write(oprot);
         oprot.writeMessageEnd();
         oprot.getTransport().flush();
       }
 
     }
 
     private class get_slice implements ProcessFunction {
       public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
       {
         get_slice_args args = new get_slice_args();
         args.read(iprot);
         iprot.readMessageEnd();
         get_slice_result result = new get_slice_result();
         try {
           result.success = iface_.get_slice(args.table, args.key, args.column_parent, args.start, args.finish, args.is_ascending, args.count);
         } catch (InvalidRequestException ire) {
           result.ire = ire;
         } catch (NotFoundException nfe) {
           result.nfe = nfe;
         } catch (Throwable th) {
           LOGGER.error("Internal error processing get_slice", th);
           TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing get_slice");
           oprot.writeMessageBegin(new TMessage("get_slice", TMessageType.EXCEPTION, seqid));
           x.write(oprot);
           oprot.writeMessageEnd();
           oprot.getTransport().flush();
           return;
         }
         oprot.writeMessageBegin(new TMessage("get_slice", TMessageType.REPLY, seqid));
         result.write(oprot);
         oprot.writeMessageEnd();
         oprot.getTransport().flush();
       }
 
     }
 
     private class get_column implements ProcessFunction {
       public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
       {
         get_column_args args = new get_column_args();
         args.read(iprot);
         iprot.readMessageEnd();
         get_column_result result = new get_column_result();
         try {
           result.success = iface_.get_column(args.table, args.key, args.column_path);
         } catch (InvalidRequestException ire) {
           result.ire = ire;
         } catch (NotFoundException nfe) {
           result.nfe = nfe;
         } catch (Throwable th) {
           LOGGER.error("Internal error processing get_column", th);
           TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing get_column");
           oprot.writeMessageBegin(new TMessage("get_column", TMessageType.EXCEPTION, seqid));
           x.write(oprot);
           oprot.writeMessageEnd();
           oprot.getTransport().flush();
           return;
         }
         oprot.writeMessageBegin(new TMessage("get_column", TMessageType.REPLY, seqid));
         result.write(oprot);
         oprot.writeMessageEnd();
         oprot.getTransport().flush();
       }
 
     }
 
     private class get_column_count implements ProcessFunction {
       public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
       {
         get_column_count_args args = new get_column_count_args();
         args.read(iprot);
         iprot.readMessageEnd();
         get_column_count_result result = new get_column_count_result();
         try {
           result.success = iface_.get_column_count(args.table, args.key, args.column_parent);
           result.__isset.success = true;
         } catch (InvalidRequestException ire) {
           result.ire = ire;
         } catch (Throwable th) {
           LOGGER.error("Internal error processing get_column_count", th);
           TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing get_column_count");
           oprot.writeMessageBegin(new TMessage("get_column_count", TMessageType.EXCEPTION, seqid));
           x.write(oprot);
           oprot.writeMessageEnd();
           oprot.getTransport().flush();
           return;
         }
         oprot.writeMessageBegin(new TMessage("get_column_count", TMessageType.REPLY, seqid));
         result.write(oprot);
         oprot.writeMessageEnd();
         oprot.getTransport().flush();
       }
 
     }
 
     private class insert implements ProcessFunction {
       public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
       {
         insert_args args = new insert_args();
         args.read(iprot);
         iprot.readMessageEnd();
         insert_result result = new insert_result();
         try {
           iface_.insert(args.table, args.key, args.column_path, args.value, args.timestamp, args.block_for);
         } catch (InvalidRequestException ire) {
           result.ire = ire;
         } catch (UnavailableException ue) {
           result.ue = ue;
         } catch (Throwable th) {
           LOGGER.error("Internal error processing insert", th);
           TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing insert");
           oprot.writeMessageBegin(new TMessage("insert", TMessageType.EXCEPTION, seqid));
           x.write(oprot);
           oprot.writeMessageEnd();
           oprot.getTransport().flush();
           return;
         }
         oprot.writeMessageBegin(new TMessage("insert", TMessageType.REPLY, seqid));
         result.write(oprot);
         oprot.writeMessageEnd();
         oprot.getTransport().flush();
       }
 
     }
 
     private class batch_insert implements ProcessFunction {
       public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
       {
         batch_insert_args args = new batch_insert_args();
         args.read(iprot);
         iprot.readMessageEnd();
         batch_insert_result result = new batch_insert_result();
         try {
           iface_.batch_insert(args.table, args.batch_mutation, args.block_for);
         } catch (InvalidRequestException ire) {
           result.ire = ire;
         } catch (UnavailableException ue) {
           result.ue = ue;
         } catch (Throwable th) {
           LOGGER.error("Internal error processing batch_insert", th);
           TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing batch_insert");
           oprot.writeMessageBegin(new TMessage("batch_insert", TMessageType.EXCEPTION, seqid));
           x.write(oprot);
           oprot.writeMessageEnd();
           oprot.getTransport().flush();
           return;
         }
         oprot.writeMessageBegin(new TMessage("batch_insert", TMessageType.REPLY, seqid));
         result.write(oprot);
         oprot.writeMessageEnd();
         oprot.getTransport().flush();
       }
 
     }
 
     private class remove implements ProcessFunction {
       public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
       {
         remove_args args = new remove_args();
         args.read(iprot);
         iprot.readMessageEnd();
         remove_result result = new remove_result();
         try {
           iface_.remove(args.table, args.key, args.column_path_or_parent, args.timestamp, args.block_for);
         } catch (InvalidRequestException ire) {
           result.ire = ire;
         } catch (UnavailableException ue) {
           result.ue = ue;
         } catch (Throwable th) {
           LOGGER.error("Internal error processing remove", th);
           TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing remove");
           oprot.writeMessageBegin(new TMessage("remove", TMessageType.EXCEPTION, seqid));
           x.write(oprot);
           oprot.writeMessageEnd();
           oprot.getTransport().flush();
           return;
         }
         oprot.writeMessageBegin(new TMessage("remove", TMessageType.REPLY, seqid));
         result.write(oprot);
         oprot.writeMessageEnd();
         oprot.getTransport().flush();
       }
 
     }
 
     private class get_slice_super implements ProcessFunction {
       public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
       {
         get_slice_super_args args = new get_slice_super_args();
         args.read(iprot);
         iprot.readMessageEnd();
         get_slice_super_result result = new get_slice_super_result();
         try {
           result.success = iface_.get_slice_super(args.table, args.key, args.column_family, args.start, args.finish, args.is_ascending, args.count);
         } catch (InvalidRequestException ire) {
           result.ire = ire;
         } catch (Throwable th) {
           LOGGER.error("Internal error processing get_slice_super", th);
           TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing get_slice_super");
           oprot.writeMessageBegin(new TMessage("get_slice_super", TMessageType.EXCEPTION, seqid));
           x.write(oprot);
           oprot.writeMessageEnd();
           oprot.getTransport().flush();
           return;
         }
         oprot.writeMessageBegin(new TMessage("get_slice_super", TMessageType.REPLY, seqid));
         result.write(oprot);
         oprot.writeMessageEnd();
         oprot.getTransport().flush();
       }
 
     }
 
     private class get_slice_super_by_names implements ProcessFunction {
       public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
       {
         get_slice_super_by_names_args args = new get_slice_super_by_names_args();
         args.read(iprot);
         iprot.readMessageEnd();
         get_slice_super_by_names_result result = new get_slice_super_by_names_result();
         try {
           result.success = iface_.get_slice_super_by_names(args.table, args.key, args.column_family, args.super_column_names);
         } catch (InvalidRequestException ire) {
           result.ire = ire;
         } catch (Throwable th) {
           LOGGER.error("Internal error processing get_slice_super_by_names", th);
           TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing get_slice_super_by_names");
           oprot.writeMessageBegin(new TMessage("get_slice_super_by_names", TMessageType.EXCEPTION, seqid));
           x.write(oprot);
           oprot.writeMessageEnd();
           oprot.getTransport().flush();
           return;
         }
         oprot.writeMessageBegin(new TMessage("get_slice_super_by_names", TMessageType.REPLY, seqid));
         result.write(oprot);
         oprot.writeMessageEnd();
         oprot.getTransport().flush();
       }
 
     }
 
     private class get_super_column implements ProcessFunction {
       public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
       {
         get_super_column_args args = new get_super_column_args();
         args.read(iprot);
         iprot.readMessageEnd();
         get_super_column_result result = new get_super_column_result();
         try {
           result.success = iface_.get_super_column(args.table, args.key, args.super_column_path);
         } catch (InvalidRequestException ire) {
           result.ire = ire;
         } catch (NotFoundException nfe) {
           result.nfe = nfe;
         } catch (Throwable th) {
           LOGGER.error("Internal error processing get_super_column", th);
           TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing get_super_column");
           oprot.writeMessageBegin(new TMessage("get_super_column", TMessageType.EXCEPTION, seqid));
           x.write(oprot);
           oprot.writeMessageEnd();
           oprot.getTransport().flush();
           return;
         }
         oprot.writeMessageBegin(new TMessage("get_super_column", TMessageType.REPLY, seqid));
         result.write(oprot);
         oprot.writeMessageEnd();
         oprot.getTransport().flush();
       }
 
     }
 
     private class batch_insert_super_column implements ProcessFunction {
       public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
       {
         batch_insert_super_column_args args = new batch_insert_super_column_args();
         args.read(iprot);
         iprot.readMessageEnd();
         batch_insert_super_column_result result = new batch_insert_super_column_result();
         try {
           iface_.batch_insert_super_column(args.table, args.batch_mutation_super, args.block_for);
         } catch (InvalidRequestException ire) {
           result.ire = ire;
         } catch (UnavailableException ue) {
           result.ue = ue;
         } catch (Throwable th) {
           LOGGER.error("Internal error processing batch_insert_super_column", th);
           TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing batch_insert_super_column");
           oprot.writeMessageBegin(new TMessage("batch_insert_super_column", TMessageType.EXCEPTION, seqid));
           x.write(oprot);
           oprot.writeMessageEnd();
           oprot.getTransport().flush();
           return;
         }
         oprot.writeMessageBegin(new TMessage("batch_insert_super_column", TMessageType.REPLY, seqid));
         result.write(oprot);
         oprot.writeMessageEnd();
         oprot.getTransport().flush();
       }
 
     }
 
     private class get_key_range implements ProcessFunction {
       public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
       {
         get_key_range_args args = new get_key_range_args();
         args.read(iprot);
         iprot.readMessageEnd();
         get_key_range_result result = new get_key_range_result();
         try {
          result.success = iface_.get_key_range(args.table, args.column_family, args.startWith, args.stopAt, args.maxResults);
         } catch (InvalidRequestException ire) {
           result.ire = ire;
         } catch (Throwable th) {
           LOGGER.error("Internal error processing get_key_range", th);
           TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing get_key_range");
           oprot.writeMessageBegin(new TMessage("get_key_range", TMessageType.EXCEPTION, seqid));
           x.write(oprot);
           oprot.writeMessageEnd();
           oprot.getTransport().flush();
           return;
         }
         oprot.writeMessageBegin(new TMessage("get_key_range", TMessageType.REPLY, seqid));
         result.write(oprot);
         oprot.writeMessageEnd();
         oprot.getTransport().flush();
       }
 
     }
 
    private class getStringProperty implements ProcessFunction {
       public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
       {
        getStringProperty_args args = new getStringProperty_args();
         args.read(iprot);
         iprot.readMessageEnd();
        getStringProperty_result result = new getStringProperty_result();
        result.success = iface_.getStringProperty(args.propertyName);
        oprot.writeMessageBegin(new TMessage("getStringProperty", TMessageType.REPLY, seqid));
         result.write(oprot);
         oprot.writeMessageEnd();
         oprot.getTransport().flush();
       }
 
     }
 
    private class getStringListProperty implements ProcessFunction {
       public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
       {
        getStringListProperty_args args = new getStringListProperty_args();
         args.read(iprot);
         iprot.readMessageEnd();
        getStringListProperty_result result = new getStringListProperty_result();
        result.success = iface_.getStringListProperty(args.propertyName);
        oprot.writeMessageBegin(new TMessage("getStringListProperty", TMessageType.REPLY, seqid));
         result.write(oprot);
         oprot.writeMessageEnd();
         oprot.getTransport().flush();
       }
 
     }
 
    private class describeTable implements ProcessFunction {
       public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
       {
        describeTable_args args = new describeTable_args();
         args.read(iprot);
         iprot.readMessageEnd();
        describeTable_result result = new describeTable_result();
         try {
          result.success = iface_.describeTable(args.tableName);
         } catch (NotFoundException nfe) {
           result.nfe = nfe;
         } catch (Throwable th) {
          LOGGER.error("Internal error processing describeTable", th);
          TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing describeTable");
          oprot.writeMessageBegin(new TMessage("describeTable", TMessageType.EXCEPTION, seqid));
           x.write(oprot);
           oprot.writeMessageEnd();
           oprot.getTransport().flush();
           return;
         }
        oprot.writeMessageBegin(new TMessage("describeTable", TMessageType.REPLY, seqid));
         result.write(oprot);
         oprot.writeMessageEnd();
         oprot.getTransport().flush();
       }
 
     }
 
    private class executeQuery implements ProcessFunction {
       public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
       {
        executeQuery_args args = new executeQuery_args();
         args.read(iprot);
         iprot.readMessageEnd();
        executeQuery_result result = new executeQuery_result();
        result.success = iface_.executeQuery(args.query);
        oprot.writeMessageBegin(new TMessage("executeQuery", TMessageType.REPLY, seqid));
         result.write(oprot);
         oprot.writeMessageEnd();
         oprot.getTransport().flush();
       }
 
     }
 
   }
 
   public static class get_slice_by_names_args implements TBase, java.io.Serializable, Cloneable   {
     private static final TStruct STRUCT_DESC = new TStruct("get_slice_by_names_args");
     private static final TField TABLE_FIELD_DESC = new TField("table", TType.STRING, (short)1);
     private static final TField KEY_FIELD_DESC = new TField("key", TType.STRING, (short)2);
     private static final TField COLUMN_PARENT_FIELD_DESC = new TField("column_parent", TType.STRUCT, (short)3);
     private static final TField COLUMN_NAMES_FIELD_DESC = new TField("column_names", TType.LIST, (short)4);
 
     public String table;
     public static final int TABLE = 1;
     public String key;
     public static final int KEY = 2;
     public ColumnParent column_parent;
     public static final int COLUMN_PARENT = 3;
     public List<byte[]> column_names;
     public static final int COLUMN_NAMES = 4;
 
     private final Isset __isset = new Isset();
     private static final class Isset implements java.io.Serializable {
     }
 
     public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
       put(TABLE, new FieldMetaData("table", TFieldRequirementType.DEFAULT, 
           new FieldValueMetaData(TType.STRING)));
       put(KEY, new FieldMetaData("key", TFieldRequirementType.DEFAULT, 
           new FieldValueMetaData(TType.STRING)));
       put(COLUMN_PARENT, new FieldMetaData("column_parent", TFieldRequirementType.DEFAULT, 
           new StructMetaData(TType.STRUCT, ColumnParent.class)));
       put(COLUMN_NAMES, new FieldMetaData("column_names", TFieldRequirementType.DEFAULT, 
           new ListMetaData(TType.LIST, 
               new FieldValueMetaData(TType.STRING))));
     }});
 
     static {
       FieldMetaData.addStructMetaDataMap(get_slice_by_names_args.class, metaDataMap);
     }
 
     public get_slice_by_names_args() {
     }
 
     public get_slice_by_names_args(
       String table,
       String key,
       ColumnParent column_parent,
       List<byte[]> column_names)
     {
       this();
       this.table = table;
       this.key = key;
       this.column_parent = column_parent;
       this.column_names = column_names;
     }
 
     /**
      * Performs a deep copy on <i>other</i>.
      */
     public get_slice_by_names_args(get_slice_by_names_args other) {
       if (other.isSetTable()) {
         this.table = other.table;
       }
       if (other.isSetKey()) {
         this.key = other.key;
       }
       if (other.isSetColumn_parent()) {
         this.column_parent = new ColumnParent(other.column_parent);
       }
       if (other.isSetColumn_names()) {
         List<byte[]> __this__column_names = new ArrayList<byte[]>();
         for (byte[] other_element : other.column_names) {
           byte[] temp_binary_element = new byte[other_element.length];
           System.arraycopy(other_element, 0, temp_binary_element, 0, other_element.length);
           __this__column_names.add(temp_binary_element);
         }
         this.column_names = __this__column_names;
       }
     }
 
     @Override
     public get_slice_by_names_args clone() {
       return new get_slice_by_names_args(this);
     }
 
     public String getTable() {
       return this.table;
     }
 
     public void setTable(String table) {
       this.table = table;
     }
 
     public void unsetTable() {
       this.table = null;
     }
 
     // Returns true if field table is set (has been asigned a value) and false otherwise
     public boolean isSetTable() {
       return this.table != null;
     }
 
     public void setTableIsSet(boolean value) {
       if (!value) {
         this.table = null;
       }
     }
 
     public String getKey() {
       return this.key;
     }
 
     public void setKey(String key) {
       this.key = key;
     }
 
     public void unsetKey() {
       this.key = null;
     }
 
     // Returns true if field key is set (has been asigned a value) and false otherwise
     public boolean isSetKey() {
       return this.key != null;
     }
 
     public void setKeyIsSet(boolean value) {
       if (!value) {
         this.key = null;
       }
     }
 
     public ColumnParent getColumn_parent() {
       return this.column_parent;
     }
 
     public void setColumn_parent(ColumnParent column_parent) {
       this.column_parent = column_parent;
     }
 
     public void unsetColumn_parent() {
       this.column_parent = null;
     }
 
     // Returns true if field column_parent is set (has been asigned a value) and false otherwise
     public boolean isSetColumn_parent() {
       return this.column_parent != null;
     }
 
     public void setColumn_parentIsSet(boolean value) {
       if (!value) {
         this.column_parent = null;
       }
     }
 
     public int getColumn_namesSize() {
       return (this.column_names == null) ? 0 : this.column_names.size();
     }
 
     public java.util.Iterator<byte[]> getColumn_namesIterator() {
       return (this.column_names == null) ? null : this.column_names.iterator();
     }
 
     public void addToColumn_names(byte[] elem) {
       if (this.column_names == null) {
         this.column_names = new ArrayList<byte[]>();
       }
       this.column_names.add(elem);
     }
 
     public List<byte[]> getColumn_names() {
       return this.column_names;
     }
 
     public void setColumn_names(List<byte[]> column_names) {
       this.column_names = column_names;
     }
 
     public void unsetColumn_names() {
       this.column_names = null;
     }
 
     // Returns true if field column_names is set (has been asigned a value) and false otherwise
     public boolean isSetColumn_names() {
       return this.column_names != null;
     }
 
     public void setColumn_namesIsSet(boolean value) {
       if (!value) {
         this.column_names = null;
       }
     }
 
     public void setFieldValue(int fieldID, Object value) {
       switch (fieldID) {
       case TABLE:
         if (value == null) {
           unsetTable();
         } else {
           setTable((String)value);
         }
         break;
 
       case KEY:
         if (value == null) {
           unsetKey();
         } else {
           setKey((String)value);
         }
         break;
 
       case COLUMN_PARENT:
         if (value == null) {
           unsetColumn_parent();
         } else {
           setColumn_parent((ColumnParent)value);
         }
         break;
 
       case COLUMN_NAMES:
         if (value == null) {
           unsetColumn_names();
         } else {
           setColumn_names((List<byte[]>)value);
         }
         break;
 
       default:
         throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
       }
     }
 
     public Object getFieldValue(int fieldID) {
       switch (fieldID) {
       case TABLE:
         return getTable();
 
       case KEY:
         return getKey();
 
       case COLUMN_PARENT:
         return getColumn_parent();
 
       case COLUMN_NAMES:
         return getColumn_names();
 
       default:
         throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
       }
     }
 
     // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
     public boolean isSet(int fieldID) {
       switch (fieldID) {
       case TABLE:
         return isSetTable();
       case KEY:
         return isSetKey();
       case COLUMN_PARENT:
         return isSetColumn_parent();
       case COLUMN_NAMES:
         return isSetColumn_names();
       default:
         throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
       }
     }
 
     @Override
     public boolean equals(Object that) {
       if (that == null)
         return false;
       if (that instanceof get_slice_by_names_args)
         return this.equals((get_slice_by_names_args)that);
       return false;
     }
 
     public boolean equals(get_slice_by_names_args that) {
       if (that == null)
         return false;
 
       boolean this_present_table = true && this.isSetTable();
       boolean that_present_table = true && that.isSetTable();
       if (this_present_table || that_present_table) {
         if (!(this_present_table && that_present_table))
           return false;
         if (!this.table.equals(that.table))
           return false;
       }
 
       boolean this_present_key = true && this.isSetKey();
       boolean that_present_key = true && that.isSetKey();
       if (this_present_key || that_present_key) {
         if (!(this_present_key && that_present_key))
           return false;
         if (!this.key.equals(that.key))
           return false;
       }
 
       boolean this_present_column_parent = true && this.isSetColumn_parent();
       boolean that_present_column_parent = true && that.isSetColumn_parent();
       if (this_present_column_parent || that_present_column_parent) {
         if (!(this_present_column_parent && that_present_column_parent))
           return false;
         if (!this.column_parent.equals(that.column_parent))
           return false;
       }
 
       boolean this_present_column_names = true && this.isSetColumn_names();
       boolean that_present_column_names = true && that.isSetColumn_names();
       if (this_present_column_names || that_present_column_names) {
         if (!(this_present_column_names && that_present_column_names))
           return false;
         if (!this.column_names.equals(that.column_names))
           return false;
       }
 
       return true;
     }
 
     @Override
     public int hashCode() {
       return 0;
     }
 
     public void read(TProtocol iprot) throws TException {
       TField field;
       iprot.readStructBegin();
       while (true)
       {
         field = iprot.readFieldBegin();
         if (field.type == TType.STOP) { 
           break;
         }
         switch (field.id)
         {
           case TABLE:
             if (field.type == TType.STRING) {
               this.table = iprot.readString();
             } else { 
               TProtocolUtil.skip(iprot, field.type);
             }
             break;
           case KEY:
             if (field.type == TType.STRING) {
               this.key = iprot.readString();
             } else { 
               TProtocolUtil.skip(iprot, field.type);
             }
             break;
           case COLUMN_PARENT:
             if (field.type == TType.STRUCT) {
               this.column_parent = new ColumnParent();
               this.column_parent.read(iprot);
             } else { 
               TProtocolUtil.skip(iprot, field.type);
             }
             break;
           case COLUMN_NAMES:
             if (field.type == TType.LIST) {
               {
                 TList _list31 = iprot.readListBegin();
                 this.column_names = new ArrayList<byte[]>(_list31.size);
                 for (int _i32 = 0; _i32 < _list31.size; ++_i32)
                 {
                   byte[] _elem33;
                   _elem33 = iprot.readBinary();
                   this.column_names.add(_elem33);
                 }
                 iprot.readListEnd();
               }
             } else { 
               TProtocolUtil.skip(iprot, field.type);
             }
             break;
           default:
             TProtocolUtil.skip(iprot, field.type);
             break;
         }
         iprot.readFieldEnd();
       }
       iprot.readStructEnd();
 
 
       // check for required fields of primitive type, which can't be checked in the validate method
       validate();
     }
 
     public void write(TProtocol oprot) throws TException {
       validate();
 
       oprot.writeStructBegin(STRUCT_DESC);
       if (this.table != null) {
         oprot.writeFieldBegin(TABLE_FIELD_DESC);
         oprot.writeString(this.table);
         oprot.writeFieldEnd();
       }
       if (this.key != null) {
         oprot.writeFieldBegin(KEY_FIELD_DESC);
         oprot.writeString(this.key);
         oprot.writeFieldEnd();
       }
       if (this.column_parent != null) {
         oprot.writeFieldBegin(COLUMN_PARENT_FIELD_DESC);
         this.column_parent.write(oprot);
         oprot.writeFieldEnd();
       }
       if (this.column_names != null) {
         oprot.writeFieldBegin(COLUMN_NAMES_FIELD_DESC);
         {
           oprot.writeListBegin(new TList(TType.STRING, this.column_names.size()));
           for (byte[] _iter34 : this.column_names)          {
             oprot.writeBinary(_iter34);
           }
           oprot.writeListEnd();
         }
         oprot.writeFieldEnd();
       }
       oprot.writeFieldStop();
       oprot.writeStructEnd();
     }
 
     @Override
     public String toString() {
       StringBuilder sb = new StringBuilder("get_slice_by_names_args(");
       boolean first = true;
 
       sb.append("table:");
       if (this.table == null) {
         sb.append("null");
       } else {
         sb.append(this.table);
       }
       first = false;
       if (!first) sb.append(", ");
       sb.append("key:");
       if (this.key == null) {
         sb.append("null");
       } else {
         sb.append(this.key);
       }
       first = false;
       if (!first) sb.append(", ");
       sb.append("column_parent:");
       if (this.column_parent == null) {
         sb.append("null");
       } else {
         sb.append(this.column_parent);
       }
       first = false;
       if (!first) sb.append(", ");
       sb.append("column_names:");
       if (this.column_names == null) {
         sb.append("null");
       } else {
         sb.append(this.column_names);
       }
       first = false;
       sb.append(")");
       return sb.toString();
     }
 
     public void validate() throws TException {
       // check for required fields
       // check that fields of type enum have valid values
     }
 
   }
 
   public static class get_slice_by_names_result implements TBase, java.io.Serializable, Cloneable   {
     private static final TStruct STRUCT_DESC = new TStruct("get_slice_by_names_result");
     private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.LIST, (short)0);
     private static final TField IRE_FIELD_DESC = new TField("ire", TType.STRUCT, (short)1);
     private static final TField NFE_FIELD_DESC = new TField("nfe", TType.STRUCT, (short)2);
 
     public List<Column> success;
     public static final int SUCCESS = 0;
     public InvalidRequestException ire;
     public static final int IRE = 1;
     public NotFoundException nfe;
     public static final int NFE = 2;
 
     private final Isset __isset = new Isset();
     private static final class Isset implements java.io.Serializable {
     }
 
     public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
       put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
           new ListMetaData(TType.LIST, 
               new StructMetaData(TType.STRUCT, Column.class))));
       put(IRE, new FieldMetaData("ire", TFieldRequirementType.DEFAULT, 
           new FieldValueMetaData(TType.STRUCT)));
       put(NFE, new FieldMetaData("nfe", TFieldRequirementType.DEFAULT, 
           new FieldValueMetaData(TType.STRUCT)));
     }});
 
     static {
       FieldMetaData.addStructMetaDataMap(get_slice_by_names_result.class, metaDataMap);
     }
 
     public get_slice_by_names_result() {
     }
 
     public get_slice_by_names_result(
       List<Column> success,
       InvalidRequestException ire,
       NotFoundException nfe)
     {
       this();
       this.success = success;
       this.ire = ire;
       this.nfe = nfe;
     }
 
     /**
      * Performs a deep copy on <i>other</i>.
      */
     public get_slice_by_names_result(get_slice_by_names_result other) {
       if (other.isSetSuccess()) {
         List<Column> __this__success = new ArrayList<Column>();
         for (Column other_element : other.success) {
           __this__success.add(new Column(other_element));
         }
         this.success = __this__success;
       }
       if (other.isSetIre()) {
         this.ire = new InvalidRequestException(other.ire);
       }
       if (other.isSetNfe()) {
         this.nfe = new NotFoundException(other.nfe);
       }
     }
 
     @Override
     public get_slice_by_names_result clone() {
       return new get_slice_by_names_result(this);
     }
 
     public int getSuccessSize() {
       return (this.success == null) ? 0 : this.success.size();
     }
 
     public java.util.Iterator<Column> getSuccessIterator() {
       return (this.success == null) ? null : this.success.iterator();
     }
 
     public void addToSuccess(Column elem) {
       if (this.success == null) {
         this.success = new ArrayList<Column>();
       }
       this.success.add(elem);
     }
 
     public List<Column> getSuccess() {
       return this.success;
     }
 
     public void setSuccess(List<Column> success) {
       this.success = success;
     }
 
     public void unsetSuccess() {
       this.success = null;
     }
 
     // Returns true if field success is set (has been asigned a value) and false otherwise
     public boolean isSetSuccess() {
       return this.success != null;
     }
 
     public void setSuccessIsSet(boolean value) {
       if (!value) {
         this.success = null;
       }
     }
 
     public InvalidRequestException getIre() {
       return this.ire;
     }
 
     public void setIre(InvalidRequestException ire) {
       this.ire = ire;
     }
 
     public void unsetIre() {
       this.ire = null;
     }
 
     // Returns true if field ire is set (has been asigned a value) and false otherwise
     public boolean isSetIre() {
       return this.ire != null;
     }
 
     public void setIreIsSet(boolean value) {
       if (!value) {
         this.ire = null;
       }
     }
 
     public NotFoundException getNfe() {
       return this.nfe;
     }
 
     public void setNfe(NotFoundException nfe) {
       this.nfe = nfe;
     }
 
     public void unsetNfe() {
       this.nfe = null;
     }
 
     // Returns true if field nfe is set (has been asigned a value) and false otherwise
     public boolean isSetNfe() {
       return this.nfe != null;
     }
 
     public void setNfeIsSet(boolean value) {
       if (!value) {
         this.nfe = null;
       }
     }
 
     public void setFieldValue(int fieldID, Object value) {
       switch (fieldID) {
       case SUCCESS:
         if (value == null) {
           unsetSuccess();
         } else {
           setSuccess((List<Column>)value);
         }
         break;
 
       case IRE:
         if (value == null) {
           unsetIre();
         } else {
           setIre((InvalidRequestException)value);
         }
         break;
 
       case NFE:
         if (value == null) {
           unsetNfe();
         } else {
           setNfe((NotFoundException)value);
         }
         break;
 
       default:
         throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
       }
     }
 
     public Object getFieldValue(int fieldID) {
       switch (fieldID) {
       case SUCCESS:
         return getSuccess();
 
       case IRE:
         return getIre();
 
       case NFE:
         return getNfe();
 
       default:
         throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
       }
     }
 
     // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
     public boolean isSet(int fieldID) {
       switch (fieldID) {
       case SUCCESS:
         return isSetSuccess();
       case IRE:
         return isSetIre();
       case NFE:
         return isSetNfe();
       default:
         throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
       }
     }
 
     @Override
     public boolean equals(Object that) {
       if (that == null)
         return false;
       if (that instanceof get_slice_by_names_result)
         return this.equals((get_slice_by_names_result)that);
       return false;
     }
 
     public boolean equals(get_slice_by_names_result that) {
       if (that == null)
         return false;
 
       boolean this_present_success = true && this.isSetSuccess();
       boolean that_present_success = true && that.isSetSuccess();
       if (this_present_success || that_present_success) {
         if (!(this_present_success && that_present_success))
           return false;
         if (!this.success.equals(that.success))
           return false;
       }
 
       boolean this_present_ire = true && this.isSetIre();
       boolean that_present_ire = true && that.isSetIre();
       if (this_present_ire || that_present_ire) {
         if (!(this_present_ire && that_present_ire))
           return false;
         if (!this.ire.equals(that.ire))
           return false;
       }
 
       boolean this_present_nfe = true && this.isSetNfe();
       boolean that_present_nfe = true && that.isSetNfe();
       if (this_present_nfe || that_present_nfe) {
         if (!(this_present_nfe && that_present_nfe))
           return false;
         if (!this.nfe.equals(that.nfe))
           return false;
       }
 
       return true;
     }
 
     @Override
     public int hashCode() {
       return 0;
     }
 
     public void read(TProtocol iprot) throws TException {
       TField field;
       iprot.readStructBegin();
       while (true)
       {
         field = iprot.readFieldBegin();
         if (field.type == TType.STOP) { 
           break;
         }
         switch (field.id)
         {
           case SUCCESS:
             if (field.type == TType.LIST) {
               {
                 TList _list35 = iprot.readListBegin();
                 this.success = new ArrayList<Column>(_list35.size);
                 for (int _i36 = 0; _i36 < _list35.size; ++_i36)
                 {
                   Column _elem37;
                   _elem37 = new Column();
                   _elem37.read(iprot);
                   this.success.add(_elem37);
                 }
                 iprot.readListEnd();
               }
             } else { 
               TProtocolUtil.skip(iprot, field.type);
             }
             break;
           case IRE:
             if (field.type == TType.STRUCT) {
               this.ire = new InvalidRequestException();
               this.ire.read(iprot);
             } else { 
               TProtocolUtil.skip(iprot, field.type);
             }
             break;
           case NFE:
             if (field.type == TType.STRUCT) {
               this.nfe = new NotFoundException();
               this.nfe.read(iprot);
             } else { 
               TProtocolUtil.skip(iprot, field.type);
             }
             break;
           default:
             TProtocolUtil.skip(iprot, field.type);
             break;
         }
         iprot.readFieldEnd();
       }
       iprot.readStructEnd();
 
 
       // check for required fields of primitive type, which can't be checked in the validate method
       validate();
     }
 
     public void write(TProtocol oprot) throws TException {
       oprot.writeStructBegin(STRUCT_DESC);
 
       if (this.isSetSuccess()) {
         oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
         {
           oprot.writeListBegin(new TList(TType.STRUCT, this.success.size()));
           for (Column _iter38 : this.success)          {
             _iter38.write(oprot);
           }
           oprot.writeListEnd();
         }
         oprot.writeFieldEnd();
       } else if (this.isSetIre()) {
         oprot.writeFieldBegin(IRE_FIELD_DESC);
         this.ire.write(oprot);
         oprot.writeFieldEnd();
       } else if (this.isSetNfe()) {
         oprot.writeFieldBegin(NFE_FIELD_DESC);
         this.nfe.write(oprot);
         oprot.writeFieldEnd();
       }
       oprot.writeFieldStop();
       oprot.writeStructEnd();
     }
 
     @Override
     public String toString() {
       StringBuilder sb = new StringBuilder("get_slice_by_names_result(");
       boolean first = true;
 
       sb.append("success:");
       if (this.success == null) {
         sb.append("null");
       } else {
         sb.append(this.success);
       }
       first = false;
       if (!first) sb.append(", ");
       sb.append("ire:");
       if (this.ire == null) {
         sb.append("null");
       } else {
         sb.append(this.ire);
       }
       first = false;
       if (!first) sb.append(", ");
       sb.append("nfe:");
       if (this.nfe == null) {
         sb.append("null");
       } else {
         sb.append(this.nfe);
       }
       first = false;
       sb.append(")");
       return sb.toString();
     }
 
     public void validate() throws TException {
       // check for required fields
       // check that fields of type enum have valid values
     }
 
   }
 
   public static class get_slice_args implements TBase, java.io.Serializable, Cloneable   {
     private static final TStruct STRUCT_DESC = new TStruct("get_slice_args");
     private static final TField TABLE_FIELD_DESC = new TField("table", TType.STRING, (short)1);
     private static final TField KEY_FIELD_DESC = new TField("key", TType.STRING, (short)2);
     private static final TField COLUMN_PARENT_FIELD_DESC = new TField("column_parent", TType.STRUCT, (short)3);
     private static final TField START_FIELD_DESC = new TField("start", TType.STRING, (short)4);
     private static final TField FINISH_FIELD_DESC = new TField("finish", TType.STRING, (short)5);
     private static final TField IS_ASCENDING_FIELD_DESC = new TField("is_ascending", TType.BOOL, (short)6);
     private static final TField COUNT_FIELD_DESC = new TField("count", TType.I32, (short)7);
 
     public String table;
     public static final int TABLE = 1;
     public String key;
     public static final int KEY = 2;
     public ColumnParent column_parent;
     public static final int COLUMN_PARENT = 3;
     public byte[] start;
     public static final int START = 4;
     public byte[] finish;
     public static final int FINISH = 5;
     public boolean is_ascending;
     public static final int IS_ASCENDING = 6;
     public int count;
     public static final int COUNT = 7;
 
     private final Isset __isset = new Isset();
     private static final class Isset implements java.io.Serializable {
       public boolean is_ascending = false;
       public boolean count = false;
     }
 
     public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
       put(TABLE, new FieldMetaData("table", TFieldRequirementType.DEFAULT, 
           new FieldValueMetaData(TType.STRING)));
       put(KEY, new FieldMetaData("key", TFieldRequirementType.DEFAULT, 
           new FieldValueMetaData(TType.STRING)));
       put(COLUMN_PARENT, new FieldMetaData("column_parent", TFieldRequirementType.DEFAULT, 
           new StructMetaData(TType.STRUCT, ColumnParent.class)));
       put(START, new FieldMetaData("start", TFieldRequirementType.DEFAULT, 
           new FieldValueMetaData(TType.STRING)));
       put(FINISH, new FieldMetaData("finish", TFieldRequirementType.DEFAULT, 
           new FieldValueMetaData(TType.STRING)));
       put(IS_ASCENDING, new FieldMetaData("is_ascending", TFieldRequirementType.DEFAULT, 
           new FieldValueMetaData(TType.BOOL)));
       put(COUNT, new FieldMetaData("count", TFieldRequirementType.DEFAULT, 
           new FieldValueMetaData(TType.I32)));
     }});
 
     static {
       FieldMetaData.addStructMetaDataMap(get_slice_args.class, metaDataMap);
     }
 
     public get_slice_args() {
       this.count = 100;
 
     }
 
     public get_slice_args(
       String table,
       String key,
       ColumnParent column_parent,
       byte[] start,
       byte[] finish,
       boolean is_ascending,
       int count)
     {
       this();
       this.table = table;
       this.key = key;
       this.column_parent = column_parent;
       this.start = start;
       this.finish = finish;
       this.is_ascending = is_ascending;
       this.__isset.is_ascending = true;
       this.count = count;
       this.__isset.count = true;
     }
 
     /**
      * Performs a deep copy on <i>other</i>.
      */
     public get_slice_args(get_slice_args other) {
       if (other.isSetTable()) {
         this.table = other.table;
       }
       if (other.isSetKey()) {
         this.key = other.key;
       }
       if (other.isSetColumn_parent()) {
         this.column_parent = new ColumnParent(other.column_parent);
       }
       if (other.isSetStart()) {
         this.start = new byte[other.start.length];
         System.arraycopy(other.start, 0, start, 0, other.start.length);
       }
       if (other.isSetFinish()) {
         this.finish = new byte[other.finish.length];
         System.arraycopy(other.finish, 0, finish, 0, other.finish.length);
       }
       __isset.is_ascending = other.__isset.is_ascending;
       this.is_ascending = other.is_ascending;
       __isset.count = other.__isset.count;
       this.count = other.count;
     }
 
     @Override
     public get_slice_args clone() {
       return new get_slice_args(this);
     }
 
     public String getTable() {
       return this.table;
     }
 
     public void setTable(String table) {
       this.table = table;
     }
 
     public void unsetTable() {
       this.table = null;
     }
 
     // Returns true if field table is set (has been asigned a value) and false otherwise
     public boolean isSetTable() {
       return this.table != null;
     }
 
     public void setTableIsSet(boolean value) {
       if (!value) {
         this.table = null;
       }
     }
 
     public String getKey() {
       return this.key;
     }
 
     public void setKey(String key) {
       this.key = key;
     }
 
     public void unsetKey() {
       this.key = null;
     }
 
     // Returns true if field key is set (has been asigned a value) and false otherwise
     public boolean isSetKey() {
       return this.key != null;
     }
 
     public void setKeyIsSet(boolean value) {
       if (!value) {
         this.key = null;
       }
     }
 
     public ColumnParent getColumn_parent() {
       return this.column_parent;
     }
 
     public void setColumn_parent(ColumnParent column_parent) {
       this.column_parent = column_parent;
     }
 
     public void unsetColumn_parent() {
       this.column_parent = null;
     }
 
     // Returns true if field column_parent is set (has been asigned a value) and false otherwise
     public boolean isSetColumn_parent() {
       return this.column_parent != null;
     }
 
     public void setColumn_parentIsSet(boolean value) {
       if (!value) {
         this.column_parent = null;
       }
     }
 
     public byte[] getStart() {
       return this.start;
     }
 
     public void setStart(byte[] start) {
       this.start = start;
     }
 
     public void unsetStart() {
       this.start = null;
     }
 
     // Returns true if field start is set (has been asigned a value) and false otherwise
     public boolean isSetStart() {
       return this.start != null;
     }
 
     public void setStartIsSet(boolean value) {
       if (!value) {
         this.start = null;
       }
     }
 
     public byte[] getFinish() {
       return this.finish;
     }
 
     public void setFinish(byte[] finish) {
       this.finish = finish;
     }
 
     public void unsetFinish() {
       this.finish = null;
     }
 
     // Returns true if field finish is set (has been asigned a value) and false otherwise
     public boolean isSetFinish() {
       return this.finish != null;
     }
 
     public void setFinishIsSet(boolean value) {
       if (!value) {
         this.finish = null;
       }
     }
 
     public boolean isIs_ascending() {
       return this.is_ascending;
     }
 
     public void setIs_ascending(boolean is_ascending) {
       this.is_ascending = is_ascending;
       this.__isset.is_ascending = true;
     }
 
     public void unsetIs_ascending() {
       this.__isset.is_ascending = false;
     }
 
     // Returns true if field is_ascending is set (has been asigned a value) and false otherwise
     public boolean isSetIs_ascending() {
       return this.__isset.is_ascending;
     }
 
     public void setIs_ascendingIsSet(boolean value) {
       this.__isset.is_ascending = value;
     }
 
     public int getCount() {
       return this.count;
     }
 
     public void setCount(int count) {
       this.count = count;
       this.__isset.count = true;
     }
 
     public void unsetCount() {
       this.__isset.count = false;
     }
 
     // Returns true if field count is set (has been asigned a value) and false otherwise
     public boolean isSetCount() {
       return this.__isset.count;
     }
 
     public void setCountIsSet(boolean value) {
       this.__isset.count = value;
     }
 
     public void setFieldValue(int fieldID, Object value) {
       switch (fieldID) {
       case TABLE:
         if (value == null) {
           unsetTable();
         } else {
           setTable((String)value);
         }
         break;
 
       case KEY:
         if (value == null) {
           unsetKey();
         } else {
           setKey((String)value);
         }
         break;
 
       case COLUMN_PARENT:
         if (value == null) {
           unsetColumn_parent();
         } else {
           setColumn_parent((ColumnParent)value);
         }
         break;
 
       case START:
         if (value == null) {
           unsetStart();
         } else {
           setStart((byte[])value);
         }
         break;
 
       case FINISH:
         if (value == null) {
           unsetFinish();
         } else {
           setFinish((byte[])value);
         }
         break;
 
       case IS_ASCENDING:
         if (value == null) {
           unsetIs_ascending();
         } else {
           setIs_ascending((Boolean)value);
         }
         break;
 
       case COUNT:
         if (value == null) {
           unsetCount();
         } else {
           setCount((Integer)value);
         }
         break;
 
       default:
         throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
       }
     }
 
     public Object getFieldValue(int fieldID) {
       switch (fieldID) {
       case TABLE:
         return getTable();
 
       case KEY:
         return getKey();
 
       case COLUMN_PARENT:
         return getColumn_parent();
 
       case START:
         return getStart();
 
       case FINISH:
         return getFinish();
 
       case IS_ASCENDING:
         return new Boolean(isIs_ascending());
 
       case COUNT:
         return new Integer(getCount());
 
       default:
         throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
       }
     }
 
     // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
     public boolean isSet(int fieldID) {
       switch (fieldID) {
       case TABLE:
         return isSetTable();
       case KEY:
         return isSetKey();
       case COLUMN_PARENT:
         return isSetColumn_parent();
       case START:
         return isSetStart();
       case FINISH:
         return isSetFinish();
       case IS_ASCENDING:
         return isSetIs_ascending();
       case COUNT:
         return isSetCount();
       default:
         throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
       }
     }
 
     @Override
     public boolean equals(Object that) {
       if (that == null)
         return false;
       if (that instanceof get_slice_args)
         return this.equals((get_slice_args)that);
       return false;
     }
 
     public boolean equals(get_slice_args that) {
       if (that == null)
         return false;
 
       boolean this_present_table = true && this.isSetTable();
       boolean that_present_table = true && that.isSetTable();
       if (this_present_table || that_present_table) {
         if (!(this_present_table && that_present_table))
           return false;
         if (!this.table.equals(that.table))
           return false;
       }
 
       boolean this_present_key = true && this.isSetKey();
       boolean that_present_key = true && that.isSetKey();
       if (this_present_key || that_present_key) {
         if (!(this_present_key && that_present_key))
           return false;
         if (!this.key.equals(that.key))
           return false;
       }
 
       boolean this_present_column_parent = true && this.isSetColumn_parent();
       boolean that_present_column_parent = true && that.isSetColumn_parent();
       if (this_present_column_parent || that_present_column_parent) {
         if (!(this_present_column_parent && that_present_column_parent))
           return false;
         if (!this.column_parent.equals(that.column_parent))
           return false;
       }
 
       boolean this_present_start = true && this.isSetStart();
       boolean that_present_start = true && that.isSetStart();
       if (this_present_start || that_present_start) {
         if (!(this_present_start && that_present_start))
           return false;
         if (!java.util.Arrays.equals(this.start, that.start))
           return false;
       }
 
       boolean this_present_finish = true && this.isSetFinish();
       boolean that_present_finish = true && that.isSetFinish();
       if (this_present_finish || that_present_finish) {
         if (!(this_present_finish && that_present_finish))
           return false;
         if (!java.util.Arrays.equals(this.finish, that.finish))
           return false;
       }
 
       boolean this_present_is_ascending = true;
       boolean that_present_is_ascending = true;
       if (this_present_is_ascending || that_present_is_ascending) {
         if (!(this_present_is_ascending && that_present_is_ascending))
           return false;
         if (this.is_ascending != that.is_ascending)
           return false;
       }
 
       boolean this_present_count = true;
       boolean that_present_count = true;
       if (this_present_count || that_present_count) {
         if (!(this_present_count && that_present_count))
           return false;
         if (this.count != that.count)
           return false;
       }
 
       return true;
     }
 
     @Override
     public int hashCode() {
       return 0;
     }
 
     public void read(TProtocol iprot) throws TException {
       TField field;
       iprot.readStructBegin();
       while (true)
       {
         field = iprot.readFieldBegin();
         if (field.type == TType.STOP) { 
           break;
         }
         switch (field.id)
         {
           case TABLE:
             if (field.type == TType.STRING) {
               this.table = iprot.readString();
             } else { 
               TProtocolUtil.skip(iprot, field.type);
             }
             break;
           case KEY:
             if (field.type == TType.STRING) {
               this.key = iprot.readString();
             } else { 
               TProtocolUtil.skip(iprot, field.type);
             }
             break;
           case COLUMN_PARENT:
             if (field.type == TType.STRUCT) {
               this.column_parent = new ColumnParent();
               this.column_parent.read(iprot);
             } else { 
               TProtocolUtil.skip(iprot, field.type);
             }
             break;
           case START:
             if (field.type == TType.STRING) {
               this.start = iprot.readBinary();
             } else { 
               TProtocolUtil.skip(iprot, field.type);
             }
             break;
           case FINISH:
             if (field.type == TType.STRING) {
               this.finish = iprot.readBinary();
             } else { 
               TProtocolUtil.skip(iprot, field.type);
             }
             break;
           case IS_ASCENDING:
             if (field.type == TType.BOOL) {
               this.is_ascending = iprot.readBool();
               this.__isset.is_ascending = true;
             } else { 
               TProtocolUtil.skip(iprot, field.type);
             }
             break;
           case COUNT:
             if (field.type == TType.I32) {
               this.count = iprot.readI32();
               this.__isset.count = true;
             } else { 
               TProtocolUtil.skip(iprot, field.type);
             }
             break;
           default:
             TProtocolUtil.skip(iprot, field.type);
             break;
         }
         iprot.readFieldEnd();
       }
       iprot.readStructEnd();
 
 
       // check for required fields of primitive type, which can't be checked in the validate method
       validate();
     }
 
     public void write(TProtocol oprot) throws TException {
       validate();
 
       oprot.writeStructBegin(STRUCT_DESC);
       if (this.table != null) {
         oprot.writeFieldBegin(TABLE_FIELD_DESC);
         oprot.writeString(this.table);
         oprot.writeFieldEnd();
       }
       if (this.key != null) {
         oprot.writeFieldBegin(KEY_FIELD_DESC);
         oprot.writeString(this.key);
         oprot.writeFieldEnd();
       }
       if (this.column_parent != null) {
         oprot.writeFieldBegin(COLUMN_PARENT_FIELD_DESC);
         this.column_parent.write(oprot);
         oprot.writeFieldEnd();
       }
       if (this.start != null) {
         oprot.writeFieldBegin(START_FIELD_DESC);
         oprot.writeBinary(this.start);
         oprot.writeFieldEnd();
       }
       if (this.finish != null) {
         oprot.writeFieldBegin(FINISH_FIELD_DESC);
         oprot.writeBinary(this.finish);
         oprot.writeFieldEnd();
       }
       oprot.writeFieldBegin(IS_ASCENDING_FIELD_DESC);
       oprot.writeBool(this.is_ascending);
       oprot.writeFieldEnd();
       oprot.writeFieldBegin(COUNT_FIELD_DESC);
       oprot.writeI32(this.count);
       oprot.writeFieldEnd();
       oprot.writeFieldStop();
       oprot.writeStructEnd();
     }
 
     @Override
     public String toString() {
       StringBuilder sb = new StringBuilder("get_slice_args(");
       boolean first = true;
 
       sb.append("table:");
       if (this.table == null) {
         sb.append("null");
       } else {
         sb.append(this.table);
       }
       first = false;
       if (!first) sb.append(", ");
       sb.append("key:");
       if (this.key == null) {
         sb.append("null");
       } else {
         sb.append(this.key);
       }
       first = false;
       if (!first) sb.append(", ");
       sb.append("column_parent:");
       if (this.column_parent == null) {
         sb.append("null");
       } else {
         sb.append(this.column_parent);
       }
       first = false;
       if (!first) sb.append(", ");
       sb.append("start:");
       if (this.start == null) {
         sb.append("null");
       } else {
           int __start_size = Math.min(this.start.length, 128);
           for (int i = 0; i < __start_size; i++) {
             if (i != 0) sb.append(" ");
             sb.append(Integer.toHexString(this.start[i]).length() > 1 ? Integer.toHexString(this.start[i]).substring(Integer.toHexString(this.start[i]).length() - 2).toUpperCase() : "0" + Integer.toHexString(this.start[i]).toUpperCase());
           }
           if (this.start.length > 128) sb.append(" ...");
       }
       first = false;
       if (!first) sb.append(", ");
       sb.append("finish:");
       if (this.finish == null) {
         sb.append("null");
       } else {
           int __finish_size = Math.min(this.finish.length, 128);
           for (int i = 0; i < __finish_size; i++) {
             if (i != 0) sb.append(" ");
             sb.append(Integer.toHexString(this.finish[i]).length() > 1 ? Integer.toHexString(this.finish[i]).substring(Integer.toHexString(this.finish[i]).length() - 2).toUpperCase() : "0" + Integer.toHexString(this.finish[i]).toUpperCase());
           }
           if (this.finish.length > 128) sb.append(" ...");
       }
       first = false;
       if (!first) sb.append(", ");
       sb.append("is_ascending:");
       sb.append(this.is_ascending);
       first = false;
       if (!first) sb.append(", ");
       sb.append("count:");
       sb.append(this.count);
       first = false;
       sb.append(")");
       return sb.toString();
     }
 
     public void validate() throws TException {
       // check for required fields
       // check that fields of type enum have valid values
     }
 
   }
 
   public static class get_slice_result implements TBase, java.io.Serializable, Cloneable   {
     private static final TStruct STRUCT_DESC = new TStruct("get_slice_result");
     private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.LIST, (short)0);
     private static final TField IRE_FIELD_DESC = new TField("ire", TType.STRUCT, (short)1);
     private static final TField NFE_FIELD_DESC = new TField("nfe", TType.STRUCT, (short)2);
 
     public List<Column> success;
     public static final int SUCCESS = 0;
     public InvalidRequestException ire;
     public static final int IRE = 1;
     public NotFoundException nfe;
     public static final int NFE = 2;
 
     private final Isset __isset = new Isset();
     private static final class Isset implements java.io.Serializable {
     }
 
     public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
       put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
           new ListMetaData(TType.LIST, 
               new StructMetaData(TType.STRUCT, Column.class))));
       put(IRE, new FieldMetaData("ire", TFieldRequirementType.DEFAULT, 
           new FieldValueMetaData(TType.STRUCT)));
       put(NFE, new FieldMetaData("nfe", TFieldRequirementType.DEFAULT, 
           new FieldValueMetaData(TType.STRUCT)));
     }});
 
     static {
       FieldMetaData.addStructMetaDataMap(get_slice_result.class, metaDataMap);
     }
 
     public get_slice_result() {
     }
 
     public get_slice_result(
       List<Column> success,
       InvalidRequestException ire,
       NotFoundException nfe)
     {
       this();
       this.success = success;
       this.ire = ire;
       this.nfe = nfe;
     }
 
     /**
      * Performs a deep copy on <i>other</i>.
      */
     public get_slice_result(get_slice_result other) {
       if (other.isSetSuccess()) {
         List<Column> __this__success = new ArrayList<Column>();
         for (Column other_element : other.success) {
           __this__success.add(new Column(other_element));
         }
         this.success = __this__success;
       }
       if (other.isSetIre()) {
         this.ire = new InvalidRequestException(other.ire);
       }
       if (other.isSetNfe()) {
         this.nfe = new NotFoundException(other.nfe);
       }
     }
 
     @Override
     public get_slice_result clone() {
       return new get_slice_result(this);
     }
 
     public int getSuccessSize() {
       return (this.success == null) ? 0 : this.success.size();
     }
 
     public java.util.Iterator<Column> getSuccessIterator() {
       return (this.success == null) ? null : this.success.iterator();
     }
 
     public void addToSuccess(Column elem) {
       if (this.success == null) {
         this.success = new ArrayList<Column>();
       }
       this.success.add(elem);
     }
 
     public List<Column> getSuccess() {
       return this.success;
     }
 
     public void setSuccess(List<Column> success) {
       this.success = success;
     }
 
     public void unsetSuccess() {
       this.success = null;
     }
 
     // Returns true if field success is set (has been asigned a value) and false otherwise
     public boolean isSetSuccess() {
       return this.success != null;
     }
 
     public void setSuccessIsSet(boolean value) {
       if (!value) {
         this.success = null;
       }
     }
 
     public InvalidRequestException getIre() {
       return this.ire;
     }
 
     public void setIre(InvalidRequestException ire) {
       this.ire = ire;
     }
 
     public void unsetIre() {
       this.ire = null;
     }
 
     // Returns true if field ire is set (has been asigned a value) and false otherwise
     public boolean isSetIre() {
       return this.ire != null;
     }
 
     public void setIreIsSet(boolean value) {
       if (!value) {
         this.ire = null;
       }
     }
 
     public NotFoundException getNfe() {
       return this.nfe;
     }
 
     public void setNfe(NotFoundException nfe) {
       this.nfe = nfe;
     }
 
     public void unsetNfe() {
       this.nfe = null;
     }
 
     // Returns true if field nfe is set (has been asigned a value) and false otherwise
     public boolean isSetNfe() {
       return this.nfe != null;
     }
 
     public void setNfeIsSet(boolean value) {
       if (!value) {
         this.nfe = null;
       }
     }
 
     public void setFieldValue(int fieldID, Object value) {
       switch (fieldID) {
       case SUCCESS:
         if (value == null) {
           unsetSuccess();
         } else {
           setSuccess((List<Column>)value);
         }
         break;
 
       case IRE:
         if (value == null) {
           unsetIre();
         } else {
           setIre((InvalidRequestException)value);
         }
         break;
 
       case NFE:
         if (value == null) {
           unsetNfe();
         } else {
           setNfe((NotFoundException)value);
         }
         break;
 
       default:
         throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
       }
     }
 
     public Object getFieldValue(int fieldID) {
       switch (fieldID) {
       case SUCCESS:
         return getSuccess();
 
       case IRE:
         return getIre();
 
       case NFE:
         return getNfe();
 
       default:
         throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
       }
     }
 
     // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
     public boolean isSet(int fieldID) {
       switch (fieldID) {
       case SUCCESS:
         return isSetSuccess();
       case IRE:
         return isSetIre();
       case NFE:
         return isSetNfe();
       default:
         throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
       }
     }
 
     @Override
     public boolean equals(Object that) {
       if (that == null)
         return false;
       if (that instanceof get_slice_result)
         return this.equals((get_slice_result)that);
       return false;
     }
 
     public boolean equals(get_slice_result that) {
       if (that == null)
         return false;
 
       boolean this_present_success = true && this.isSetSuccess();
       boolean that_present_success = true && that.isSetSuccess();
       if (this_present_success || that_present_success) {
         if (!(this_present_success && that_present_success))
           return false;
         if (!this.success.equals(that.success))
           return false;
       }
 
       boolean this_present_ire = true && this.isSetIre();
       boolean that_present_ire = true && that.isSetIre();
       if (this_present_ire || that_present_ire) {
         if (!(this_present_ire && that_present_ire))
           return false;
         if (!this.ire.equals(that.ire))
           return false;
       }
 
       boolean this_present_nfe = true && this.isSetNfe();
       boolean that_present_nfe = true && that.isSetNfe();
       if (this_present_nfe || that_present_nfe) {
         if (!(this_present_nfe && that_present_nfe))
           return false;
         if (!this.nfe.equals(that.nfe))
           return false;
       }
 
       return true;
     }
 
     @Override
     public int hashCode() {
       return 0;
     }
 
     public void read(TProtocol iprot) throws TException {
       TField field;
       iprot.readStructBegin();
       while (true)
       {
         field = iprot.readFieldBegin();
         if (field.type == TType.STOP) { 
           break;
         }
         switch (field.id)
         {
           case SUCCESS:
             if (field.type == TType.LIST) {
               {
                 TList _list39 = iprot.readListBegin();
                 this.success = new ArrayList<Column>(_list39.size);
                 for (int _i40 = 0; _i40 < _list39.size; ++_i40)
                 {
                   Column _elem41;
                   _elem41 = new Column();
                   _elem41.read(iprot);
                   this.success.add(_elem41);
                 }
                 iprot.readListEnd();
               }
             } else { 
               TProtocolUtil.skip(iprot, field.type);
             }
             break;
           case IRE:
             if (field.type == TType.STRUCT) {
               this.ire = new InvalidRequestException();
               this.ire.read(iprot);
             } else { 
               TProtocolUtil.skip(iprot, field.type);
             }
             break;
           case NFE:
             if (field.type == TType.STRUCT) {
               this.nfe = new NotFoundException();
               this.nfe.read(iprot);
             } else { 
               TProtocolUtil.skip(iprot, field.type);
             }
             break;
           default:
             TProtocolUtil.skip(iprot, field.type);
             break;
         }
         iprot.readFieldEnd();
       }
       iprot.readStructEnd();
 
 
       // check for required fields of primitive type, which can't be checked in the validate method
       validate();
     }
 
     public void write(TProtocol oprot) throws TException {
       oprot.writeStructBegin(STRUCT_DESC);
 
       if (this.isSetSuccess()) {
         oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
         {
           oprot.writeListBegin(new TList(TType.STRUCT, this.success.size()));
           for (Column _iter42 : this.success)          {
             _iter42.write(oprot);
           }
           oprot.writeListEnd();
         }
         oprot.writeFieldEnd();
       } else if (this.isSetIre()) {
         oprot.writeFieldBegin(IRE_FIELD_DESC);
         this.ire.write(oprot);
         oprot.writeFieldEnd();
       } else if (this.isSetNfe()) {
         oprot.writeFieldBegin(NFE_FIELD_DESC);
         this.nfe.write(oprot);
         oprot.writeFieldEnd();
       }
       oprot.writeFieldStop();
       oprot.writeStructEnd();
     }
 
     @Override
     public String toString() {
       StringBuilder sb = new StringBuilder("get_slice_result(");
       boolean first = true;
 
       sb.append("success:");
       if (this.success == null) {
         sb.append("null");
       } else {
         sb.append(this.success);
       }
       first = false;
       if (!first) sb.append(", ");
       sb.append("ire:");
       if (this.ire == null) {
         sb.append("null");
       } else {
         sb.append(this.ire);
       }
       first = false;
       if (!first) sb.append(", ");
       sb.append("nfe:");
       if (this.nfe == null) {
         sb.append("null");
       } else {
         sb.append(this.nfe);
       }
       first = false;
       sb.append(")");
       return sb.toString();
     }
 
     public void validate() throws TException {
       // check for required fields
       // check that fields of type enum have valid values
     }
 
   }
 
   public static class get_column_args implements TBase, java.io.Serializable, Cloneable   {
     private static final TStruct STRUCT_DESC = new TStruct("get_column_args");
     private static final TField TABLE_FIELD_DESC = new TField("table", TType.STRING, (short)1);
     private static final TField KEY_FIELD_DESC = new TField("key", TType.STRING, (short)2);
     private static final TField COLUMN_PATH_FIELD_DESC = new TField("column_path", TType.STRUCT, (short)3);
 
     public String table;
     public static final int TABLE = 1;
     public String key;
     public static final int KEY = 2;
     public ColumnPath column_path;
     public static final int COLUMN_PATH = 3;
 
     private final Isset __isset = new Isset();
     private static final class Isset implements java.io.Serializable {
     }
 
     public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
       put(TABLE, new FieldMetaData("table", TFieldRequirementType.DEFAULT, 
           new FieldValueMetaData(TType.STRING)));
       put(KEY, new FieldMetaData("key", TFieldRequirementType.DEFAULT, 
           new FieldValueMetaData(TType.STRING)));
       put(COLUMN_PATH, new FieldMetaData("column_path", TFieldRequirementType.DEFAULT, 
           new StructMetaData(TType.STRUCT, ColumnPath.class)));
     }});
 
     static {
       FieldMetaData.addStructMetaDataMap(get_column_args.class, metaDataMap);
     }
 
     public get_column_args() {
     }
 
     public get_column_args(
       String table,
       String key,
       ColumnPath column_path)
     {
       this();
       this.table = table;
       this.key = key;
       this.column_path = column_path;
     }
 
     /**
      * Performs a deep copy on <i>other</i>.
      */
     public get_column_args(get_column_args other) {
       if (other.isSetTable()) {
         this.table = other.table;
       }
       if (other.isSetKey()) {
         this.key = other.key;
       }
       if (other.isSetColumn_path()) {
         this.column_path = new ColumnPath(other.column_path);
       }
     }
 
     @Override
     public get_column_args clone() {
       return new get_column_args(this);
     }
 
     public String getTable() {
       return this.table;
     }
 
     public void setTable(String table) {
       this.table = table;
     }
 
     public void unsetTable() {
       this.table = null;
     }
 
     // Returns true if field table is set (has been asigned a value) and false otherwise
     public boolean isSetTable() {
       return this.table != null;
     }
 
     public void setTableIsSet(boolean value) {
       if (!value) {
         this.table = null;
       }
     }
 
     public String getKey() {
       return this.key;
     }
 
     public void setKey(String key) {
       this.key = key;
     }
 
     public void unsetKey() {
       this.key = null;
     }
 
     // Returns true if field key is set (has been asigned a value) and false otherwise
     public boolean isSetKey() {
       return this.key != null;
     }
 
     public void setKeyIsSet(boolean value) {
       if (!value) {
         this.key = null;
       }
     }
 
     public ColumnPath getColumn_path() {
       return this.column_path;
     }
 
     public void setColumn_path(ColumnPath column_path) {
       this.column_path = column_path;
     }
 
     public void unsetColumn_path() {
       this.column_path = null;
     }
 
     // Returns true if field column_path is set (has been asigned a value) and false otherwise
     public boolean isSetColumn_path() {
       return this.column_path != null;
     }
 
     public void setColumn_pathIsSet(boolean value) {
       if (!value) {
         this.column_path = null;
       }
     }
 
     public void setFieldValue(int fieldID, Object value) {
       switch (fieldID) {
       case TABLE:
         if (value == null) {
           unsetTable();
         } else {
           setTable((String)value);
         }
         break;
 
       case KEY:
         if (value == null) {
           unsetKey();
         } else {
           setKey((String)value);
         }
         break;
 
       case COLUMN_PATH:
         if (value == null) {
           unsetColumn_path();
         } else {
           setColumn_path((ColumnPath)value);
         }
         break;
 
       default:
         throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
       }
     }
 
     public Object getFieldValue(int fieldID) {
       switch (fieldID) {
       case TABLE:
         return getTable();
 
       case KEY:
         return getKey();
 
       case COLUMN_PATH:
         return getColumn_path();
 
       default:
         throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
       }
     }
 
     // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
     public boolean isSet(int fieldID) {
       switch (fieldID) {
       case TABLE:
         return isSetTable();
       case KEY:
         return isSetKey();
       case COLUMN_PATH:
         return isSetColumn_path();
       default:
         throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
       }
     }
 
     @Override
     public boolean equals(Object that) {
       if (that == null)
         return false;
       if (that instanceof get_column_args)
         return this.equals((get_column_args)that);
       return false;
     }
 
     public boolean equals(get_column_args that) {
       if (that == null)
         return false;
 
       boolean this_present_table = true && this.isSetTable();
       boolean that_present_table = true && that.isSetTable();
       if (this_present_table || that_present_table) {
         if (!(this_present_table && that_present_table))
           return false;
         if (!this.table.equals(that.table))
           return false;
       }
 
       boolean this_present_key = true && this.isSetKey();
       boolean that_present_key = true && that.isSetKey();
       if (this_present_key || that_present_key) {
         if (!(this_present_key && that_present_key))
           return false;
         if (!this.key.equals(that.key))
           return false;
       }
 
       boolean this_present_column_path = true && this.isSetColumn_path();
       boolean that_present_column_path = true && that.isSetColumn_path();
       if (this_present_column_path || that_present_column_path) {
         if (!(this_present_column_path && that_present_column_path))
           return false;
         if (!this.column_path.equals(that.column_path))
           return false;
       }
 
       return true;
     }
 
     @Override
     public int hashCode() {
       return 0;
     }
 
     public void read(TProtocol iprot) throws TException {
       TField field;
       iprot.readStructBegin();
       while (true)
       {
         field = iprot.readFieldBegin();
         if (field.type == TType.STOP) { 
           break;
         }
         switch (field.id)
         {
           case TABLE:
             if (field.type == TType.STRING) {
               this.table = iprot.readString();
             } else { 
               TProtocolUtil.skip(iprot, field.type);
             }
             break;
           case KEY:
             if (field.type == TType.STRING) {
               this.key = iprot.readString();
             } else { 
               TProtocolUtil.skip(iprot, field.type);
             }
             break;
           case COLUMN_PATH:
             if (field.type == TType.STRUCT) {
               this.column_path = new ColumnPath();
               this.column_path.read(iprot);
             } else { 
               TProtocolUtil.skip(iprot, field.type);
             }
             break;
           default:
             TProtocolUtil.skip(iprot, field.type);
             break;
         }
         iprot.readFieldEnd();
       }
       iprot.readStructEnd();
 
 
       // check for required fields of primitive type, which can't be checked in the validate method
       validate();
     }
 
     public void write(TProtocol oprot) throws TException {
       validate();
 
       oprot.writeStructBegin(STRUCT_DESC);
       if (this.table != null) {
         oprot.writeFieldBegin(TABLE_FIELD_DESC);
         oprot.writeString(this.table);
         oprot.writeFieldEnd();
       }
       if (this.key != null) {
         oprot.writeFieldBegin(KEY_FIELD_DESC);
         oprot.writeString(this.key);
         oprot.writeFieldEnd();
       }
       if (this.column_path != null) {
         oprot.writeFieldBegin(COLUMN_PATH_FIELD_DESC);
         this.column_path.write(oprot);
         oprot.writeFieldEnd();
       }
       oprot.writeFieldStop();
       oprot.writeStructEnd();
     }
 
     @Override
     public String toString() {
       StringBuilder sb = new StringBuilder("get_column_args(");
       boolean first = true;
 
       sb.append("table:");
       if (this.table == null) {
         sb.append("null");
       } else {
         sb.append(this.table);
       }
       first = false;
       if (!first) sb.append(", ");
       sb.append("key:");
       if (this.key == null) {
         sb.append("null");
       } else {
         sb.append(this.key);
       }
       first = false;
       if (!first) sb.append(", ");
       sb.append("column_path:");
       if (this.column_path == null) {
         sb.append("null");
       } else {
         sb.append(this.column_path);
       }
       first = false;
       sb.append(")");
       return sb.toString();
     }
 
     public void validate() throws TException {
       // check for required fields
       // check that fields of type enum have valid values
     }
 
   }
 
   public static class get_column_result implements TBase, java.io.Serializable, Cloneable   {
     private static final TStruct STRUCT_DESC = new TStruct("get_column_result");
     private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);
     private static final TField IRE_FIELD_DESC = new TField("ire", TType.STRUCT, (short)1);
     private static final TField NFE_FIELD_DESC = new TField("nfe", TType.STRUCT, (short)2);
 
     public Column success;
     public static final int SUCCESS = 0;
     public InvalidRequestException ire;
     public static final int IRE = 1;
     public NotFoundException nfe;
     public static final int NFE = 2;
 
     private final Isset __isset = new Isset();
     private static final class Isset implements java.io.Serializable {
     }
 
     public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
       put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
           new StructMetaData(TType.STRUCT, Column.class)));
       put(IRE, new FieldMetaData("ire", TFieldRequirementType.DEFAULT, 
           new FieldValueMetaData(TType.STRUCT)));
       put(NFE, new FieldMetaData("nfe", TFieldRequirementType.DEFAULT, 
           new FieldValueMetaData(TType.STRUCT)));
     }});
 
     static {
       FieldMetaData.addStructMetaDataMap(get_column_result.class, metaDataMap);
     }
 
     public get_column_result() {
     }
 
     public get_column_result(
       Column success,
       InvalidRequestException ire,
       NotFoundException nfe)
     {
       this();
       this.success = success;
       this.ire = ire;
       this.nfe = nfe;
     }
 
     /**
      * Performs a deep copy on <i>other</i>.
      */
     public get_column_result(get_column_result other) {
       if (other.isSetSuccess()) {
         this.success = new Column(other.success);
       }
       if (other.isSetIre()) {
         this.ire = new InvalidRequestException(other.ire);
       }
       if (other.isSetNfe()) {
         this.nfe = new NotFoundException(other.nfe);
       }
     }
 
     @Override
     public get_column_result clone() {
       return new get_column_result(this);
     }
 
     public Column getSuccess() {
       return this.success;
     }
 
     public void setSuccess(Column success) {
       this.success = success;
     }
 
     public void unsetSuccess() {
       this.success = null;
     }
 
     // Returns true if field success is set (has been asigned a value) and false otherwise
     public boolean isSetSuccess() {
       return this.success != null;
     }
 
     public void setSuccessIsSet(boolean value) {
       if (!value) {
         this.success = null;
       }
     }
 
     public InvalidRequestException getIre() {
       return this.ire;
     }
 
     public void setIre(InvalidRequestException ire) {
       this.ire = ire;
     }
 
     public void unsetIre() {
       this.ire = null;
     }
 
     // Returns true if field ire is set (has been asigned a value) and false otherwise
     public boolean isSetIre() {
       return this.ire != null;
     }
 
     public void setIreIsSet(boolean value) {
       if (!value) {
         this.ire = null;
       }
     }
 
     public NotFoundException getNfe() {
       return this.nfe;
     }
 
     public void setNfe(NotFoundException nfe) {
       this.nfe = nfe;
     }
 
     public void unsetNfe() {
       this.nfe = null;
     }
 
     // Returns true if field nfe is set (has been asigned a value) and false otherwise
     public boolean isSetNfe() {
       return this.nfe != null;
     }
 
     public void setNfeIsSet(boolean value) {
       if (!value) {
         this.nfe = null;
       }
     }
 
     public void setFieldValue(int fieldID, Object value) {
       switch (fieldID) {
       case SUCCESS:
         if (value == null) {
           unsetSuccess();
         } else {
           setSuccess((Column)value);
         }
         break;
 
       case IRE:
         if (value == null) {
           unsetIre();
         } else {
           setIre((InvalidRequestException)value);
         }
         break;
 
       case NFE:
         if (value == null) {
           unsetNfe();
         } else {
           setNfe((NotFoundException)value);
         }
         break;
 
       default:
         throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
       }
     }
 
     public Object getFieldValue(int fieldID) {
       switch (fieldID) {
       case SUCCESS:
         return getSuccess();
 
       case IRE:
         return getIre();
 
       case NFE:
         return getNfe();
 
       default:
         throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
       }
     }
 
     // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
     public boolean isSet(int fieldID) {
       switch (fieldID) {
       case SUCCESS:
         return isSetSuccess();
       case IRE:
         return isSetIre();
       case NFE:
         return isSetNfe();
       default:
         throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
       }
     }
 
     @Override
     public boolean equals(Object that) {
       if (that == null)
         return false;
       if (that instanceof get_column_result)
         return this.equals((get_column_result)that);
       return false;
     }
 
     public boolean equals(get_column_result that) {
       if (that == null)
         return false;
 
       boolean this_present_success = true && this.isSetSuccess();
       boolean that_present_success = true && that.isSetSuccess();
       if (this_present_success || that_present_success) {
         if (!(this_present_success && that_present_success))
           return false;
         if (!this.success.equals(that.success))
           return false;
       }
 
       boolean this_present_ire = true && this.isSetIre();
       boolean that_present_ire = true && that.isSetIre();
       if (this_present_ire || that_present_ire) {
         if (!(this_present_ire && that_present_ire))
           return false;
         if (!this.ire.equals(that.ire))
           return false;
       }
 
       boolean this_present_nfe = true && this.isSetNfe();
       boolean that_present_nfe = true && that.isSetNfe();
       if (this_present_nfe || that_present_nfe) {
         if (!(this_present_nfe && that_present_nfe))
           return false;
         if (!this.nfe.equals(that.nfe))
           return false;
       }
 
       return true;
     }
 
     @Override
     public int hashCode() {
       return 0;
     }
 
     public void read(TProtocol iprot) throws TException {
       TField field;
       iprot.readStructBegin();
       while (true)
       {
         field = iprot.readFieldBegin();
         if (field.type == TType.STOP) { 
           break;
         }
         switch (field.id)
         {
           case SUCCESS:
             if (field.type == TType.STRUCT) {
               this.success = new Column();
               this.success.read(iprot);
             } else { 
               TProtocolUtil.skip(iprot, field.type);
             }
             break;
           case IRE:
             if (field.type == TType.STRUCT) {
               this.ire = new InvalidRequestException();
               this.ire.read(iprot);
             } else { 
               TProtocolUtil.skip(iprot, field.type);
             }
             break;
           case NFE:
             if (field.type == TType.STRUCT) {
               this.nfe = new NotFoundException();
               this.nfe.read(iprot);
             } else { 
               TProtocolUtil.skip(iprot, field.type);
             }
             break;
           default:
             TProtocolUtil.skip(iprot, field.type);
             break;
         }
         iprot.readFieldEnd();
       }
       iprot.readStructEnd();
 
 
       // check for required fields of primitive type, which can't be checked in the validate method
       validate();
     }
 
     public void write(TProtocol oprot) throws TException {
       oprot.writeStructBegin(STRUCT_DESC);
 
       if (this.isSetSuccess()) {
         oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
         this.success.write(oprot);
         oprot.writeFieldEnd();
       } else if (this.isSetIre()) {
         oprot.writeFieldBegin(IRE_FIELD_DESC);
         this.ire.write(oprot);
         oprot.writeFieldEnd();
       } else if (this.isSetNfe()) {
         oprot.writeFieldBegin(NFE_FIELD_DESC);
         this.nfe.write(oprot);
         oprot.writeFieldEnd();
       }
       oprot.writeFieldStop();
       oprot.writeStructEnd();
     }
 
     @Override
     public String toString() {
       StringBuilder sb = new StringBuilder("get_column_result(");
       boolean first = true;
 
       sb.append("success:");
       if (this.success == null) {
         sb.append("null");
       } else {
         sb.append(this.success);
       }
       first = false;
       if (!first) sb.append(", ");
       sb.append("ire:");
       if (this.ire == null) {
         sb.append("null");
       } else {
         sb.append(this.ire);
       }
       first = false;
       if (!first) sb.append(", ");
       sb.append("nfe:");
       if (this.nfe == null) {
         sb.append("null");
       } else {
         sb.append(this.nfe);
       }
       first = false;
       sb.append(")");
       return sb.toString();
     }
 
     public void validate() throws TException {
       // check for required fields
       // check that fields of type enum have valid values
     }
 
   }
 
   public static class get_column_count_args implements TBase, java.io.Serializable, Cloneable   {
     private static final TStruct STRUCT_DESC = new TStruct("get_column_count_args");
     private static final TField TABLE_FIELD_DESC = new TField("table", TType.STRING, (short)1);
     private static final TField KEY_FIELD_DESC = new TField("key", TType.STRING, (short)2);
     private static final TField COLUMN_PARENT_FIELD_DESC = new TField("column_parent", TType.STRUCT, (short)3);
 
     public String table;
     public static final int TABLE = 1;
     public String key;
     public static final int KEY = 2;
     public ColumnParent column_parent;
     public static final int COLUMN_PARENT = 3;
 
     private final Isset __isset = new Isset();
     private static final class Isset implements java.io.Serializable {
     }
 
     public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
       put(TABLE, new FieldMetaData("table", TFieldRequirementType.DEFAULT, 
           new FieldValueMetaData(TType.STRING)));
       put(KEY, new FieldMetaData("key", TFieldRequirementType.DEFAULT, 
           new FieldValueMetaData(TType.STRING)));
       put(COLUMN_PARENT, new FieldMetaData("column_parent", TFieldRequirementType.DEFAULT, 
           new StructMetaData(TType.STRUCT, ColumnParent.class)));
     }});
 
     static {
       FieldMetaData.addStructMetaDataMap(get_column_count_args.class, metaDataMap);
     }
 
     public get_column_count_args() {
     }
 
     public get_column_count_args(
       String table,
       String key,
       ColumnParent column_parent)
     {
       this();
       this.table = table;
       this.key = key;
       this.column_parent = column_parent;
     }
 
     /**
      * Performs a deep copy on <i>other</i>.
      */
     public get_column_count_args(get_column_count_args other) {
       if (other.isSetTable()) {
         this.table = other.table;
       }
       if (other.isSetKey()) {
         this.key = other.key;
       }
       if (other.isSetColumn_parent()) {
         this.column_parent = new ColumnParent(other.column_parent);
       }
     }
 
     @Override
     public get_column_count_args clone() {
       return new get_column_count_args(this);
     }
 
     public String getTable() {
       return this.table;
     }
 
     public void setTable(String table) {
       this.table = table;
     }
 
     public void unsetTable() {
       this.table = null;
     }
 
     // Returns true if field table is set (has been asigned a value) and false otherwise
     public boolean isSetTable() {
       return this.table != null;
     }
 
     public void setTableIsSet(boolean value) {
       if (!value) {
         this.table = null;
       }
     }
 
     public String getKey() {
       return this.key;
     }
 
     public void setKey(String key) {
       this.key = key;
     }
 
     public void unsetKey() {
       this.key = null;
     }
 
     // Returns true if field key is set (has been asigned a value) and false otherwise
     public boolean isSetKey() {
       return this.key != null;
     }
 
     public void setKeyIsSet(boolean value) {
       if (!value) {
         this.key = null;
       }
     }
 
     public ColumnParent getColumn_parent() {
       return this.column_parent;
     }
 
     public void setColumn_parent(ColumnParent column_parent) {
       this.column_parent = column_parent;
     }
 
     public void unsetColumn_parent() {
       this.column_parent = null;
     }
 
     // Returns true if field column_parent is set (has been asigned a value) and false otherwise
     public boolean isSetColumn_parent() {
       return this.column_parent != null;
     }
 
     public void setColumn_parentIsSet(boolean value) {
       if (!value) {
         this.column_parent = null;
       }
     }
 
     public void setFieldValue(int fieldID, Object value) {
       switch (fieldID) {
       case TABLE:
         if (value == null) {
           unsetTable();
         } else {
           setTable((String)value);
         }
         break;
 
       case KEY:
         if (value == null) {
           unsetKey();
         } else {
           setKey((String)value);
         }
         break;
 
       case COLUMN_PARENT:
         if (value == null) {
           unsetColumn_parent();
         } else {
           setColumn_parent((ColumnParent)value);
         }
         break;
 
       default:
         throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
       }
     }
 
     public Object getFieldValue(int fieldID) {
       switch (fieldID) {
       case TABLE:
         return getTable();
 
       case KEY:
         return getKey();
 
       case COLUMN_PARENT:
         return getColumn_parent();
 
       default:
         throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
       }
     }
 
     // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
     public boolean isSet(int fieldID) {
       switch (fieldID) {
       case TABLE:
         return isSetTable();
       case KEY:
         return isSetKey();
       case COLUMN_PARENT:
         return isSetColumn_parent();
       default:
         throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
       }
     }
 
     @Override
     public boolean equals(Object that) {
       if (that == null)
         return false;
       if (that instanceof get_column_count_args)
         return this.equals((get_column_count_args)that);
       return false;
     }
 
     public boolean equals(get_column_count_args that) {
       if (that == null)
         return false;
 
       boolean this_present_table = true && this.isSetTable();
       boolean that_present_table = true && that.isSetTable();
       if (this_present_table || that_present_table) {
         if (!(this_present_table && that_present_table))
           return false;
         if (!this.table.equals(that.table))
           return false;
       }
 
       boolean this_present_key = true && this.isSetKey();
       boolean that_present_key = true && that.isSetKey();
       if (this_present_key || that_present_key) {
         if (!(this_present_key && that_present_key))
           return false;
         if (!this.key.equals(that.key))
           return false;
       }
 
       boolean this_present_column_parent = true && this.isSetColumn_parent();
       boolean that_present_column_parent = true && that.isSetColumn_parent();
       if (this_present_column_parent || that_present_column_parent) {
         if (!(this_present_column_parent && that_present_column_parent))
           return false;
         if (!this.column_parent.equals(that.column_parent))
           return false;
       }
 
       return true;
     }
 
     @Override
     public int hashCode() {
       return 0;
     }
 
     public void read(TProtocol iprot) throws TException {
       TField field;
       iprot.readStructBegin();
       while (true)
       {
         field = iprot.readFieldBegin();
         if (field.type == TType.STOP) { 
           break;
         }
         switch (field.id)
         {
           case TABLE:
             if (field.type == TType.STRING) {
               this.table = iprot.readString();
             } else { 
               TProtocolUtil.skip(iprot, field.type);
             }
             break;
           case KEY:
             if (field.type == TType.STRING) {
               this.key = iprot.readString();
             } else { 
               TProtocolUtil.skip(iprot, field.type);
             }
             break;
           case COLUMN_PARENT:
             if (field.type == TType.STRUCT) {
               this.column_parent = new ColumnParent();
               this.column_parent.read(iprot);
             } else { 
               TProtocolUtil.skip(iprot, field.type);
             }
             break;
           default:
             TProtocolUtil.skip(iprot, field.type);
             break;
         }
         iprot.readFieldEnd();
       }
       iprot.readStructEnd();
 
 
       // check for required fields of primitive type, which can't be checked in the validate method
       validate();
     }
 
     public void write(TProtocol oprot) throws TException {
       validate();
 
       oprot.writeStructBegin(STRUCT_DESC);
       if (this.table != null) {
         oprot.writeFieldBegin(TABLE_FIELD_DESC);
         oprot.writeString(this.table);
         oprot.writeFieldEnd();
       }
       if (this.key != null) {
         oprot.writeFieldBegin(KEY_FIELD_DESC);
         oprot.writeString(this.key);
         oprot.writeFieldEnd();
       }
       if (this.column_parent != null) {
         oprot.writeFieldBegin(COLUMN_PARENT_FIELD_DESC);
         this.column_parent.write(oprot);
         oprot.writeFieldEnd();
       }
       oprot.writeFieldStop();
       oprot.writeStructEnd();
     }
 
     @Override
     public String toString() {
       StringBuilder sb = new StringBuilder("get_column_count_args(");
       boolean first = true;
 
       sb.append("table:");
       if (this.table == null) {
         sb.append("null");
       } else {
         sb.append(this.table);
       }
       first = false;
       if (!first) sb.append(", ");
       sb.append("key:");
       if (this.key == null) {
         sb.append("null");
       } else {
         sb.append(this.key);
       }
       first = false;
       if (!first) sb.append(", ");
       sb.append("column_parent:");
       if (this.column_parent == null) {
         sb.append("null");
       } else {
         sb.append(this.column_parent);
       }
       first = false;
       sb.append(")");
       return sb.toString();
     }
 
     public void validate() throws TException {
       // check for required fields
       // check that fields of type enum have valid values
     }
 
   }
 
   public static class get_column_count_result implements TBase, java.io.Serializable, Cloneable   {
     private static final TStruct STRUCT_DESC = new TStruct("get_column_count_result");
     private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.I32, (short)0);
     private static final TField IRE_FIELD_DESC = new TField("ire", TType.STRUCT, (short)1);
 
     public int success;
     public static final int SUCCESS = 0;
     public InvalidRequestException ire;
     public static final int IRE = 1;
 
     private final Isset __isset = new Isset();
     private static final class Isset implements java.io.Serializable {
       public boolean success = false;
     }
 
     public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
       put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
           new FieldValueMetaData(TType.I32)));
       put(IRE, new FieldMetaData("ire", TFieldRequirementType.DEFAULT, 
           new FieldValueMetaData(TType.STRUCT)));
     }});
 
     static {
       FieldMetaData.addStructMetaDataMap(get_column_count_result.class, metaDataMap);
     }
 
     public get_column_count_result() {
     }
 
     public get_column_count_result(
       int success,
       InvalidRequestException ire)
     {
       this();
       this.success = success;
       this.__isset.success = true;
       this.ire = ire;
     }
 
     /**
      * Performs a deep copy on <i>other</i>.
      */
     public get_column_count_result(get_column_count_result other) {
       __isset.success = other.__isset.success;
       this.success = other.success;
       if (other.isSetIre()) {
         this.ire = new InvalidRequestException(other.ire);
       }
     }
 
     @Override
     public get_column_count_result clone() {
       return new get_column_count_result(this);
     }
 
     public int getSuccess() {
       return this.success;
     }
 
     public void setSuccess(int success) {
       this.success = success;
       this.__isset.success = true;
     }
 
     public void unsetSuccess() {
       this.__isset.success = false;
     }
 
     // Returns true if field success is set (has been asigned a value) and false otherwise
     public boolean isSetSuccess() {
       return this.__isset.success;
     }
 
     public void setSuccessIsSet(boolean value) {
       this.__isset.success = value;
     }
 
     public InvalidRequestException getIre() {
       return this.ire;
     }
 
     public void setIre(InvalidRequestException ire) {
       this.ire = ire;
     }
 
     public void unsetIre() {
       this.ire = null;
     }
 
     // Returns true if field ire is set (has been asigned a value) and false otherwise
     public boolean isSetIre() {
       return this.ire != null;
     }
 
     public void setIreIsSet(boolean value) {
       if (!value) {
         this.ire = null;
       }
     }
 
     public void setFieldValue(int fieldID, Object value) {
       switch (fieldID) {
       case SUCCESS:
         if (value == null) {
           unsetSuccess();
         } else {
           setSuccess((Integer)value);
         }
         break;
 
       case IRE:
         if (value == null) {
           unsetIre();
         } else {
           setIre((InvalidRequestException)value);
         }
         break;
 
       default:
         throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
       }
     }
 
     public Object getFieldValue(int fieldID) {
       switch (fieldID) {
       case SUCCESS:
         return new Integer(getSuccess());
 
       case IRE:
         return getIre();
 
       default:
         throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
       }
     }
 
     // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
     public boolean isSet(int fieldID) {
       switch (fieldID) {
       case SUCCESS:
         return isSetSuccess();
       case IRE:
         return isSetIre();
       default:
         throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
       }
     }
 
     @Override
     public boolean equals(Object that) {
       if (that == null)
         return false;
       if (that instanceof get_column_count_result)
         return this.equals((get_column_count_result)that);
       return false;
     }
 
     public boolean equals(get_column_count_result that) {
       if (that == null)
         return false;
 
       boolean this_present_success = true;
       boolean that_present_success = true;
       if (this_present_success || that_present_success) {
         if (!(this_present_success && that_present_success))
           return false;
         if (this.success != that.success)
           return false;
       }
 
       boolean this_present_ire = true && this.isSetIre();
       boolean that_present_ire = true && that.isSetIre();
       if (this_present_ire || that_present_ire) {
         if (!(this_present_ire && that_present_ire))
           return false;
         if (!this.ire.equals(that.ire))
           return false;
       }
 
       return true;
     }
 
     @Override
     public int hashCode() {
       return 0;
     }
 
     public void read(TProtocol iprot) throws TException {
       TField field;
       iprot.readStructBegin();
       while (true)
       {
         field = iprot.readFieldBegin();
         if (field.type == TType.STOP) { 
           break;
         }
         switch (field.id)
         {
           case SUCCESS:
             if (field.type == TType.I32) {
               this.success = iprot.readI32();
               this.__isset.success = true;
             } else { 
               TProtocolUtil.skip(iprot, field.type);
             }
             break;
           case IRE:
             if (field.type == TType.STRUCT) {
               this.ire = new InvalidRequestException();
               this.ire.read(iprot);
             } else { 
               TProtocolUtil.skip(iprot, field.type);
             }
             break;
           default:
             TProtocolUtil.skip(iprot, field.type);
             break;
         }
         iprot.readFieldEnd();
       }
       iprot.readStructEnd();
 
 
       // check for required fields of primitive type, which can't be checked in the validate method
       validate();
     }
 
     public void write(TProtocol oprot) throws TException {
       oprot.writeStructBegin(STRUCT_DESC);
 
       if (this.isSetSuccess()) {
         oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
         oprot.writeI32(this.success);
         oprot.writeFieldEnd();
       } else if (this.isSetIre()) {
         oprot.writeFieldBegin(IRE_FIELD_DESC);
         this.ire.write(oprot);
         oprot.writeFieldEnd();
       }
       oprot.writeFieldStop();
       oprot.writeStructEnd();
     }
 
     @Override
     public String toString() {
       StringBuilder sb = new StringBuilder("get_column_count_result(");
       boolean first = true;
 
       sb.append("success:");
       sb.append(this.success);
       first = false;
       if (!first) sb.append(", ");
       sb.append("ire:");
       if (this.ire == null) {
         sb.append("null");
       } else {
         sb.append(this.ire);
       }
       first = false;
       sb.append(")");
       return sb.toString();
     }
 
     public void validate() throws TException {
       // check for required fields
       // check that fields of type enum have valid values
     }
 
   }
 
   public static class insert_args implements TBase, java.io.Serializable, Cloneable   {
     private static final TStruct STRUCT_DESC = new TStruct("insert_args");
     private static final TField TABLE_FIELD_DESC = new TField("table", TType.STRING, (short)1);
     private static final TField KEY_FIELD_DESC = new TField("key", TType.STRING, (short)2);
     private static final TField COLUMN_PATH_FIELD_DESC = new TField("column_path", TType.STRUCT, (short)3);
     private static final TField VALUE_FIELD_DESC = new TField("value", TType.STRING, (short)4);
     private static final TField TIMESTAMP_FIELD_DESC = new TField("timestamp", TType.I64, (short)5);
     private static final TField BLOCK_FOR_FIELD_DESC = new TField("block_for", TType.I32, (short)6);
 
     public String table;
     public static final int TABLE = 1;
     public String key;
     public static final int KEY = 2;
     public ColumnPath column_path;
     public static final int COLUMN_PATH = 3;
     public byte[] value;
     public static final int VALUE = 4;
     public long timestamp;
     public static final int TIMESTAMP = 5;
     public int block_for;
     public static final int BLOCK_FOR = 6;
 
     private final Isset __isset = new Isset();
     private static final class Isset implements java.io.Serializable {
       public boolean timestamp = false;
       public boolean block_for = false;
     }
 
     public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
       put(TABLE, new FieldMetaData("table", TFieldRequirementType.DEFAULT, 
           new FieldValueMetaData(TType.STRING)));
       put(KEY, new FieldMetaData("key", TFieldRequirementType.DEFAULT, 
           new FieldValueMetaData(TType.STRING)));
       put(COLUMN_PATH, new FieldMetaData("column_path", TFieldRequirementType.DEFAULT, 
           new StructMetaData(TType.STRUCT, ColumnPath.class)));
       put(VALUE, new FieldMetaData("value", TFieldRequirementType.DEFAULT, 
           new FieldValueMetaData(TType.STRING)));
       put(TIMESTAMP, new FieldMetaData("timestamp", TFieldRequirementType.DEFAULT, 
           new FieldValueMetaData(TType.I64)));
       put(BLOCK_FOR, new FieldMetaData("block_for", TFieldRequirementType.DEFAULT, 
           new FieldValueMetaData(TType.I32)));
     }});
 
     static {
       FieldMetaData.addStructMetaDataMap(insert_args.class, metaDataMap);
     }
 
     public insert_args() {
       this.block_for = 0;
 
     }
 
     public insert_args(
       String table,
       String key,
       ColumnPath column_path,
       byte[] value,
       long timestamp,
       int block_for)
     {
       this();
       this.table = table;
       this.key = key;
       this.column_path = column_path;
       this.value = value;
       this.timestamp = timestamp;
       this.__isset.timestamp = true;
       this.block_for = block_for;
       this.__isset.block_for = true;
     }
 
     /**
      * Performs a deep copy on <i>other</i>.
      */
     public insert_args(insert_args other) {
       if (other.isSetTable()) {
         this.table = other.table;
       }
       if (other.isSetKey()) {
         this.key = other.key;
       }
       if (other.isSetColumn_path()) {
         this.column_path = new ColumnPath(other.column_path);
       }
       if (other.isSetValue()) {
         this.value = new byte[other.value.length];
         System.arraycopy(other.value, 0, value, 0, other.value.length);
       }
       __isset.timestamp = other.__isset.timestamp;
       this.timestamp = other.timestamp;
       __isset.block_for = other.__isset.block_for;
       this.block_for = other.block_for;
     }
 
     @Override
     public insert_args clone() {
       return new insert_args(this);
     }
 
     public String getTable() {
       return this.table;
     }
 
     public void setTable(String table) {
       this.table = table;
     }
 
     public void unsetTable() {
       this.table = null;
     }
 
     // Returns true if field table is set (has been asigned a value) and false otherwise
     public boolean isSetTable() {
       return this.table != null;
     }
 
     public void setTableIsSet(boolean value) {
       if (!value) {
         this.table = null;
       }
     }
 
     public String getKey() {
       return this.key;
     }
 
     public void setKey(String key) {
       this.key = key;
     }
 
     public void unsetKey() {
       this.key = null;
     }
 
     // Returns true if field key is set (has been asigned a value) and false otherwise
     public boolean isSetKey() {
       return this.key != null;
     }
 
     public void setKeyIsSet(boolean value) {
       if (!value) {
         this.key = null;
       }
     }
 
     public ColumnPath getColumn_path() {
       return this.column_path;
     }
 
     public void setColumn_path(ColumnPath column_path) {
       this.column_path = column_path;
     }
 
     public void unsetColumn_path() {
       this.column_path = null;
     }
 
     // Returns true if field column_path is set (has been asigned a value) and false otherwise
     public boolean isSetColumn_path() {
       return this.column_path != null;
     }
 
     public void setColumn_pathIsSet(boolean value) {
       if (!value) {
         this.column_path = null;
       }
     }
 
     public byte[] getValue() {
       return this.value;
     }
 
     public void setValue(byte[] value) {
       this.value = value;
     }
 
     public void unsetValue() {
       this.value = null;
     }
 
     // Returns true if field value is set (has been asigned a value) and false otherwise
     public boolean isSetValue() {
       return this.value != null;
     }
 
     public void setValueIsSet(boolean value) {
       if (!value) {
         this.value = null;
       }
     }
 
     public long getTimestamp() {
       return this.timestamp;
     }
 
     public void setTimestamp(long timestamp) {
       this.timestamp = timestamp;
       this.__isset.timestamp = true;
     }
 
     public void unsetTimestamp() {
       this.__isset.timestamp = false;
     }
 
     // Returns true if field timestamp is set (has been asigned a value) and false otherwise
     public boolean isSetTimestamp() {
       return this.__isset.timestamp;
     }
 
     public void setTimestampIsSet(boolean value) {
       this.__isset.timestamp = value;
     }
 
     public int getBlock_for() {
       return this.block_for;
     }
 
     public void setBlock_for(int block_for) {
       this.block_for = block_for;
       this.__isset.block_for = true;
     }
 
     public void unsetBlock_for() {
       this.__isset.block_for = false;
     }
 
     // Returns true if field block_for is set (has been asigned a value) and false otherwise
     public boolean isSetBlock_for() {
       return this.__isset.block_for;
     }
 
     public void setBlock_forIsSet(boolean value) {
       this.__isset.block_for = value;
     }
 
     public void setFieldValue(int fieldID, Object value) {
       switch (fieldID) {
       case TABLE:
         if (value == null) {
           unsetTable();
         } else {
           setTable((String)value);
         }
         break;
 
       case KEY:
         if (value == null) {
           unsetKey();
         } else {
           setKey((String)value);
         }
         break;
 
       case COLUMN_PATH:
         if (value == null) {
           unsetColumn_path();
         } else {
           setColumn_path((ColumnPath)value);
         }
         break;
 
       case VALUE:
         if (value == null) {
           unsetValue();
         } else {
           setValue((byte[])value);
         }
         break;
 
       case TIMESTAMP:
         if (value == null) {
           unsetTimestamp();
         } else {
           setTimestamp((Long)value);
         }
         break;
 
       case BLOCK_FOR:
         if (value == null) {
           unsetBlock_for();
         } else {
           setBlock_for((Integer)value);
         }
         break;
 
       default:
         throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
       }
     }
 
     public Object getFieldValue(int fieldID) {
       switch (fieldID) {
       case TABLE:
         return getTable();
 
       case KEY:
         return getKey();
 
       case COLUMN_PATH:
         return getColumn_path();
 
       case VALUE:
         return getValue();
 
       case TIMESTAMP:
         return new Long(getTimestamp());
 
       case BLOCK_FOR:
         return new Integer(getBlock_for());
 
       default:
         throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
       }
     }
 
     // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
     public boolean isSet(int fieldID) {
       switch (fieldID) {
       case TABLE:
         return isSetTable();
       case KEY:
         return isSetKey();
       case COLUMN_PATH:
         return isSetColumn_path();
       case VALUE:
         return isSetValue();
       case TIMESTAMP:
         return isSetTimestamp();
       case BLOCK_FOR:
         return isSetBlock_for();
       default:
         throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
       }
     }
 
     @Override
     public boolean equals(Object that) {
       if (that == null)
         return false;
       if (that instanceof insert_args)
         return this.equals((insert_args)that);
       return false;
     }
 
     public boolean equals(insert_args that) {
       if (that == null)
         return false;
 
       boolean this_present_table = true && this.isSetTable();
       boolean that_present_table = true && that.isSetTable();
       if (this_present_table || that_present_table) {
         if (!(this_present_table && that_present_table))
           return false;
         if (!this.table.equals(that.table))
           return false;
       }
 
       boolean this_present_key = true && this.isSetKey();
       boolean that_present_key = true && that.isSetKey();
       if (this_present_key || that_present_key) {
         if (!(this_present_key && that_present_key))
           return false;
         if (!this.key.equals(that.key))
           return false;
       }
 
       boolean this_present_column_path = true && this.isSetColumn_path();
       boolean that_present_column_path = true && that.isSetColumn_path();
       if (this_present_column_path || that_present_column_path) {
         if (!(this_present_column_path && that_present_column_path))
           return false;
         if (!this.column_path.equals(that.column_path))
           return false;
       }
 
       boolean this_present_value = true && this.isSetValue();
       boolean that_present_value = true && that.isSetValue();
       if (this_present_value || that_present_value) {
         if (!(this_present_value && that_present_value))
           return false;
         if (!java.util.Arrays.equals(this.value, that.value))
           return false;
       }
 
       boolean this_present_timestamp = true;
       boolean that_present_timestamp = true;
       if (this_present_timestamp || that_present_timestamp) {
         if (!(this_present_timestamp && that_present_timestamp))
           return false;
         if (this.timestamp != that.timestamp)
           return false;
       }
 
       boolean this_present_block_for = true;
       boolean that_present_block_for = true;
       if (this_present_block_for || that_present_block_for) {
         if (!(this_present_block_for && that_present_block_for))
           return false;
         if (this.block_for != that.block_for)
           return false;
       }
 
       return true;
     }
 
     @Override
     public int hashCode() {
       return 0;
     }
 
     public void read(TProtocol iprot) throws TException {
       TField field;
       iprot.readStructBegin();
       while (true)
       {
         field = iprot.readFieldBegin();
         if (field.type == TType.STOP) { 
           break;
         }
         switch (field.id)
         {
           case TABLE:
             if (field.type == TType.STRING) {
               this.table = iprot.readString();
             } else { 
               TProtocolUtil.skip(iprot, field.type);
             }
             break;
           case KEY:
             if (field.type == TType.STRING) {
               this.key = iprot.readString();
             } else { 
               TProtocolUtil.skip(iprot, field.type);
             }
             break;
           case COLUMN_PATH:
             if (field.type == TType.STRUCT) {
               this.column_path = new ColumnPath();
               this.column_path.read(iprot);
             } else { 
               TProtocolUtil.skip(iprot, field.type);
             }
             break;
           case VALUE:
             if (field.type == TType.STRING) {
               this.value = iprot.readBinary();
             } else { 
               TProtocolUtil.skip(iprot, field.type);
             }
             break;
           case TIMESTAMP:
             if (field.type == TType.I64) {
               this.timestamp = iprot.readI64();
               this.__isset.timestamp = true;
             } else { 
               TProtocolUtil.skip(iprot, field.type);
             }
             break;
           case BLOCK_FOR:
             if (field.type == TType.I32) {
               this.block_for = iprot.readI32();
               this.__isset.block_for = true;
             } else { 
               TProtocolUtil.skip(iprot, field.type);
             }
             break;
           default:
             TProtocolUtil.skip(iprot, field.type);
             break;
         }
         iprot.readFieldEnd();
       }
       iprot.readStructEnd();
 
 
       // check for required fields of primitive type, which can't be checked in the validate method
       validate();
     }
 
     public void write(TProtocol oprot) throws TException {
       validate();
 
       oprot.writeStructBegin(STRUCT_DESC);
       if (this.table != null) {
         oprot.writeFieldBegin(TABLE_FIELD_DESC);
         oprot.writeString(this.table);
         oprot.writeFieldEnd();
       }
       if (this.key != null) {
         oprot.writeFieldBegin(KEY_FIELD_DESC);
         oprot.writeString(this.key);
         oprot.writeFieldEnd();
       }
       if (this.column_path != null) {
         oprot.writeFieldBegin(COLUMN_PATH_FIELD_DESC);
         this.column_path.write(oprot);
         oprot.writeFieldEnd();
       }
       if (this.value != null) {
         oprot.writeFieldBegin(VALUE_FIELD_DESC);
         oprot.writeBinary(this.value);
         oprot.writeFieldEnd();
       }
       oprot.writeFieldBegin(TIMESTAMP_FIELD_DESC);
       oprot.writeI64(this.timestamp);
       oprot.writeFieldEnd();
       oprot.writeFieldBegin(BLOCK_FOR_FIELD_DESC);
       oprot.writeI32(this.block_for);
       oprot.writeFieldEnd();
       oprot.writeFieldStop();
       oprot.writeStructEnd();
     }
 
     @Override
     public String toString() {
       StringBuilder sb = new StringBuilder("insert_args(");
       boolean first = true;
 
       sb.append("table:");
       if (this.table == null) {
         sb.append("null");
       } else {
         sb.append(this.table);
       }
       first = false;
       if (!first) sb.append(", ");
       sb.append("key:");
       if (this.key == null) {
         sb.append("null");
       } else {
         sb.append(this.key);
       }
       first = false;
       if (!first) sb.append(", ");
       sb.append("column_path:");
       if (this.column_path == null) {
         sb.append("null");
       } else {
         sb.append(this.column_path);
       }
       first = false;
       if (!first) sb.append(", ");
       sb.append("value:");
       if (this.value == null) {
         sb.append("null");
       } else {
           int __value_size = Math.min(this.value.length, 128);
           for (int i = 0; i < __value_size; i++) {
             if (i != 0) sb.append(" ");
             sb.append(Integer.toHexString(this.value[i]).length() > 1 ? Integer.toHexString(this.value[i]).substring(Integer.toHexString(this.value[i]).length() - 2).toUpperCase() : "0" + Integer.toHexString(this.value[i]).toUpperCase());
           }
           if (this.value.length > 128) sb.append(" ...");
       }
       first = false;
       if (!first) sb.append(", ");
       sb.append("timestamp:");
       sb.append(this.timestamp);
       first = false;
       if (!first) sb.append(", ");
       sb.append("block_for:");
       sb.append(this.block_for);
       first = false;
       sb.append(")");
       return sb.toString();
     }
 
     public void validate() throws TException {
       // check for required fields
       // check that fields of type enum have valid values
     }
 
   }
 
   public static class insert_result implements TBase, java.io.Serializable, Cloneable   {
     private static final TStruct STRUCT_DESC = new TStruct("insert_result");
     private static final TField IRE_FIELD_DESC = new TField("ire", TType.STRUCT, (short)1);
     private static final TField UE_FIELD_DESC = new TField("ue", TType.STRUCT, (short)2);
 
     public InvalidRequestException ire;
     public static final int IRE = 1;
     public UnavailableException ue;
     public static final int UE = 2;
 
     private final Isset __isset = new Isset();
     private static final class Isset implements java.io.Serializable {
     }
 
     public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
       put(IRE, new FieldMetaData("ire", TFieldRequirementType.DEFAULT, 
           new FieldValueMetaData(TType.STRUCT)));
       put(UE, new FieldMetaData("ue", TFieldRequirementType.DEFAULT, 
           new FieldValueMetaData(TType.STRUCT)));
     }});
 
     static {
       FieldMetaData.addStructMetaDataMap(insert_result.class, metaDataMap);
     }
 
     public insert_result() {
     }
 
     public insert_result(
       InvalidRequestException ire,
       UnavailableException ue)
     {
       this();
       this.ire = ire;
       this.ue = ue;
     }
 
     /**
      * Performs a deep copy on <i>other</i>.
      */
     public insert_result(insert_result other) {
       if (other.isSetIre()) {
         this.ire = new InvalidRequestException(other.ire);
       }
       if (other.isSetUe()) {
         this.ue = new UnavailableException(other.ue);
       }
     }
 
     @Override
     public insert_result clone() {
       return new insert_result(this);
     }
 
     public InvalidRequestException getIre() {
       return this.ire;
     }
 
     public void setIre(InvalidRequestException ire) {
       this.ire = ire;
     }
 
     public void unsetIre() {
       this.ire = null;
     }
 
     // Returns true if field ire is set (has been asigned a value) and false otherwise
     public boolean isSetIre() {
       return this.ire != null;
     }
 
     public void setIreIsSet(boolean value) {
       if (!value) {
         this.ire = null;
       }
     }
 
     public UnavailableException getUe() {
       return this.ue;
     }
 
     public void setUe(UnavailableException ue) {
       this.ue = ue;
     }
 
     public void unsetUe() {
       this.ue = null;
     }
 
     // Returns true if field ue is set (has been asigned a value) and false otherwise
     public boolean isSetUe() {
       return this.ue != null;
     }
 
     public void setUeIsSet(boolean value) {
       if (!value) {
         this.ue = null;
       }
     }
 
     public void setFieldValue(int fieldID, Object value) {
       switch (fieldID) {
       case IRE:
         if (value == null) {
           unsetIre();
         } else {
           setIre((InvalidRequestException)value);
         }
         break;
 
       case UE:
         if (value == null) {
           unsetUe();
         } else {
           setUe((UnavailableException)value);
         }
         break;
 
       default:
         throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
       }
     }
 
     public Object getFieldValue(int fieldID) {
       switch (fieldID) {
       case IRE:
         return getIre();
 
       case UE:
         return getUe();
 
       default:
         throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
       }
     }
 
     // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
     public boolean isSet(int fieldID) {
       switch (fieldID) {
       case IRE:
         return isSetIre();
       case UE:
         return isSetUe();
       default:
         throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
       }
     }
 
     @Override
     public boolean equals(Object that) {
       if (that == null)
         return false;
       if (that instanceof insert_result)
         return this.equals((insert_result)that);
       return false;
     }
 
     public boolean equals(insert_result that) {
       if (that == null)
         return false;
 
       boolean this_present_ire = true && this.isSetIre();
       boolean that_present_ire = true && that.isSetIre();
       if (this_present_ire || that_present_ire) {
         if (!(this_present_ire && that_present_ire))
           return false;
         if (!this.ire.equals(that.ire))
           return false;
       }
 
       boolean this_present_ue = true && this.isSetUe();
       boolean that_present_ue = true && that.isSetUe();
       if (this_present_ue || that_present_ue) {
         if (!(this_present_ue && that_present_ue))
           return false;
         if (!this.ue.equals(that.ue))
           return false;
       }
 
       return true;
     }
 
     @Override
     public int hashCode() {
       return 0;
     }
 
     public void read(TProtocol iprot) throws TException {
       TField field;
       iprot.readStructBegin();
       while (true)
       {
         field = iprot.readFieldBegin();
         if (field.type == TType.STOP) { 
           break;
         }
         switch (field.id)
         {
           case IRE:
             if (field.type == TType.STRUCT) {
               this.ire = new InvalidRequestException();
               this.ire.read(iprot);
             } else { 
               TProtocolUtil.skip(iprot, field.type);
             }
             break;
           case UE:
             if (field.type == TType.STRUCT) {
               this.ue = new UnavailableException();
               this.ue.read(iprot);
             } else { 
               TProtocolUtil.skip(iprot, field.type);
             }
             break;
           default:
             TProtocolUtil.skip(iprot, field.type);
             break;
         }
         iprot.readFieldEnd();
       }
       iprot.readStructEnd();
 
 
       // check for required fields of primitive type, which can't be checked in the validate method
       validate();
     }
 
     public void write(TProtocol oprot) throws TException {
       oprot.writeStructBegin(STRUCT_DESC);
 
       if (this.isSetIre()) {
         oprot.writeFieldBegin(IRE_FIELD_DESC);
         this.ire.write(oprot);
         oprot.writeFieldEnd();
       } else if (this.isSetUe()) {
         oprot.writeFieldBegin(UE_FIELD_DESC);
         this.ue.write(oprot);
         oprot.writeFieldEnd();
       }
       oprot.writeFieldStop();
       oprot.writeStructEnd();
     }
 
     @Override
     public String toString() {
       StringBuilder sb = new StringBuilder("insert_result(");
       boolean first = true;
 
       sb.append("ire:");
       if (this.ire == null) {
         sb.append("null");
       } else {
         sb.append(this.ire);
       }
       first = false;
       if (!first) sb.append(", ");
       sb.append("ue:");
       if (this.ue == null) {
         sb.append("null");
       } else {
         sb.append(this.ue);
       }
       first = false;
       sb.append(")");
       return sb.toString();
     }
 
     public void validate() throws TException {
       // check for required fields
       // check that fields of type enum have valid values
     }
 
   }
 
   public static class batch_insert_args implements TBase, java.io.Serializable, Cloneable   {
     private static final TStruct STRUCT_DESC = new TStruct("batch_insert_args");
     private static final TField TABLE_FIELD_DESC = new TField("table", TType.STRING, (short)1);
     private static final TField BATCH_MUTATION_FIELD_DESC = new TField("batch_mutation", TType.STRUCT, (short)2);
     private static final TField BLOCK_FOR_FIELD_DESC = new TField("block_for", TType.I32, (short)3);
 
     public String table;
     public static final int TABLE = 1;
     public BatchMutation batch_mutation;
     public static final int BATCH_MUTATION = 2;
     public int block_for;
     public static final int BLOCK_FOR = 3;
 
     private final Isset __isset = new Isset();
     private static final class Isset implements java.io.Serializable {
       public boolean block_for = false;
     }
 
     public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
       put(TABLE, new FieldMetaData("table", TFieldRequirementType.DEFAULT, 
           new FieldValueMetaData(TType.STRING)));
       put(BATCH_MUTATION, new FieldMetaData("batch_mutation", TFieldRequirementType.DEFAULT, 
           new StructMetaData(TType.STRUCT, BatchMutation.class)));
       put(BLOCK_FOR, new FieldMetaData("block_for", TFieldRequirementType.DEFAULT, 
           new FieldValueMetaData(TType.I32)));
     }});
 
     static {
       FieldMetaData.addStructMetaDataMap(batch_insert_args.class, metaDataMap);
     }
 
     public batch_insert_args() {
       this.block_for = 0;
 
     }
 
     public batch_insert_args(
       String table,
       BatchMutation batch_mutation,
       int block_for)
     {
       this();
       this.table = table;
       this.batch_mutation = batch_mutation;
       this.block_for = block_for;
       this.__isset.block_for = true;
     }
 
     /**
      * Performs a deep copy on <i>other</i>.
      */
     public batch_insert_args(batch_insert_args other) {
       if (other.isSetTable()) {
         this.table = other.table;
       }
       if (other.isSetBatch_mutation()) {
         this.batch_mutation = new BatchMutation(other.batch_mutation);
       }
       __isset.block_for = other.__isset.block_for;
       this.block_for = other.block_for;
     }
 
     @Override
     public batch_insert_args clone() {
       return new batch_insert_args(this);
     }
 
     public String getTable() {
       return this.table;
     }
 
     public void setTable(String table) {
       this.table = table;
     }
 
     public void unsetTable() {
       this.table = null;
     }
 
     // Returns true if field table is set (has been asigned a value) and false otherwise
     public boolean isSetTable() {
       return this.table != null;
     }
 
     public void setTableIsSet(boolean value) {
       if (!value) {
         this.table = null;
       }
     }
 
     public BatchMutation getBatch_mutation() {
       return this.batch_mutation;
     }
 
     public void setBatch_mutation(BatchMutation batch_mutation) {
       this.batch_mutation = batch_mutation;
     }
 
     public void unsetBatch_mutation() {
       this.batch_mutation = null;
     }
 
     // Returns true if field batch_mutation is set (has been asigned a value) and false otherwise
     public boolean isSetBatch_mutation() {
       return this.batch_mutation != null;
     }
 
     public void setBatch_mutationIsSet(boolean value) {
       if (!value) {
         this.batch_mutation = null;
       }
     }
 
     public int getBlock_for() {
       return this.block_for;
     }
 
     public void setBlock_for(int block_for) {
       this.block_for = block_for;
       this.__isset.block_for = true;
     }
 
     public void unsetBlock_for() {
       this.__isset.block_for = false;
     }
 
     // Returns true if field block_for is set (has been asigned a value) and false otherwise
     public boolean isSetBlock_for() {
       return this.__isset.block_for;
     }
 
     public void setBlock_forIsSet(boolean value) {
       this.__isset.block_for = value;
     }
 
     public void setFieldValue(int fieldID, Object value) {
       switch (fieldID) {
       case TABLE:
         if (value == null) {
           unsetTable();
         } else {
           setTable((String)value);
         }
         break;
 
       case BATCH_MUTATION:
         if (value == null) {
           unsetBatch_mutation();
         } else {
           setBatch_mutation((BatchMutation)value);
         }
         break;
 
       case BLOCK_FOR:
         if (value == null) {
           unsetBlock_for();
         } else {
           setBlock_for((Integer)value);
         }
         break;
 
       default:
         throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
       }
     }
 
     public Object getFieldValue(int fieldID) {
       switch (fieldID) {
       case TABLE:
         return getTable();
 
       case BATCH_MUTATION:
         return getBatch_mutation();
 
       case BLOCK_FOR:
         return new Integer(getBlock_for());
 
       default:
         throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
       }
     }
 
     // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
     public boolean isSet(int fieldID) {
       switch (fieldID) {
       case TABLE:
         return isSetTable();
       case BATCH_MUTATION:
         return isSetBatch_mutation();
       case BLOCK_FOR:
         return isSetBlock_for();
       default:
         throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
       }
     }
 
     @Override
     public boolean equals(Object that) {
       if (that == null)
         return false;
       if (that instanceof batch_insert_args)
         return this.equals((batch_insert_args)that);
       return false;
     }
 
     public boolean equals(batch_insert_args that) {
       if (that == null)
         return false;
 
       boolean this_present_table = true && this.isSetTable();
       boolean that_present_table = true && that.isSetTable();
       if (this_present_table || that_present_table) {
         if (!(this_present_table && that_present_table))
           return false;
         if (!this.table.equals(that.table))
           return false;
       }
 
       boolean this_present_batch_mutation = true && this.isSetBatch_mutation();
       boolean that_present_batch_mutation = true && that.isSetBatch_mutation();
       if (this_present_batch_mutation || that_present_batch_mutation) {
         if (!(this_present_batch_mutation && that_present_batch_mutation))
           return false;
         if (!this.batch_mutation.equals(that.batch_mutation))
           return false;
       }
 
       boolean this_present_block_for = true;
       boolean that_present_block_for = true;
       if (this_present_block_for || that_present_block_for) {
         if (!(this_present_block_for && that_present_block_for))
           return false;
         if (this.block_for != that.block_for)
           return false;
       }
 
       return true;
     }
 
     @Override
     public int hashCode() {
       return 0;
     }
 
     public void read(TProtocol iprot) throws TException {
       TField field;
       iprot.readStructBegin();
       while (true)
       {
         field = iprot.readFieldBegin();
         if (field.type == TType.STOP) { 
           break;
         }
         switch (field.id)
         {
           case TABLE:
             if (field.type == TType.STRING) {
               this.table = iprot.readString();
             } else { 
               TProtocolUtil.skip(iprot, field.type);
             }
             break;
           case BATCH_MUTATION:
             if (field.type == TType.STRUCT) {
               this.batch_mutation = new BatchMutation();
               this.batch_mutation.read(iprot);
             } else { 
               TProtocolUtil.skip(iprot, field.type);
             }
             break;
           case BLOCK_FOR:
             if (field.type == TType.I32) {
               this.block_for = iprot.readI32();
               this.__isset.block_for = true;
             } else { 
               TProtocolUtil.skip(iprot, field.type);
             }
             break;
           default:
             TProtocolUtil.skip(iprot, field.type);
             break;
         }
         iprot.readFieldEnd();
       }
       iprot.readStructEnd();
 
 
       // check for required fields of primitive type, which can't be checked in the validate method
       validate();
     }
 
     public void write(TProtocol oprot) throws TException {
       validate();
 
       oprot.writeStructBegin(STRUCT_DESC);
       if (this.table != null) {
         oprot.writeFieldBegin(TABLE_FIELD_DESC);
         oprot.writeString(this.table);
         oprot.writeFieldEnd();
       }
       if (this.batch_mutation != null) {
         oprot.writeFieldBegin(BATCH_MUTATION_FIELD_DESC);
         this.batch_mutation.write(oprot);
         oprot.writeFieldEnd();
       }
       oprot.writeFieldBegin(BLOCK_FOR_FIELD_DESC);
       oprot.writeI32(this.block_for);
       oprot.writeFieldEnd();
       oprot.writeFieldStop();
       oprot.writeStructEnd();
     }
 
     @Override
     public String toString() {
       StringBuilder sb = new StringBuilder("batch_insert_args(");
       boolean first = true;
 
       sb.append("table:");
       if (this.table == null) {
         sb.append("null");
       } else {
         sb.append(this.table);
       }
       first = false;
       if (!first) sb.append(", ");
       sb.append("batch_mutation:");
       if (this.batch_mutation == null) {
         sb.append("null");
       } else {
         sb.append(this.batch_mutation);
       }
       first = false;
       if (!first) sb.append(", ");
       sb.append("block_for:");
       sb.append(this.block_for);
       first = false;
       sb.append(")");
       return sb.toString();
     }
 
     public void validate() throws TException {
       // check for required fields
       // check that fields of type enum have valid values
     }
 
   }
 
   public static class batch_insert_result implements TBase, java.io.Serializable, Cloneable   {
     private static final TStruct STRUCT_DESC = new TStruct("batch_insert_result");
     private static final TField IRE_FIELD_DESC = new TField("ire", TType.STRUCT, (short)1);
     private static final TField UE_FIELD_DESC = new TField("ue", TType.STRUCT, (short)2);
 
     public InvalidRequestException ire;
     public static final int IRE = 1;
     public UnavailableException ue;
     public static final int UE = 2;
 
     private final Isset __isset = new Isset();
     private static final class Isset implements java.io.Serializable {
     }
 
     public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
       put(IRE, new FieldMetaData("ire", TFieldRequirementType.DEFAULT, 
           new FieldValueMetaData(TType.STRUCT)));
       put(UE, new FieldMetaData("ue", TFieldRequirementType.DEFAULT, 
           new FieldValueMetaData(TType.STRUCT)));
     }});
 
     static {
       FieldMetaData.addStructMetaDataMap(batch_insert_result.class, metaDataMap);
     }
 
     public batch_insert_result() {
     }
 
     public batch_insert_result(
       InvalidRequestException ire,
       UnavailableException ue)
     {
       this();
       this.ire = ire;
       this.ue = ue;
     }
 
     /**
      * Performs a deep copy on <i>other</i>.
      */
     public batch_insert_result(batch_insert_result other) {
       if (other.isSetIre()) {
         this.ire = new InvalidRequestException(other.ire);
       }
       if (other.isSetUe()) {
         this.ue = new UnavailableException(other.ue);
       }
     }
 
     @Override
     public batch_insert_result clone() {
       return new batch_insert_result(this);
     }
 
     public InvalidRequestException getIre() {
       return this.ire;
     }
 
     public void setIre(InvalidRequestException ire) {
       this.ire = ire;
     }
 
     public void unsetIre() {
       this.ire = null;
     }
 
     // Returns true if field ire is set (has been asigned a value) and false otherwise
     public boolean isSetIre() {
       return this.ire != null;
     }
 
     public void setIreIsSet(boolean value) {
       if (!value) {
         this.ire = null;
       }
     }
 
     public UnavailableException getUe() {
       return this.ue;
     }
 
     public void setUe(UnavailableException ue) {
       this.ue = ue;
     }
 
     public void unsetUe() {
       this.ue = null;
     }
 
     // Returns true if field ue is set (has been asigned a value) and false otherwise
     public boolean isSetUe() {
       return this.ue != null;
     }
 
     public void setUeIsSet(boolean value) {
       if (!value) {
         this.ue = null;
       }
     }
 
     public void setFieldValue(int fieldID, Object value) {
       switch (fieldID) {
       case IRE:
         if (value == null) {
           unsetIre();
         } else {
           setIre((InvalidRequestException)value);
         }
         break;
 
       case UE:
         if (value == null) {
           unsetUe();
         } else {
           setUe((UnavailableException)value);
         }
         break;
 
       default:
         throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
       }
     }
 
     public Object getFieldValue(int fieldID) {
       switch (fieldID) {
       case IRE:
         return getIre();
 
       case UE:
         return getUe();
 
       default:
         throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
       }
     }
 
     // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
     public boolean isSet(int fieldID) {
       switch (fieldID) {
       case IRE:
         return isSetIre();
       case UE:
         return isSetUe();
       default:
         throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
       }
     }
 
     @Override
     public boolean equals(Object that) {
       if (that == null)
         return false;
       if (that instanceof batch_insert_result)
         return this.equals((batch_insert_result)that);
       return false;
     }
 
     public boolean equals(batch_insert_result that) {
       if (that == null)
         return false;
 
       boolean this_present_ire = true && this.isSetIre();
       boolean that_present_ire = true && that.isSetIre();
       if (this_present_ire || that_present_ire) {
         if (!(this_present_ire && that_present_ire))
           return false;
         if (!this.ire.equals(that.ire))
           return false;
       }
 
       boolean this_present_ue = true && this.isSetUe();
       boolean that_present_ue = true && that.isSetUe();
       if (this_present_ue || that_present_ue) {
         if (!(this_present_ue && that_present_ue))
           return false;
         if (!this.ue.equals(that.ue))
           return false;
       }
 
       return true;
     }
 
     @Override
     public int hashCode() {
       return 0;
     }
 
     public void read(TProtocol iprot) throws TException {
       TField field;
       iprot.readStructBegin();
       while (true)
       {
         field = iprot.readFieldBegin();
         if (field.type == TType.STOP) { 
           break;
         }
         switch (field.id)
         {
           case IRE:
             if (field.type == TType.STRUCT) {
               this.ire = new InvalidRequestException();
               this.ire.read(iprot);
             } else { 
               TProtocolUtil.skip(iprot, field.type);
             }
             break;
           case UE:
             if (field.type == TType.STRUCT) {
               this.ue = new UnavailableException();
               this.ue.read(iprot);
             } else { 
               TProtocolUtil.skip(iprot, field.type);
             }
             break;
           default:
             TProtocolUtil.skip(iprot, field.type);
             break;
         }
         iprot.readFieldEnd();
       }
       iprot.readStructEnd();
 
 
       // check for required fields of primitive type, which can't be checked in the validate method
       validate();
     }
 
     public void write(TProtocol oprot) throws TException {
       oprot.writeStructBegin(STRUCT_DESC);
 
       if (this.isSetIre()) {
         oprot.writeFieldBegin(IRE_FIELD_DESC);
         this.ire.write(oprot);
         oprot.writeFieldEnd();
       } else if (this.isSetUe()) {
         oprot.writeFieldBegin(UE_FIELD_DESC);
         this.ue.write(oprot);
         oprot.writeFieldEnd();
       }
       oprot.writeFieldStop();
       oprot.writeStructEnd();
     }
 
     @Override
     public String toString() {
       StringBuilder sb = new StringBuilder("batch_insert_result(");
       boolean first = true;
 
       sb.append("ire:");
       if (this.ire == null) {
         sb.append("null");
       } else {
         sb.append(this.ire);
       }
       first = false;
       if (!first) sb.append(", ");
       sb.append("ue:");
       if (this.ue == null) {
         sb.append("null");
       } else {
         sb.append(this.ue);
       }
       first = false;
       sb.append(")");
       return sb.toString();
     }
 
     public void validate() throws TException {
       // check for required fields
       // check that fields of type enum have valid values
     }
 
   }
 
   public static class remove_args implements TBase, java.io.Serializable, Cloneable   {
     private static final TStruct STRUCT_DESC = new TStruct("remove_args");
     private static final TField TABLE_FIELD_DESC = new TField("table", TType.STRING, (short)1);
     private static final TField KEY_FIELD_DESC = new TField("key", TType.STRING, (short)2);
     private static final TField COLUMN_PATH_OR_PARENT_FIELD_DESC = new TField("column_path_or_parent", TType.STRUCT, (short)3);
     private static final TField TIMESTAMP_FIELD_DESC = new TField("timestamp", TType.I64, (short)4);
     private static final TField BLOCK_FOR_FIELD_DESC = new TField("block_for", TType.I32, (short)5);
 
     public String table;
     public static final int TABLE = 1;
     public String key;
     public static final int KEY = 2;
     public ColumnPathOrParent column_path_or_parent;
     public static final int COLUMN_PATH_OR_PARENT = 3;
     public long timestamp;
     public static final int TIMESTAMP = 4;
     public int block_for;
     public static final int BLOCK_FOR = 5;
 
     private final Isset __isset = new Isset();
     private static final class Isset implements java.io.Serializable {
       public boolean timestamp = false;
       public boolean block_for = false;
     }
 
     public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
       put(TABLE, new FieldMetaData("table", TFieldRequirementType.DEFAULT, 
           new FieldValueMetaData(TType.STRING)));
       put(KEY, new FieldMetaData("key", TFieldRequirementType.DEFAULT, 
           new FieldValueMetaData(TType.STRING)));
       put(COLUMN_PATH_OR_PARENT, new FieldMetaData("column_path_or_parent", TFieldRequirementType.DEFAULT, 
           new StructMetaData(TType.STRUCT, ColumnPathOrParent.class)));
       put(TIMESTAMP, new FieldMetaData("timestamp", TFieldRequirementType.DEFAULT, 
           new FieldValueMetaData(TType.I64)));
       put(BLOCK_FOR, new FieldMetaData("block_for", TFieldRequirementType.DEFAULT, 
           new FieldValueMetaData(TType.I32)));
     }});
 
     static {
       FieldMetaData.addStructMetaDataMap(remove_args.class, metaDataMap);
     }
 
     public remove_args() {
       this.block_for = 0;
 
     }
 
     public remove_args(
       String table,
       String key,
       ColumnPathOrParent column_path_or_parent,
       long timestamp,
       int block_for)
     {
       this();
       this.table = table;
       this.key = key;
       this.column_path_or_parent = column_path_or_parent;
       this.timestamp = timestamp;
       this.__isset.timestamp = true;
       this.block_for = block_for;
       this.__isset.block_for = true;
     }
 
     /**
      * Performs a deep copy on <i>other</i>.
      */
     public remove_args(remove_args other) {
       if (other.isSetTable()) {
         this.table = other.table;
       }
       if (other.isSetKey()) {
         this.key = other.key;
       }
       if (other.isSetColumn_path_or_parent()) {
         this.column_path_or_parent = new ColumnPathOrParent(other.column_path_or_parent);
       }
       __isset.timestamp = other.__isset.timestamp;
       this.timestamp = other.timestamp;
       __isset.block_for = other.__isset.block_for;
       this.block_for = other.block_for;
     }
 
     @Override
     public remove_args clone() {
       return new remove_args(this);
     }
 
     public String getTable() {
       return this.table;
     }
 
     public void setTable(String table) {
       this.table = table;
     }
 
     public void unsetTable() {
       this.table = null;
     }
 
     // Returns true if field table is set (has been asigned a value) and false otherwise
     public boolean isSetTable() {
       return this.table != null;
     }
 
     public void setTableIsSet(boolean value) {
       if (!value) {
         this.table = null;
       }
     }
 
     public String getKey() {
       return this.key;
     }
 
     public void setKey(String key) {
       this.key = key;
     }
 
     public void unsetKey() {
       this.key = null;
     }
 
     // Returns true if field key is set (has been asigned a value) and false otherwise
     public boolean isSetKey() {
       return this.key != null;
     }
 
     public void setKeyIsSet(boolean value) {
       if (!value) {
         this.key = null;
       }
     }
 
     public ColumnPathOrParent getColumn_path_or_parent() {
       return this.column_path_or_parent;
     }
 
     public void setColumn_path_or_parent(ColumnPathOrParent column_path_or_parent) {
       this.column_path_or_parent = column_path_or_parent;
     }
 
     public void unsetColumn_path_or_parent() {
       this.column_path_or_parent = null;
     }
 
     // Returns true if field column_path_or_parent is set (has been asigned a value) and false otherwise
     public boolean isSetColumn_path_or_parent() {
       return this.column_path_or_parent != null;
     }
 
     public void setColumn_path_or_parentIsSet(boolean value) {
       if (!value) {
         this.column_path_or_parent = null;
       }
     }
 
     public long getTimestamp() {
       return this.timestamp;
     }
 
     public void setTimestamp(long timestamp) {
       this.timestamp = timestamp;
       this.__isset.timestamp = true;
     }
 
     public void unsetTimestamp() {
       this.__isset.timestamp = false;
     }
 
     // Returns true if field timestamp is set (has been asigned a value) and false otherwise
     public boolean isSetTimestamp() {
       return this.__isset.timestamp;
     }
 
     public void setTimestampIsSet(boolean value) {
       this.__isset.timestamp = value;
     }
 
     public int getBlock_for() {
       return this.block_for;
     }
 
     public void setBlock_for(int block_for) {
       this.block_for = block_for;
       this.__isset.block_for = true;
     }
 
     public void unsetBlock_for() {
       this.__isset.block_for = false;
     }
 
     // Returns true if field block_for is set (has been asigned a value) and false otherwise
     public boolean isSetBlock_for() {
       return this.__isset.block_for;
     }
 
     public void setBlock_forIsSet(boolean value) {
       this.__isset.block_for = value;
     }
 
     public void setFieldValue(int fieldID, Object value) {
       switch (fieldID) {
       case TABLE:
         if (value == null) {
           unsetTable();
         } else {
           setTable((String)value);
         }
         break;
 
       case KEY:
         if (value == null) {
           unsetKey();
         } else {
           setKey((String)value);
         }
         break;
 
       case COLUMN_PATH_OR_PARENT:
         if (value == null) {
           unsetColumn_path_or_parent();
         } else {
           setColumn_path_or_parent((ColumnPathOrParent)value);
         }
         break;
 
       case TIMESTAMP:
         if (value == null) {
           unsetTimestamp();
         } else {
           setTimestamp((Long)value);
         }
         break;
 
       case BLOCK_FOR:
         if (value == null) {
           unsetBlock_for();
         } else {
           setBlock_for((Integer)value);
         }
         break;
 
       default:
         throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
       }
     }
 
     public Object getFieldValue(int fieldID) {
       switch (fieldID) {
       case TABLE:
         return getTable();
 
       case KEY:
         return getKey();
 
       case COLUMN_PATH_OR_PARENT:
         return getColumn_path_or_parent();
 
       case TIMESTAMP:
         return new Long(getTimestamp());
 
       case BLOCK_FOR:
         return new Integer(getBlock_for());
 
       default:
         throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
       }
     }
 
     // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
     public boolean isSet(int fieldID) {
       switch (fieldID) {
       case TABLE:
         return isSetTable();
       case KEY:
         return isSetKey();
       case COLUMN_PATH_OR_PARENT:
         return isSetColumn_path_or_parent();
       case TIMESTAMP:
         return isSetTimestamp();
       case BLOCK_FOR:
         return isSetBlock_for();
       default:
         throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
       }
     }
 
     @Override
     public boolean equals(Object that) {
       if (that == null)
         return false;
       if (that instanceof remove_args)
         return this.equals((remove_args)that);
       return false;
     }
 
     public boolean equals(remove_args that) {
       if (that == null)
         return false;
 
       boolean this_present_table = true && this.isSetTable();
       boolean that_present_table = true && that.isSetTable();
       if (this_present_table || that_present_table) {
         if (!(this_present_table && that_present_table))
           return false;
         if (!this.table.equals(that.table))
           return false;
       }
 
       boolean this_present_key = true && this.isSetKey();
       boolean that_present_key = true && that.isSetKey();
       if (this_present_key || that_present_key) {
         if (!(this_present_key && that_present_key))
           return false;
         if (!this.key.equals(that.key))
           return false;
       }
 
       boolean this_present_column_path_or_parent = true && this.isSetColumn_path_or_parent();
       boolean that_present_column_path_or_parent = true && that.isSetColumn_path_or_parent();
       if (this_present_column_path_or_parent || that_present_column_path_or_parent) {
         if (!(this_present_column_path_or_parent && that_present_column_path_or_parent))
           return false;
         if (!this.column_path_or_parent.equals(that.column_path_or_parent))
           return false;
       }
 
       boolean this_present_timestamp = true;
       boolean that_present_timestamp = true;
       if (this_present_timestamp || that_present_timestamp) {
         if (!(this_present_timestamp && that_present_timestamp))
           return false;
         if (this.timestamp != that.timestamp)
           return false;
       }
 
       boolean this_present_block_for = true;
       boolean that_present_block_for = true;
       if (this_present_block_for || that_present_block_for) {
         if (!(this_present_block_for && that_present_block_for))
           return false;
         if (this.block_for != that.block_for)
           return false;
       }
 
       return true;
     }
 
     @Override
     public int hashCode() {
       return 0;
     }
 
     public void read(TProtocol iprot) throws TException {
       TField field;
       iprot.readStructBegin();
       while (true)
       {
         field = iprot.readFieldBegin();
         if (field.type == TType.STOP) { 
           break;
         }
         switch (field.id)
         {
           case TABLE:
             if (field.type == TType.STRING) {
               this.table = iprot.readString();
             } else { 
               TProtocolUtil.skip(iprot, field.type);
             }
             break;
           case KEY:
             if (field.type == TType.STRING) {
               this.key = iprot.readString();
             } else { 
               TProtocolUtil.skip(iprot, field.type);
             }
             break;
           case COLUMN_PATH_OR_PARENT:
             if (field.type == TType.STRUCT) {
               this.column_path_or_parent = new ColumnPathOrParent();
               this.column_path_or_parent.read(iprot);
             } else { 
               TProtocolUtil.skip(iprot, field.type);
             }
             break;
           case TIMESTAMP:
             if (field.type == TType.I64) {
               this.timestamp = iprot.readI64();
               this.__isset.timestamp = true;
             } else { 
               TProtocolUtil.skip(iprot, field.type);
             }
             break;
           case BLOCK_FOR:
             if (field.type == TType.I32) {
               this.block_for = iprot.readI32();
               this.__isset.block_for = true;
             } else { 
               TProtocolUtil.skip(iprot, field.type);
             }
             break;
           default:
             TProtocolUtil.skip(iprot, field.type);
             break;
         }
         iprot.readFieldEnd();
       }
       iprot.readStructEnd();
 
 
       // check for required fields of primitive type, which can't be checked in the validate method
       validate();
     }
 
     public void write(TProtocol oprot) throws TException {
       validate();
 
       oprot.writeStructBegin(STRUCT_DESC);
       if (this.table != null) {
         oprot.writeFieldBegin(TABLE_FIELD_DESC);
         oprot.writeString(this.table);
         oprot.writeFieldEnd();
       }
       if (this.key != null) {
         oprot.writeFieldBegin(KEY_FIELD_DESC);
         oprot.writeString(this.key);
         oprot.writeFieldEnd();
       }
       if (this.column_path_or_parent != null) {
         oprot.writeFieldBegin(COLUMN_PATH_OR_PARENT_FIELD_DESC);
         this.column_path_or_parent.write(oprot);
         oprot.writeFieldEnd();
       }
       oprot.writeFieldBegin(TIMESTAMP_FIELD_DESC);
       oprot.writeI64(this.timestamp);
       oprot.writeFieldEnd();
       oprot.writeFieldBegin(BLOCK_FOR_FIELD_DESC);
       oprot.writeI32(this.block_for);
       oprot.writeFieldEnd();
       oprot.writeFieldStop();
       oprot.writeStructEnd();
     }
 
     @Override
     public String toString() {
       StringBuilder sb = new StringBuilder("remove_args(");
       boolean first = true;
 
       sb.append("table:");
       if (this.table == null) {
         sb.append("null");
       } else {
         sb.append(this.table);
       }
       first = false;
       if (!first) sb.append(", ");
       sb.append("key:");
       if (this.key == null) {
         sb.append("null");
       } else {
         sb.append(this.key);
       }
       first = false;
       if (!first) sb.append(", ");
       sb.append("column_path_or_parent:");
       if (this.column_path_or_parent == null) {
         sb.append("null");
       } else {
         sb.append(this.column_path_or_parent);
       }
       first = false;
       if (!first) sb.append(", ");
       sb.append("timestamp:");
       sb.append(this.timestamp);
       first = false;
       if (!first) sb.append(", ");
       sb.append("block_for:");
       sb.append(this.block_for);
       first = false;
       sb.append(")");
       return sb.toString();
     }
 
     public void validate() throws TException {
       // check for required fields
       // check that fields of type enum have valid values
     }
 
   }
 
   public static class remove_result implements TBase, java.io.Serializable, Cloneable   {
     private static final TStruct STRUCT_DESC = new TStruct("remove_result");
     private static final TField IRE_FIELD_DESC = new TField("ire", TType.STRUCT, (short)1);
     private static final TField UE_FIELD_DESC = new TField("ue", TType.STRUCT, (short)2);
 
     public InvalidRequestException ire;
     public static final int IRE = 1;
     public UnavailableException ue;
     public static final int UE = 2;
 
     private final Isset __isset = new Isset();
     private static final class Isset implements java.io.Serializable {
     }
 
     public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
       put(IRE, new FieldMetaData("ire", TFieldRequirementType.DEFAULT, 
           new FieldValueMetaData(TType.STRUCT)));
       put(UE, new FieldMetaData("ue", TFieldRequirementType.DEFAULT, 
           new FieldValueMetaData(TType.STRUCT)));
     }});
 
     static {
       FieldMetaData.addStructMetaDataMap(remove_result.class, metaDataMap);
     }
 
     public remove_result() {
     }
 
     public remove_result(
       InvalidRequestException ire,
       UnavailableException ue)
     {
       this();
       this.ire = ire;
       this.ue = ue;
     }
 
     /**
      * Performs a deep copy on <i>other</i>.
      */
     public remove_result(remove_result other) {
       if (other.isSetIre()) {
         this.ire = new InvalidRequestException(other.ire);
       }
       if (other.isSetUe()) {
         this.ue = new UnavailableException(other.ue);
       }
     }
 
     @Override
     public remove_result clone() {
       return new remove_result(this);
     }
 
     public InvalidRequestException getIre() {
       return this.ire;
     }
 
     public void setIre(InvalidRequestException ire) {
       this.ire = ire;
     }
 
     public void unsetIre() {
       this.ire = null;
     }
 
     // Returns true if field ire is set (has been asigned a value) and false otherwise
     public boolean isSetIre() {
       return this.ire != null;
     }
 
     public void setIreIsSet(boolean value) {
       if (!value) {
         this.ire = null;
       }
     }
 
     public UnavailableException getUe() {
       return this.ue;
     }
 
     public void setUe(UnavailableException ue) {
       this.ue = ue;
     }
 
     public void unsetUe() {
       this.ue = null;
     }
 
     // Returns true if field ue is set (has been asigned a value) and false otherwise
     public boolean isSetUe() {
       return this.ue != null;
     }
 
     public void setUeIsSet(boolean value) {
       if (!value) {
         this.ue = null;
       }
     }
 
     public void setFieldValue(int fieldID, Object value) {
       switch (fieldID) {
       case IRE:
         if (value == null) {
           unsetIre();
         } else {
           setIre((InvalidRequestException)value);
         }
         break;
 
       case UE:
         if (value == null) {
           unsetUe();
         } else {
           setUe((UnavailableException)value);
         }
         break;
 
       default:
         throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
       }
     }
 
     public Object getFieldValue(int fieldID) {
       switch (fieldID) {
       case IRE:
         return getIre();
 
       case UE:
         return getUe();
 
       default:
         throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
       }
     }
 
     // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
     public boolean isSet(int fieldID) {
       switch (fieldID) {
       case IRE:
         return isSetIre();
       case UE:
         return isSetUe();
       default:
         throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
       }
     }
 
     @Override
     public boolean equals(Object that) {
       if (that == null)
         return false;
       if (that instanceof remove_result)
         return this.equals((remove_result)that);
       return false;
     }
 
     public boolean equals(remove_result that) {
       if (that == null)
         return false;
 
       boolean this_present_ire = true && this.isSetIre();
       boolean that_present_ire = true && that.isSetIre();
       if (this_present_ire || that_present_ire) {
         if (!(this_present_ire && that_present_ire))
           return false;
         if (!this.ire.equals(that.ire))
           return false;
       }
 
       boolean this_present_ue = true && this.isSetUe();
       boolean that_present_ue = true && that.isSetUe();
       if (this_present_ue || that_present_ue) {
         if (!(this_present_ue && that_present_ue))
           return false;
         if (!this.ue.equals(that.ue))
           return false;
       }
 
       return true;
     }
 
     @Override
     public int hashCode() {
       return 0;
     }
 
     public void read(TProtocol iprot) throws TException {
       TField field;
       iprot.readStructBegin();
       while (true)
       {
         field = iprot.readFieldBegin();
         if (field.type == TType.STOP) { 
           break;
         }
         switch (field.id)
         {
           case IRE:
             if (field.type == TType.STRUCT) {
               this.ire = new InvalidRequestException();
               this.ire.read(iprot);
             } else { 
               TProtocolUtil.skip(iprot, field.type);
             }
             break;
           case UE:
             if (field.type == TType.STRUCT) {
               this.ue = new UnavailableException();
               this.ue.read(iprot);
             } else { 
               TProtocolUtil.skip(iprot, field.type);
             }
             break;
           default:
             TProtocolUtil.skip(iprot, field.type);
             break;
         }
         iprot.readFieldEnd();
       }
       iprot.readStructEnd();
 
 
       // check for required fields of primitive type, which can't be checked in the validate method
       validate();
     }
 
     public void write(TProtocol oprot) throws TException {
       oprot.writeStructBegin(STRUCT_DESC);
 
       if (this.isSetIre()) {
         oprot.writeFieldBegin(IRE_FIELD_DESC);
         this.ire.write(oprot);
         oprot.writeFieldEnd();
       } else if (this.isSetUe()) {
         oprot.writeFieldBegin(UE_FIELD_DESC);
         this.ue.write(oprot);
         oprot.writeFieldEnd();
       }
       oprot.writeFieldStop();
       oprot.writeStructEnd();
     }
 
     @Override
     public String toString() {
       StringBuilder sb = new StringBuilder("remove_result(");
       boolean first = true;
 
       sb.append("ire:");
       if (this.ire == null) {
         sb.append("null");
       } else {
         sb.append(this.ire);
       }
       first = false;
       if (!first) sb.append(", ");
       sb.append("ue:");
       if (this.ue == null) {
         sb.append("null");
       } else {
         sb.append(this.ue);
       }
       first = false;
       sb.append(")");
       return sb.toString();
     }
 
     public void validate() throws TException {
       // check for required fields
       // check that fields of type enum have valid values
     }
 
   }
 
   public static class get_slice_super_args implements TBase, java.io.Serializable, Cloneable   {
     private static final TStruct STRUCT_DESC = new TStruct("get_slice_super_args");
     private static final TField TABLE_FIELD_DESC = new TField("table", TType.STRING, (short)1);
     private static final TField KEY_FIELD_DESC = new TField("key", TType.STRING, (short)2);
     private static final TField COLUMN_FAMILY_FIELD_DESC = new TField("column_family", TType.STRING, (short)3);
     private static final TField START_FIELD_DESC = new TField("start", TType.STRING, (short)4);
     private static final TField FINISH_FIELD_DESC = new TField("finish", TType.STRING, (short)5);
     private static final TField IS_ASCENDING_FIELD_DESC = new TField("is_ascending", TType.BOOL, (short)6);
     private static final TField COUNT_FIELD_DESC = new TField("count", TType.I32, (short)7);
 
     public String table;
     public static final int TABLE = 1;
     public String key;
     public static final int KEY = 2;
     public String column_family;
     public static final int COLUMN_FAMILY = 3;
     public byte[] start;
     public static final int START = 4;
     public byte[] finish;
     public static final int FINISH = 5;
     public boolean is_ascending;
     public static final int IS_ASCENDING = 6;
     public int count;
     public static final int COUNT = 7;
 
     private final Isset __isset = new Isset();
     private static final class Isset implements java.io.Serializable {
       public boolean is_ascending = false;
       public boolean count = false;
     }
 
     public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
       put(TABLE, new FieldMetaData("table", TFieldRequirementType.DEFAULT, 
           new FieldValueMetaData(TType.STRING)));
       put(KEY, new FieldMetaData("key", TFieldRequirementType.DEFAULT, 
           new FieldValueMetaData(TType.STRING)));
       put(COLUMN_FAMILY, new FieldMetaData("column_family", TFieldRequirementType.DEFAULT, 
           new FieldValueMetaData(TType.STRING)));
       put(START, new FieldMetaData("start", TFieldRequirementType.DEFAULT, 
           new FieldValueMetaData(TType.STRING)));
       put(FINISH, new FieldMetaData("finish", TFieldRequirementType.DEFAULT, 
           new FieldValueMetaData(TType.STRING)));
       put(IS_ASCENDING, new FieldMetaData("is_ascending", TFieldRequirementType.DEFAULT, 
           new FieldValueMetaData(TType.BOOL)));
       put(COUNT, new FieldMetaData("count", TFieldRequirementType.DEFAULT, 
           new FieldValueMetaData(TType.I32)));
     }});
 
     static {
       FieldMetaData.addStructMetaDataMap(get_slice_super_args.class, metaDataMap);
     }
 
     public get_slice_super_args() {
       this.count = 100;
 
     }
 
     public get_slice_super_args(
       String table,
       String key,
       String column_family,
       byte[] start,
       byte[] finish,
       boolean is_ascending,
       int count)
     {
       this();
       this.table = table;
       this.key = key;
       this.column_family = column_family;
       this.start = start;
       this.finish = finish;
       this.is_ascending = is_ascending;
       this.__isset.is_ascending = true;
       this.count = count;
       this.__isset.count = true;
     }
 
     /**
      * Performs a deep copy on <i>other</i>.
      */
     public get_slice_super_args(get_slice_super_args other) {
       if (other.isSetTable()) {
         this.table = other.table;
       }
       if (other.isSetKey()) {
         this.key = other.key;
       }
       if (other.isSetColumn_family()) {
         this.column_family = other.column_family;
       }
       if (other.isSetStart()) {
         this.start = new byte[other.start.length];
         System.arraycopy(other.start, 0, start, 0, other.start.length);
       }
       if (other.isSetFinish()) {
         this.finish = new byte[other.finish.length];
         System.arraycopy(other.finish, 0, finish, 0, other.finish.length);
       }
       __isset.is_ascending = other.__isset.is_ascending;
       this.is_ascending = other.is_ascending;
       __isset.count = other.__isset.count;
       this.count = other.count;
     }
 
     @Override
     public get_slice_super_args clone() {
       return new get_slice_super_args(this);
     }
 
     public String getTable() {
       return this.table;
     }
 
     public void setTable(String table) {
       this.table = table;
     }
 
     public void unsetTable() {
       this.table = null;
     }
 
     // Returns true if field table is set (has been asigned a value) and false otherwise
     public boolean isSetTable() {
       return this.table != null;
     }
 
     public void setTableIsSet(boolean value) {
       if (!value) {
         this.table = null;
       }
     }
 
     public String getKey() {
       return this.key;
     }
 
     public void setKey(String key) {
       this.key = key;
     }
 
     public void unsetKey() {
       this.key = null;
     }
 
     // Returns true if field key is set (has been asigned a value) and false otherwise
     public boolean isSetKey() {
       return this.key != null;
     }
 
     public void setKeyIsSet(boolean value) {
       if (!value) {
         this.key = null;
       }
     }
 
     public String getColumn_family() {
       return this.column_family;
     }
 
     public void setColumn_family(String column_family) {
       this.column_family = column_family;
     }
 
     public void unsetColumn_family() {
       this.column_family = null;
     }
 
     // Returns true if field column_family is set (has been asigned a value) and false otherwise
     public boolean isSetColumn_family() {
       return this.column_family != null;
     }
 
     public void setColumn_familyIsSet(boolean value) {
       if (!value) {
         this.column_family = null;
       }
     }
 
     public byte[] getStart() {
       return this.start;
     }
 
     public void setStart(byte[] start) {
       this.start = start;
     }
 
     public void unsetStart() {
       this.start = null;
     }
 
     // Returns true if field start is set (has been asigned a value) and false otherwise
     public boolean isSetStart() {
       return this.start != null;
     }
 
     public void setStartIsSet(boolean value) {
       if (!value) {
         this.start = null;
       }
     }
 
     public byte[] getFinish() {
       return this.finish;
     }
 
     public void setFinish(byte[] finish) {
       this.finish = finish;
     }
 
     public void unsetFinish() {
       this.finish = null;
     }
 
     // Returns true if field finish is set (has been asigned a value) and false otherwise
     public boolean isSetFinish() {
       return this.finish != null;
     }
 
     public void setFinishIsSet(boolean value) {
       if (!value) {
         this.finish = null;
       }
     }
 
     public boolean isIs_ascending() {
       return this.is_ascending;
     }
 
     public void setIs_ascending(boolean is_ascending) {
       this.is_ascending = is_ascending;
       this.__isset.is_ascending = true;
     }
 
     public void unsetIs_ascending() {
       this.__isset.is_ascending = false;
     }
 
     // Returns true if field is_ascending is set (has been asigned a value) and false otherwise
     public boolean isSetIs_ascending() {
       return this.__isset.is_ascending;
     }
 
     public void setIs_ascendingIsSet(boolean value) {
       this.__isset.is_ascending = value;
     }
 
     public int getCount() {
       return this.count;
     }
 
     public void setCount(int count) {
       this.count = count;
       this.__isset.count = true;
     }
 
     public void unsetCount() {
       this.__isset.count = false;
     }
 
     // Returns true if field count is set (has been asigned a value) and false otherwise
     public boolean isSetCount() {
       return this.__isset.count;
     }
 
     public void setCountIsSet(boolean value) {
       this.__isset.count = value;
     }
 
     public void setFieldValue(int fieldID, Object value) {
       switch (fieldID) {
       case TABLE:
         if (value == null) {
           unsetTable();
         } else {
           setTable((String)value);
         }
         break;
 
       case KEY:
         if (value == null) {
           unsetKey();
         } else {
           setKey((String)value);
         }
         break;
 
       case COLUMN_FAMILY:
         if (value == null) {
           unsetColumn_family();
         } else {
           setColumn_family((String)value);
         }
         break;
 
       case START:
         if (value == null) {
           unsetStart();
         } else {
           setStart((byte[])value);
         }
         break;
 
       case FINISH:
         if (value == null) {
           unsetFinish();
         } else {
           setFinish((byte[])value);
         }
         break;
 
       case IS_ASCENDING:
         if (value == null) {
           unsetIs_ascending();
         } else {
           setIs_ascending((Boolean)value);
         }
         break;
 
       case COUNT:
         if (value == null) {
           unsetCount();
         } else {
           setCount((Integer)value);
         }
         break;
 
       default:
         throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
       }
     }
 
     public Object getFieldValue(int fieldID) {
       switch (fieldID) {
       case TABLE:
         return getTable();
 
       case KEY:
         return getKey();
 
       case COLUMN_FAMILY:
         return getColumn_family();
 
       case START:
         return getStart();
 
       case FINISH:
         return getFinish();
 
       case IS_ASCENDING:
         return new Boolean(isIs_ascending());
 
       case COUNT:
         return new Integer(getCount());
 
       default:
         throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
       }
     }
 
     // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
     public boolean isSet(int fieldID) {
       switch (fieldID) {
       case TABLE:
         return isSetTable();
       case KEY:
         return isSetKey();
       case COLUMN_FAMILY:
         return isSetColumn_family();
       case START:
         return isSetStart();
       case FINISH:
         return isSetFinish();
       case IS_ASCENDING:
         return isSetIs_ascending();
       case COUNT:
         return isSetCount();
       default:
         throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
       }
     }
 
     @Override
     public boolean equals(Object that) {
       if (that == null)
         return false;
       if (that instanceof get_slice_super_args)
         return this.equals((get_slice_super_args)that);
       return false;
     }
 
     public boolean equals(get_slice_super_args that) {
       if (that == null)
         return false;
 
       boolean this_present_table = true && this.isSetTable();
       boolean that_present_table = true && that.isSetTable();
       if (this_present_table || that_present_table) {
         if (!(this_present_table && that_present_table))
           return false;
         if (!this.table.equals(that.table))
           return false;
       }
 
       boolean this_present_key = true && this.isSetKey();
       boolean that_present_key = true && that.isSetKey();
       if (this_present_key || that_present_key) {
         if (!(this_present_key && that_present_key))
           return false;
         if (!this.key.equals(that.key))
           return false;
       }
 
       boolean this_present_column_family = true && this.isSetColumn_family();
       boolean that_present_column_family = true && that.isSetColumn_family();
       if (this_present_column_family || that_present_column_family) {
         if (!(this_present_column_family && that_present_column_family))
           return false;
         if (!this.column_family.equals(that.column_family))
           return false;
       }
 
       boolean this_present_start = true && this.isSetStart();
       boolean that_present_start = true && that.isSetStart();
       if (this_present_start || that_present_start) {
         if (!(this_present_start && that_present_start))
           return false;
         if (!java.util.Arrays.equals(this.start, that.start))
           return false;
       }
 
       boolean this_present_finish = true && this.isSetFinish();
       boolean that_present_finish = true && that.isSetFinish();
       if (this_present_finish || that_present_finish) {
         if (!(this_present_finish && that_present_finish))
           return false;
         if (!java.util.Arrays.equals(this.finish, that.finish))
           return false;
       }
 
       boolean this_present_is_ascending = true;
       boolean that_present_is_ascending = true;
       if (this_present_is_ascending || that_present_is_ascending) {
         if (!(this_present_is_ascending && that_present_is_ascending))
           return false;
         if (this.is_ascending != that.is_ascending)
           return false;
       }
 
       boolean this_present_count = true;
       boolean that_present_count = true;
       if (this_present_count || that_present_count) {
         if (!(this_present_count && that_present_count))
           return false;
         if (this.count != that.count)
           return false;
       }
 
       return true;
     }
 
     @Override
     public int hashCode() {
       return 0;
     }
 
     public void read(TProtocol iprot) throws TException {
       TField field;
       iprot.readStructBegin();
       while (true)
       {
         field = iprot.readFieldBegin();
         if (field.type == TType.STOP) { 
           break;
         }
         switch (field.id)
         {
           case TABLE:
             if (field.type == TType.STRING) {
               this.table = iprot.readString();
             } else { 
               TProtocolUtil.skip(iprot, field.type);
             }
             break;
           case KEY:
             if (field.type == TType.STRING) {
               this.key = iprot.readString();
             } else { 
               TProtocolUtil.skip(iprot, field.type);
             }
             break;
           case COLUMN_FAMILY:
             if (field.type == TType.STRING) {
               this.column_family = iprot.readString();
             } else { 
               TProtocolUtil.skip(iprot, field.type);
             }
             break;
           case START:
             if (field.type == TType.STRING) {
               this.start = iprot.readBinary();
             } else { 
               TProtocolUtil.skip(iprot, field.type);
             }
             break;
           case FINISH:
             if (field.type == TType.STRING) {
               this.finish = iprot.readBinary();
             } else { 
               TProtocolUtil.skip(iprot, field.type);
             }
             break;
           case IS_ASCENDING:
             if (field.type == TType.BOOL) {
               this.is_ascending = iprot.readBool();
               this.__isset.is_ascending = true;
             } else { 
               TProtocolUtil.skip(iprot, field.type);
             }
             break;
           case COUNT:
             if (field.type == TType.I32) {
               this.count = iprot.readI32();
               this.__isset.count = true;
             } else { 
               TProtocolUtil.skip(iprot, field.type);
             }
             break;
           default:
             TProtocolUtil.skip(iprot, field.type);
             break;
         }
         iprot.readFieldEnd();
       }
       iprot.readStructEnd();
 
 
       // check for required fields of primitive type, which can't be checked in the validate method
       validate();
     }
 
     public void write(TProtocol oprot) throws TException {
       validate();
 
       oprot.writeStructBegin(STRUCT_DESC);
       if (this.table != null) {
         oprot.writeFieldBegin(TABLE_FIELD_DESC);
         oprot.writeString(this.table);
         oprot.writeFieldEnd();
       }
       if (this.key != null) {
         oprot.writeFieldBegin(KEY_FIELD_DESC);
         oprot.writeString(this.key);
         oprot.writeFieldEnd();
       }
       if (this.column_family != null) {
         oprot.writeFieldBegin(COLUMN_FAMILY_FIELD_DESC);
         oprot.writeString(this.column_family);
         oprot.writeFieldEnd();
       }
       if (this.start != null) {
         oprot.writeFieldBegin(START_FIELD_DESC);
         oprot.writeBinary(this.start);
         oprot.writeFieldEnd();
       }
       if (this.finish != null) {
         oprot.writeFieldBegin(FINISH_FIELD_DESC);
         oprot.writeBinary(this.finish);
         oprot.writeFieldEnd();
       }
       oprot.writeFieldBegin(IS_ASCENDING_FIELD_DESC);
       oprot.writeBool(this.is_ascending);
       oprot.writeFieldEnd();
       oprot.writeFieldBegin(COUNT_FIELD_DESC);
       oprot.writeI32(this.count);
       oprot.writeFieldEnd();
       oprot.writeFieldStop();
       oprot.writeStructEnd();
     }
 
     @Override
     public String toString() {
       StringBuilder sb = new StringBuilder("get_slice_super_args(");
       boolean first = true;
 
       sb.append("table:");
       if (this.table == null) {
         sb.append("null");
       } else {
         sb.append(this.table);
       }
       first = false;
       if (!first) sb.append(", ");
       sb.append("key:");
       if (this.key == null) {
         sb.append("null");
       } else {
         sb.append(this.key);
       }
       first = false;
       if (!first) sb.append(", ");
       sb.append("column_family:");
       if (this.column_family == null) {
         sb.append("null");
       } else {
         sb.append(this.column_family);
       }
       first = false;
       if (!first) sb.append(", ");
       sb.append("start:");
       if (this.start == null) {
         sb.append("null");
       } else {
           int __start_size = Math.min(this.start.length, 128);
           for (int i = 0; i < __start_size; i++) {
             if (i != 0) sb.append(" ");
             sb.append(Integer.toHexString(this.start[i]).length() > 1 ? Integer.toHexString(this.start[i]).substring(Integer.toHexString(this.start[i]).length() - 2).toUpperCase() : "0" + Integer.toHexString(this.start[i]).toUpperCase());
           }
           if (this.start.length > 128) sb.append(" ...");
       }
       first = false;
       if (!first) sb.append(", ");
       sb.append("finish:");
       if (this.finish == null) {
         sb.append("null");
       } else {
           int __finish_size = Math.min(this.finish.length, 128);
           for (int i = 0; i < __finish_size; i++) {
             if (i != 0) sb.append(" ");
             sb.append(Integer.toHexString(this.finish[i]).length() > 1 ? Integer.toHexString(this.finish[i]).substring(Integer.toHexString(this.finish[i]).length() - 2).toUpperCase() : "0" + Integer.toHexString(this.finish[i]).toUpperCase());
           }
           if (this.finish.length > 128) sb.append(" ...");
       }
       first = false;
       if (!first) sb.append(", ");
       sb.append("is_ascending:");
       sb.append(this.is_ascending);
       first = false;
       if (!first) sb.append(", ");
       sb.append("count:");
       sb.append(this.count);
       first = false;
       sb.append(")");
       return sb.toString();
     }
 
     public void validate() throws TException {
       // check for required fields
       // check that fields of type enum have valid values
     }
 
   }
 
   public static class get_slice_super_result implements TBase, java.io.Serializable, Cloneable   {
     private static final TStruct STRUCT_DESC = new TStruct("get_slice_super_result");
     private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.LIST, (short)0);
     private static final TField IRE_FIELD_DESC = new TField("ire", TType.STRUCT, (short)1);
 
     public List<SuperColumn> success;
     public static final int SUCCESS = 0;
     public InvalidRequestException ire;
     public static final int IRE = 1;
 
     private final Isset __isset = new Isset();
     private static final class Isset implements java.io.Serializable {
     }
 
     public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
       put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
           new ListMetaData(TType.LIST, 
               new StructMetaData(TType.STRUCT, SuperColumn.class))));
       put(IRE, new FieldMetaData("ire", TFieldRequirementType.DEFAULT, 
           new FieldValueMetaData(TType.STRUCT)));
     }});
 
     static {
       FieldMetaData.addStructMetaDataMap(get_slice_super_result.class, metaDataMap);
     }
 
     public get_slice_super_result() {
     }
 
     public get_slice_super_result(
       List<SuperColumn> success,
       InvalidRequestException ire)
     {
       this();
       this.success = success;
       this.ire = ire;
     }
 
     /**
      * Performs a deep copy on <i>other</i>.
      */
     public get_slice_super_result(get_slice_super_result other) {
       if (other.isSetSuccess()) {
         List<SuperColumn> __this__success = new ArrayList<SuperColumn>();
         for (SuperColumn other_element : other.success) {
           __this__success.add(new SuperColumn(other_element));
         }
         this.success = __this__success;
       }
       if (other.isSetIre()) {
         this.ire = new InvalidRequestException(other.ire);
       }
     }
 
     @Override
     public get_slice_super_result clone() {
       return new get_slice_super_result(this);
     }
 
     public int getSuccessSize() {
       return (this.success == null) ? 0 : this.success.size();
     }
 
     public java.util.Iterator<SuperColumn> getSuccessIterator() {
       return (this.success == null) ? null : this.success.iterator();
     }
 
     public void addToSuccess(SuperColumn elem) {
       if (this.success == null) {
         this.success = new ArrayList<SuperColumn>();
       }
       this.success.add(elem);
     }
 
     public List<SuperColumn> getSuccess() {
       return this.success;
     }
 
     public void setSuccess(List<SuperColumn> success) {
       this.success = success;
     }
 
     public void unsetSuccess() {
       this.success = null;
     }
 
     // Returns true if field success is set (has been asigned a value) and false otherwise
     public boolean isSetSuccess() {
       return this.success != null;
     }
 
     public void setSuccessIsSet(boolean value) {
       if (!value) {
         this.success = null;
       }
     }
 
     public InvalidRequestException getIre() {
       return this.ire;
     }
 
     public void setIre(InvalidRequestException ire) {
       this.ire = ire;
     }
 
     public void unsetIre() {
       this.ire = null;
     }
 
     // Returns true if field ire is set (has been asigned a value) and false otherwise
     public boolean isSetIre() {
       return this.ire != null;
     }
 
     public void setIreIsSet(boolean value) {
       if (!value) {
         this.ire = null;
       }
     }
 
     public void setFieldValue(int fieldID, Object value) {
       switch (fieldID) {
       case SUCCESS:
         if (value == null) {
           unsetSuccess();
         } else {
           setSuccess((List<SuperColumn>)value);
         }
         break;
 
       case IRE:
         if (value == null) {
           unsetIre();
         } else {
           setIre((InvalidRequestException)value);
         }
         break;
 
       default:
         throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
       }
     }
 
     public Object getFieldValue(int fieldID) {
       switch (fieldID) {
       case SUCCESS:
         return getSuccess();
 
       case IRE:
         return getIre();
 
       default:
         throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
       }
     }
 
     // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
     public boolean isSet(int fieldID) {
       switch (fieldID) {
       case SUCCESS:
         return isSetSuccess();
       case IRE:
         return isSetIre();
       default:
         throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
       }
     }
 
     @Override
     public boolean equals(Object that) {
       if (that == null)
         return false;
       if (that instanceof get_slice_super_result)
         return this.equals((get_slice_super_result)that);
       return false;
     }
 
     public boolean equals(get_slice_super_result that) {
       if (that == null)
         return false;
 
       boolean this_present_success = true && this.isSetSuccess();
       boolean that_present_success = true && that.isSetSuccess();
       if (this_present_success || that_present_success) {
         if (!(this_present_success && that_present_success))
           return false;
         if (!this.success.equals(that.success))
           return false;
       }
 
       boolean this_present_ire = true && this.isSetIre();
       boolean that_present_ire = true && that.isSetIre();
       if (this_present_ire || that_present_ire) {
         if (!(this_present_ire && that_present_ire))
           return false;
         if (!this.ire.equals(that.ire))
           return false;
       }
 
       return true;
     }
 
     @Override
     public int hashCode() {
       return 0;
     }
 
     public void read(TProtocol iprot) throws TException {
       TField field;
       iprot.readStructBegin();
       while (true)
       {
         field = iprot.readFieldBegin();
         if (field.type == TType.STOP) { 
           break;
         }
         switch (field.id)
         {
           case SUCCESS:
             if (field.type == TType.LIST) {
               {
                 TList _list43 = iprot.readListBegin();
                 this.success = new ArrayList<SuperColumn>(_list43.size);
                 for (int _i44 = 0; _i44 < _list43.size; ++_i44)
                 {
                   SuperColumn _elem45;
                   _elem45 = new SuperColumn();
                   _elem45.read(iprot);
                   this.success.add(_elem45);
                 }
                 iprot.readListEnd();
               }
             } else { 
               TProtocolUtil.skip(iprot, field.type);
             }
             break;
           case IRE:
             if (field.type == TType.STRUCT) {
               this.ire = new InvalidRequestException();
               this.ire.read(iprot);
             } else { 
               TProtocolUtil.skip(iprot, field.type);
             }
             break;
           default:
             TProtocolUtil.skip(iprot, field.type);
             break;
         }
         iprot.readFieldEnd();
       }
       iprot.readStructEnd();
 
 
       // check for required fields of primitive type, which can't be checked in the validate method
       validate();
     }
 
     public void write(TProtocol oprot) throws TException {
       oprot.writeStructBegin(STRUCT_DESC);
 
       if (this.isSetSuccess()) {
         oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
         {
           oprot.writeListBegin(new TList(TType.STRUCT, this.success.size()));
           for (SuperColumn _iter46 : this.success)          {
             _iter46.write(oprot);
           }
           oprot.writeListEnd();
         }
         oprot.writeFieldEnd();
       } else if (this.isSetIre()) {
         oprot.writeFieldBegin(IRE_FIELD_DESC);
         this.ire.write(oprot);
         oprot.writeFieldEnd();
       }
       oprot.writeFieldStop();
       oprot.writeStructEnd();
     }
 
     @Override
     public String toString() {
       StringBuilder sb = new StringBuilder("get_slice_super_result(");
       boolean first = true;
 
       sb.append("success:");
       if (this.success == null) {
         sb.append("null");
       } else {
         sb.append(this.success);
       }
       first = false;
       if (!first) sb.append(", ");
       sb.append("ire:");
       if (this.ire == null) {
         sb.append("null");
       } else {
         sb.append(this.ire);
       }
       first = false;
       sb.append(")");
       return sb.toString();
     }
 
     public void validate() throws TException {
       // check for required fields
       // check that fields of type enum have valid values
     }
 
   }
 
   public static class get_slice_super_by_names_args implements TBase, java.io.Serializable, Cloneable   {
     private static final TStruct STRUCT_DESC = new TStruct("get_slice_super_by_names_args");
     private static final TField TABLE_FIELD_DESC = new TField("table", TType.STRING, (short)1);
     private static final TField KEY_FIELD_DESC = new TField("key", TType.STRING, (short)2);
     private static final TField COLUMN_FAMILY_FIELD_DESC = new TField("column_family", TType.STRING, (short)3);
     private static final TField SUPER_COLUMN_NAMES_FIELD_DESC = new TField("super_column_names", TType.LIST, (short)4);
 
     public String table;
     public static final int TABLE = 1;
     public String key;
     public static final int KEY = 2;
     public String column_family;
     public static final int COLUMN_FAMILY = 3;
     public List<byte[]> super_column_names;
     public static final int SUPER_COLUMN_NAMES = 4;
 
     private final Isset __isset = new Isset();
     private static final class Isset implements java.io.Serializable {
     }
 
     public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
       put(TABLE, new FieldMetaData("table", TFieldRequirementType.DEFAULT, 
           new FieldValueMetaData(TType.STRING)));
       put(KEY, new FieldMetaData("key", TFieldRequirementType.DEFAULT, 
           new FieldValueMetaData(TType.STRING)));
       put(COLUMN_FAMILY, new FieldMetaData("column_family", TFieldRequirementType.DEFAULT, 
           new FieldValueMetaData(TType.STRING)));
       put(SUPER_COLUMN_NAMES, new FieldMetaData("super_column_names", TFieldRequirementType.DEFAULT, 
           new ListMetaData(TType.LIST, 
               new FieldValueMetaData(TType.STRING))));
     }});
 
     static {
       FieldMetaData.addStructMetaDataMap(get_slice_super_by_names_args.class, metaDataMap);
     }
 
     public get_slice_super_by_names_args() {
     }
 
     public get_slice_super_by_names_args(
       String table,
       String key,
       String column_family,
       List<byte[]> super_column_names)
     {
       this();
       this.table = table;
       this.key = key;
       this.column_family = column_family;
       this.super_column_names = super_column_names;
     }
 
     /**
      * Performs a deep copy on <i>other</i>.
      */
     public get_slice_super_by_names_args(get_slice_super_by_names_args other) {
       if (other.isSetTable()) {
         this.table = other.table;
       }
       if (other.isSetKey()) {
         this.key = other.key;
       }
       if (other.isSetColumn_family()) {
         this.column_family = other.column_family;
       }
       if (other.isSetSuper_column_names()) {
         List<byte[]> __this__super_column_names = new ArrayList<byte[]>();
         for (byte[] other_element : other.super_column_names) {
           byte[] temp_binary_element = new byte[other_element.length];
           System.arraycopy(other_element, 0, temp_binary_element, 0, other_element.length);
           __this__super_column_names.add(temp_binary_element);
         }
         this.super_column_names = __this__super_column_names;
       }
     }
 
     @Override
     public get_slice_super_by_names_args clone() {
       return new get_slice_super_by_names_args(this);
     }
 
     public String getTable() {
       return this.table;
     }
 
     public void setTable(String table) {
       this.table = table;
     }
 
     public void unsetTable() {
       this.table = null;
     }
 
     // Returns true if field table is set (has been asigned a value) and false otherwise
     public boolean isSetTable() {
       return this.table != null;
     }
 
     public void setTableIsSet(boolean value) {
       if (!value) {
         this.table = null;
       }
     }
 
     public String getKey() {
       return this.key;
     }
 
     public void setKey(String key) {
       this.key = key;
     }
 
     public void unsetKey() {
       this.key = null;
     }
 
     // Returns true if field key is set (has been asigned a value) and false otherwise
     public boolean isSetKey() {
       return this.key != null;
     }
 
     public void setKeyIsSet(boolean value) {
       if (!value) {
         this.key = null;
       }
     }
 
     public String getColumn_family() {
       return this.column_family;
     }
 
     public void setColumn_family(String column_family) {
       this.column_family = column_family;
     }
 
     public void unsetColumn_family() {
       this.column_family = null;
     }
 
     // Returns true if field column_family is set (has been asigned a value) and false otherwise
     public boolean isSetColumn_family() {
       return this.column_family != null;
     }
 
     public void setColumn_familyIsSet(boolean value) {
       if (!value) {
         this.column_family = null;
       }
     }
 
     public int getSuper_column_namesSize() {
       return (this.super_column_names == null) ? 0 : this.super_column_names.size();
     }
 
     public java.util.Iterator<byte[]> getSuper_column_namesIterator() {
       return (this.super_column_names == null) ? null : this.super_column_names.iterator();
     }
 
     public void addToSuper_column_names(byte[] elem) {
       if (this.super_column_names == null) {
         this.super_column_names = new ArrayList<byte[]>();
       }
       this.super_column_names.add(elem);
     }
 
     public List<byte[]> getSuper_column_names() {
       return this.super_column_names;
     }
 
     public void setSuper_column_names(List<byte[]> super_column_names) {
       this.super_column_names = super_column_names;
     }
 
     public void unsetSuper_column_names() {
       this.super_column_names = null;
     }
 
     // Returns true if field super_column_names is set (has been asigned a value) and false otherwise
     public boolean isSetSuper_column_names() {
       return this.super_column_names != null;
     }
 
     public void setSuper_column_namesIsSet(boolean value) {
       if (!value) {
         this.super_column_names = null;
       }
     }
 
     public void setFieldValue(int fieldID, Object value) {
       switch (fieldID) {
       case TABLE:
         if (value == null) {
           unsetTable();
         } else {
           setTable((String)value);
         }
         break;
 
       case KEY:
         if (value == null) {
           unsetKey();
         } else {
           setKey((String)value);
         }
         break;
 
       case COLUMN_FAMILY:
         if (value == null) {
           unsetColumn_family();
         } else {
           setColumn_family((String)value);
         }
         break;
 
       case SUPER_COLUMN_NAMES:
         if (value == null) {
           unsetSuper_column_names();
         } else {
           setSuper_column_names((List<byte[]>)value);
         }
         break;
 
       default:
         throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
       }
     }
 
     public Object getFieldValue(int fieldID) {
       switch (fieldID) {
       case TABLE:
         return getTable();
 
       case KEY:
         return getKey();
 
       case COLUMN_FAMILY:
         return getColumn_family();
 
       case SUPER_COLUMN_NAMES:
         return getSuper_column_names();
 
       default:
         throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
       }
     }
 
     // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
     public boolean isSet(int fieldID) {
       switch (fieldID) {
       case TABLE:
         return isSetTable();
       case KEY:
         return isSetKey();
       case COLUMN_FAMILY:
         return isSetColumn_family();
       case SUPER_COLUMN_NAMES:
         return isSetSuper_column_names();
       default:
         throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
       }
     }
 
     @Override
     public boolean equals(Object that) {
       if (that == null)
         return false;
       if (that instanceof get_slice_super_by_names_args)
         return this.equals((get_slice_super_by_names_args)that);
       return false;
     }
 
     public boolean equals(get_slice_super_by_names_args that) {
       if (that == null)
         return false;
 
       boolean this_present_table = true && this.isSetTable();
       boolean that_present_table = true && that.isSetTable();
       if (this_present_table || that_present_table) {
         if (!(this_present_table && that_present_table))
           return false;
         if (!this.table.equals(that.table))
           return false;
       }
 
       boolean this_present_key = true && this.isSetKey();
       boolean that_present_key = true && that.isSetKey();
       if (this_present_key || that_present_key) {
         if (!(this_present_key && that_present_key))
           return false;
         if (!this.key.equals(that.key))
           return false;
       }
 
       boolean this_present_column_family = true && this.isSetColumn_family();
       boolean that_present_column_family = true && that.isSetColumn_family();
       if (this_present_column_family || that_present_column_family) {
         if (!(this_present_column_family && that_present_column_family))
           return false;
         if (!this.column_family.equals(that.column_family))
           return false;
       }
 
       boolean this_present_super_column_names = true && this.isSetSuper_column_names();
       boolean that_present_super_column_names = true && that.isSetSuper_column_names();
       if (this_present_super_column_names || that_present_super_column_names) {
         if (!(this_present_super_column_names && that_present_super_column_names))
           return false;
         if (!this.super_column_names.equals(that.super_column_names))
           return false;
       }
 
       return true;
     }
 
     @Override
     public int hashCode() {
       return 0;
     }
 
     public void read(TProtocol iprot) throws TException {
       TField field;
       iprot.readStructBegin();
       while (true)
       {
         field = iprot.readFieldBegin();
         if (field.type == TType.STOP) { 
           break;
         }
         switch (field.id)
         {
           case TABLE:
             if (field.type == TType.STRING) {
               this.table = iprot.readString();
             } else { 
               TProtocolUtil.skip(iprot, field.type);
             }
             break;
           case KEY:
             if (field.type == TType.STRING) {
               this.key = iprot.readString();
             } else { 
               TProtocolUtil.skip(iprot, field.type);
             }
             break;
           case COLUMN_FAMILY:
             if (field.type == TType.STRING) {
               this.column_family = iprot.readString();
             } else { 
               TProtocolUtil.skip(iprot, field.type);
             }
             break;
           case SUPER_COLUMN_NAMES:
             if (field.type == TType.LIST) {
               {
                 TList _list47 = iprot.readListBegin();
                 this.super_column_names = new ArrayList<byte[]>(_list47.size);
                 for (int _i48 = 0; _i48 < _list47.size; ++_i48)
                 {
                   byte[] _elem49;
                   _elem49 = iprot.readBinary();
                   this.super_column_names.add(_elem49);
                 }
                 iprot.readListEnd();
               }
             } else { 
               TProtocolUtil.skip(iprot, field.type);
             }
             break;
           default:
             TProtocolUtil.skip(iprot, field.type);
             break;
         }
         iprot.readFieldEnd();
       }
       iprot.readStructEnd();
 
 
       // check for required fields of primitive type, which can't be checked in the validate method
       validate();
     }
 
     public void write(TProtocol oprot) throws TException {
       validate();
 
       oprot.writeStructBegin(STRUCT_DESC);
       if (this.table != null) {
         oprot.writeFieldBegin(TABLE_FIELD_DESC);
         oprot.writeString(this.table);
         oprot.writeFieldEnd();
       }
       if (this.key != null) {
         oprot.writeFieldBegin(KEY_FIELD_DESC);
         oprot.writeString(this.key);
         oprot.writeFieldEnd();
       }
       if (this.column_family != null) {
         oprot.writeFieldBegin(COLUMN_FAMILY_FIELD_DESC);
         oprot.writeString(this.column_family);
         oprot.writeFieldEnd();
       }
       if (this.super_column_names != null) {
         oprot.writeFieldBegin(SUPER_COLUMN_NAMES_FIELD_DESC);
         {
           oprot.writeListBegin(new TList(TType.STRING, this.super_column_names.size()));
           for (byte[] _iter50 : this.super_column_names)          {
             oprot.writeBinary(_iter50);
           }
           oprot.writeListEnd();
         }
         oprot.writeFieldEnd();
       }
       oprot.writeFieldStop();
       oprot.writeStructEnd();
     }
 
     @Override
     public String toString() {
       StringBuilder sb = new StringBuilder("get_slice_super_by_names_args(");
       boolean first = true;
 
       sb.append("table:");
       if (this.table == null) {
         sb.append("null");
       } else {
         sb.append(this.table);
       }
       first = false;
       if (!first) sb.append(", ");
       sb.append("key:");
       if (this.key == null) {
         sb.append("null");
       } else {
         sb.append(this.key);
       }
       first = false;
       if (!first) sb.append(", ");
       sb.append("column_family:");
       if (this.column_family == null) {
         sb.append("null");
       } else {
         sb.append(this.column_family);
       }
       first = false;
       if (!first) sb.append(", ");
       sb.append("super_column_names:");
       if (this.super_column_names == null) {
         sb.append("null");
       } else {
         sb.append(this.super_column_names);
       }
       first = false;
       sb.append(")");
       return sb.toString();
     }
 
     public void validate() throws TException {
       // check for required fields
       // check that fields of type enum have valid values
     }
 
   }
 
   public static class get_slice_super_by_names_result implements TBase, java.io.Serializable, Cloneable   {
     private static final TStruct STRUCT_DESC = new TStruct("get_slice_super_by_names_result");
     private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.LIST, (short)0);
     private static final TField IRE_FIELD_DESC = new TField("ire", TType.STRUCT, (short)1);
 
     public List<SuperColumn> success;
     public static final int SUCCESS = 0;
     public InvalidRequestException ire;
     public static final int IRE = 1;
 
     private final Isset __isset = new Isset();
     private static final class Isset implements java.io.Serializable {
     }
 
     public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
       put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
           new ListMetaData(TType.LIST, 
               new StructMetaData(TType.STRUCT, SuperColumn.class))));
       put(IRE, new FieldMetaData("ire", TFieldRequirementType.DEFAULT, 
           new FieldValueMetaData(TType.STRUCT)));
     }});
 
     static {
       FieldMetaData.addStructMetaDataMap(get_slice_super_by_names_result.class, metaDataMap);
     }
 
     public get_slice_super_by_names_result() {
     }
 
     public get_slice_super_by_names_result(
       List<SuperColumn> success,
       InvalidRequestException ire)
     {
       this();
       this.success = success;
       this.ire = ire;
     }
 
     /**
      * Performs a deep copy on <i>other</i>.
      */
     public get_slice_super_by_names_result(get_slice_super_by_names_result other) {
       if (other.isSetSuccess()) {
         List<SuperColumn> __this__success = new ArrayList<SuperColumn>();
         for (SuperColumn other_element : other.success) {
           __this__success.add(new SuperColumn(other_element));
         }
         this.success = __this__success;
       }
       if (other.isSetIre()) {
         this.ire = new InvalidRequestException(other.ire);
       }
     }
 
     @Override
     public get_slice_super_by_names_result clone() {
       return new get_slice_super_by_names_result(this);
     }
 
     public int getSuccessSize() {
       return (this.success == null) ? 0 : this.success.size();
     }
 
     public java.util.Iterator<SuperColumn> getSuccessIterator() {
       return (this.success == null) ? null : this.success.iterator();
     }
 
     public void addToSuccess(SuperColumn elem) {
       if (this.success == null) {
         this.success = new ArrayList<SuperColumn>();
       }
       this.success.add(elem);
     }
 
     public List<SuperColumn> getSuccess() {
       return this.success;
     }
 
     public void setSuccess(List<SuperColumn> success) {
       this.success = success;
     }
 
     public void unsetSuccess() {
       this.success = null;
     }
 
     // Returns true if field success is set (has been asigned a value) and false otherwise
     public boolean isSetSuccess() {
       return this.success != null;
     }
 
     public void setSuccessIsSet(boolean value) {
       if (!value) {
         this.success = null;
       }
     }
 
     public InvalidRequestException getIre() {
       return this.ire;
     }
 
     public void setIre(InvalidRequestException ire) {
       this.ire = ire;
     }
 
     public void unsetIre() {
       this.ire = null;
     }
 
     // Returns true if field ire is set (has been asigned a value) and false otherwise
     public boolean isSetIre() {
       return this.ire != null;
     }
 
     public void setIreIsSet(boolean value) {
       if (!value) {
         this.ire = null;
       }
     }
 
     public void setFieldValue(int fieldID, Object value) {
       switch (fieldID) {
       case SUCCESS:
         if (value == null) {
           unsetSuccess();
         } else {
           setSuccess((List<SuperColumn>)value);
         }
         break;
 
       case IRE:
         if (value == null) {
           unsetIre();
         } else {
           setIre((InvalidRequestException)value);
         }
         break;
 
       default:
         throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
       }
     }
 
     public Object getFieldValue(int fieldID) {
       switch (fieldID) {
       case SUCCESS:
         return getSuccess();
 
       case IRE:
         return getIre();
 
       default:
         throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
       }
     }
 
     // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
     public boolean isSet(int fieldID) {
       switch (fieldID) {
       case SUCCESS:
         return isSetSuccess();
       case IRE:
         return isSetIre();
       default:
         throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
       }
     }
 
     @Override
     public boolean equals(Object that) {
       if (that == null)
         return false;
       if (that instanceof get_slice_super_by_names_result)
         return this.equals((get_slice_super_by_names_result)that);
       return false;
     }
 
     public boolean equals(get_slice_super_by_names_result that) {
       if (that == null)
         return false;
 
       boolean this_present_success = true && this.isSetSuccess();
       boolean that_present_success = true && that.isSetSuccess();
       if (this_present_success || that_present_success) {
         if (!(this_present_success && that_present_success))
           return false;
         if (!this.success.equals(that.success))
           return false;
       }
 
       boolean this_present_ire = true && this.isSetIre();
       boolean that_present_ire = true && that.isSetIre();
       if (this_present_ire || that_present_ire) {
         if (!(this_present_ire && that_present_ire))
           return false;
         if (!this.ire.equals(that.ire))
           return false;
       }
 
       return true;
     }
 
     @Override
     public int hashCode() {
       return 0;
     }
 
     public void read(TProtocol iprot) throws TException {
       TField field;
       iprot.readStructBegin();
       while (true)
       {
         field = iprot.readFieldBegin();
         if (field.type == TType.STOP) { 
           break;
         }
         switch (field.id)
         {
           case SUCCESS:
             if (field.type == TType.LIST) {
               {
                 TList _list51 = iprot.readListBegin();
                 this.success = new ArrayList<SuperColumn>(_list51.size);
                 for (int _i52 = 0; _i52 < _list51.size; ++_i52)
                 {
                   SuperColumn _elem53;
                   _elem53 = new SuperColumn();
                   _elem53.read(iprot);
                   this.success.add(_elem53);
                 }
                 iprot.readListEnd();
               }
             } else { 
               TProtocolUtil.skip(iprot, field.type);
             }
             break;
           case IRE:
             if (field.type == TType.STRUCT) {
               this.ire = new InvalidRequestException();
               this.ire.read(iprot);
             } else { 
               TProtocolUtil.skip(iprot, field.type);
             }
             break;
           default:
             TProtocolUtil.skip(iprot, field.type);
             break;
         }
         iprot.readFieldEnd();
       }
       iprot.readStructEnd();
 
 
       // check for required fields of primitive type, which can't be checked in the validate method
       validate();
     }
 
     public void write(TProtocol oprot) throws TException {
       oprot.writeStructBegin(STRUCT_DESC);
 
       if (this.isSetSuccess()) {
         oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
         {
           oprot.writeListBegin(new TList(TType.STRUCT, this.success.size()));
           for (SuperColumn _iter54 : this.success)          {
             _iter54.write(oprot);
           }
           oprot.writeListEnd();
         }
         oprot.writeFieldEnd();
       } else if (this.isSetIre()) {
         oprot.writeFieldBegin(IRE_FIELD_DESC);
         this.ire.write(oprot);
         oprot.writeFieldEnd();
       }
       oprot.writeFieldStop();
       oprot.writeStructEnd();
     }
 
     @Override
     public String toString() {
       StringBuilder sb = new StringBuilder("get_slice_super_by_names_result(");
       boolean first = true;
 
       sb.append("success:");
       if (this.success == null) {
         sb.append("null");
       } else {
         sb.append(this.success);
       }
       first = false;
       if (!first) sb.append(", ");
       sb.append("ire:");
       if (this.ire == null) {
         sb.append("null");
       } else {
         sb.append(this.ire);
       }
       first = false;
       sb.append(")");
       return sb.toString();
     }
 
     public void validate() throws TException {
       // check for required fields
       // check that fields of type enum have valid values
     }
 
   }
 
   public static class get_super_column_args implements TBase, java.io.Serializable, Cloneable   {
     private static final TStruct STRUCT_DESC = new TStruct("get_super_column_args");
     private static final TField TABLE_FIELD_DESC = new TField("table", TType.STRING, (short)1);
     private static final TField KEY_FIELD_DESC = new TField("key", TType.STRING, (short)2);
     private static final TField SUPER_COLUMN_PATH_FIELD_DESC = new TField("super_column_path", TType.STRUCT, (short)3);
 
     public String table;
     public static final int TABLE = 1;
     public String key;
     public static final int KEY = 2;
     public SuperColumnPath super_column_path;
     public static final int SUPER_COLUMN_PATH = 3;
 
     private final Isset __isset = new Isset();
     private static final class Isset implements java.io.Serializable {
     }
 
     public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
       put(TABLE, new FieldMetaData("table", TFieldRequirementType.DEFAULT, 
           new FieldValueMetaData(TType.STRING)));
       put(KEY, new FieldMetaData("key", TFieldRequirementType.DEFAULT, 
           new FieldValueMetaData(TType.STRING)));
       put(SUPER_COLUMN_PATH, new FieldMetaData("super_column_path", TFieldRequirementType.DEFAULT, 
           new StructMetaData(TType.STRUCT, SuperColumnPath.class)));
     }});
 
     static {
       FieldMetaData.addStructMetaDataMap(get_super_column_args.class, metaDataMap);
     }
 
     public get_super_column_args() {
     }
 
     public get_super_column_args(
       String table,
       String key,
       SuperColumnPath super_column_path)
     {
       this();
       this.table = table;
       this.key = key;
       this.super_column_path = super_column_path;
     }
 
     /**
      * Performs a deep copy on <i>other</i>.
      */
     public get_super_column_args(get_super_column_args other) {
       if (other.isSetTable()) {
         this.table = other.table;
       }
       if (other.isSetKey()) {
         this.key = other.key;
       }
       if (other.isSetSuper_column_path()) {
         this.super_column_path = new SuperColumnPath(other.super_column_path);
       }
     }
 
     @Override
     public get_super_column_args clone() {
       return new get_super_column_args(this);
     }
 
     public String getTable() {
       return this.table;
     }
 
     public void setTable(String table) {
       this.table = table;
     }
 
     public void unsetTable() {
       this.table = null;
     }
 
     // Returns true if field table is set (has been asigned a value) and false otherwise
     public boolean isSetTable() {
       return this.table != null;
     }
 
     public void setTableIsSet(boolean value) {
       if (!value) {
         this.table = null;
       }
     }
 
     public String getKey() {
       return this.key;
     }
 
     public void setKey(String key) {
       this.key = key;
     }
 
     public void unsetKey() {
       this.key = null;
     }
 
     // Returns true if field key is set (has been asigned a value) and false otherwise
     public boolean isSetKey() {
       return this.key != null;
     }
 
     public void setKeyIsSet(boolean value) {
       if (!value) {
         this.key = null;
       }
     }
 
     public SuperColumnPath getSuper_column_path() {
       return this.super_column_path;
     }
 
     public void setSuper_column_path(SuperColumnPath super_column_path) {
       this.super_column_path = super_column_path;
     }
 
     public void unsetSuper_column_path() {
       this.super_column_path = null;
     }
 
     // Returns true if field super_column_path is set (has been asigned a value) and false otherwise
     public boolean isSetSuper_column_path() {
       return this.super_column_path != null;
     }
 
     public void setSuper_column_pathIsSet(boolean value) {
       if (!value) {
         this.super_column_path = null;
       }
     }
 
     public void setFieldValue(int fieldID, Object value) {
       switch (fieldID) {
       case TABLE:
         if (value == null) {
           unsetTable();
         } else {
           setTable((String)value);
         }
         break;
 
       case KEY:
         if (value == null) {
           unsetKey();
         } else {
           setKey((String)value);
         }
         break;
 
       case SUPER_COLUMN_PATH:
         if (value == null) {
           unsetSuper_column_path();
         } else {
           setSuper_column_path((SuperColumnPath)value);
         }
         break;
 
       default:
         throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
       }
     }
 
     public Object getFieldValue(int fieldID) {
       switch (fieldID) {
       case TABLE:
         return getTable();
 
       case KEY:
         return getKey();
 
       case SUPER_COLUMN_PATH:
         return getSuper_column_path();
 
       default:
         throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
       }
     }
 
     // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
     public boolean isSet(int fieldID) {
       switch (fieldID) {
       case TABLE:
         return isSetTable();
       case KEY:
         return isSetKey();
       case SUPER_COLUMN_PATH:
         return isSetSuper_column_path();
       default:
         throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
       }
     }
 
     @Override
     public boolean equals(Object that) {
       if (that == null)
         return false;
       if (that instanceof get_super_column_args)
         return this.equals((get_super_column_args)that);
       return false;
     }
 
     public boolean equals(get_super_column_args that) {
       if (that == null)
         return false;
 
       boolean this_present_table = true && this.isSetTable();
       boolean that_present_table = true && that.isSetTable();
       if (this_present_table || that_present_table) {
         if (!(this_present_table && that_present_table))
           return false;
         if (!this.table.equals(that.table))
           return false;
       }
 
       boolean this_present_key = true && this.isSetKey();
       boolean that_present_key = true && that.isSetKey();
       if (this_present_key || that_present_key) {
         if (!(this_present_key && that_present_key))
           return false;
         if (!this.key.equals(that.key))
           return false;
       }
 
       boolean this_present_super_column_path = true && this.isSetSuper_column_path();
       boolean that_present_super_column_path = true && that.isSetSuper_column_path();
       if (this_present_super_column_path || that_present_super_column_path) {
         if (!(this_present_super_column_path && that_present_super_column_path))
           return false;
         if (!this.super_column_path.equals(that.super_column_path))
           return false;
       }
 
       return true;
     }
 
     @Override
     public int hashCode() {
       return 0;
     }
 
     public void read(TProtocol iprot) throws TException {
       TField field;
       iprot.readStructBegin();
       while (true)
       {
         field = iprot.readFieldBegin();
         if (field.type == TType.STOP) { 
           break;
         }
         switch (field.id)
         {
           case TABLE:
             if (field.type == TType.STRING) {
               this.table = iprot.readString();
             } else { 
               TProtocolUtil.skip(iprot, field.type);
             }
             break;
           case KEY:
             if (field.type == TType.STRING) {
               this.key = iprot.readString();
             } else { 
               TProtocolUtil.skip(iprot, field.type);
             }
             break;
           case SUPER_COLUMN_PATH:
             if (field.type == TType.STRUCT) {
               this.super_column_path = new SuperColumnPath();
               this.super_column_path.read(iprot);
             } else { 
               TProtocolUtil.skip(iprot, field.type);
             }
             break;
           default:
             TProtocolUtil.skip(iprot, field.type);
             break;
         }
         iprot.readFieldEnd();
       }
       iprot.readStructEnd();
 
 
       // check for required fields of primitive type, which can't be checked in the validate method
       validate();
     }
 
     public void write(TProtocol oprot) throws TException {
       validate();
 
       oprot.writeStructBegin(STRUCT_DESC);
       if (this.table != null) {
         oprot.writeFieldBegin(TABLE_FIELD_DESC);
         oprot.writeString(this.table);
         oprot.writeFieldEnd();
       }
       if (this.key != null) {
         oprot.writeFieldBegin(KEY_FIELD_DESC);
         oprot.writeString(this.key);
         oprot.writeFieldEnd();
       }
       if (this.super_column_path != null) {
         oprot.writeFieldBegin(SUPER_COLUMN_PATH_FIELD_DESC);
         this.super_column_path.write(oprot);
         oprot.writeFieldEnd();
       }
       oprot.writeFieldStop();
       oprot.writeStructEnd();
     }
 
     @Override
     public String toString() {
       StringBuilder sb = new StringBuilder("get_super_column_args(");
       boolean first = true;
 
       sb.append("table:");
       if (this.table == null) {
         sb.append("null");
       } else {
         sb.append(this.table);
       }
       first = false;
       if (!first) sb.append(", ");
       sb.append("key:");
       if (this.key == null) {
         sb.append("null");
       } else {
         sb.append(this.key);
       }
       first = false;
       if (!first) sb.append(", ");
       sb.append("super_column_path:");
       if (this.super_column_path == null) {
         sb.append("null");
       } else {
         sb.append(this.super_column_path);
       }
       first = false;
       sb.append(")");
       return sb.toString();
     }
 
     public void validate() throws TException {
       // check for required fields
       // check that fields of type enum have valid values
     }
 
   }
 
   public static class get_super_column_result implements TBase, java.io.Serializable, Cloneable   {
     private static final TStruct STRUCT_DESC = new TStruct("get_super_column_result");
     private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);
     private static final TField IRE_FIELD_DESC = new TField("ire", TType.STRUCT, (short)1);
     private static final TField NFE_FIELD_DESC = new TField("nfe", TType.STRUCT, (short)2);
 
     public SuperColumn success;
     public static final int SUCCESS = 0;
     public InvalidRequestException ire;
     public static final int IRE = 1;
     public NotFoundException nfe;
     public static final int NFE = 2;
 
     private final Isset __isset = new Isset();
     private static final class Isset implements java.io.Serializable {
     }
 
     public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
       put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
           new StructMetaData(TType.STRUCT, SuperColumn.class)));
       put(IRE, new FieldMetaData("ire", TFieldRequirementType.DEFAULT, 
           new FieldValueMetaData(TType.STRUCT)));
       put(NFE, new FieldMetaData("nfe", TFieldRequirementType.DEFAULT, 
           new FieldValueMetaData(TType.STRUCT)));
     }});
 
     static {
       FieldMetaData.addStructMetaDataMap(get_super_column_result.class, metaDataMap);
     }
 
     public get_super_column_result() {
     }
 
     public get_super_column_result(
       SuperColumn success,
       InvalidRequestException ire,
       NotFoundException nfe)
     {
       this();
       this.success = success;
       this.ire = ire;
       this.nfe = nfe;
     }
 
     /**
      * Performs a deep copy on <i>other</i>.
      */
     public get_super_column_result(get_super_column_result other) {
       if (other.isSetSuccess()) {
         this.success = new SuperColumn(other.success);
       }
       if (other.isSetIre()) {
         this.ire = new InvalidRequestException(other.ire);
       }
       if (other.isSetNfe()) {
         this.nfe = new NotFoundException(other.nfe);
       }
     }
 
     @Override
     public get_super_column_result clone() {
       return new get_super_column_result(this);
     }
 
     public SuperColumn getSuccess() {
       return this.success;
     }
 
     public void setSuccess(SuperColumn success) {
       this.success = success;
     }
 
     public void unsetSuccess() {
       this.success = null;
     }
 
     // Returns true if field success is set (has been asigned a value) and false otherwise
     public boolean isSetSuccess() {
       return this.success != null;
     }
 
     public void setSuccessIsSet(boolean value) {
       if (!value) {
         this.success = null;
       }
     }
 
     public InvalidRequestException getIre() {
       return this.ire;
     }
 
     public void setIre(InvalidRequestException ire) {
       this.ire = ire;
     }
 
     public void unsetIre() {
       this.ire = null;
     }
 
     // Returns true if field ire is set (has been asigned a value) and false otherwise
     public boolean isSetIre() {
       return this.ire != null;
     }
 
     public void setIreIsSet(boolean value) {
       if (!value) {
         this.ire = null;
       }
     }
 
     public NotFoundException getNfe() {
       return this.nfe;
     }
 
     public void setNfe(NotFoundException nfe) {
       this.nfe = nfe;
     }
 
     public void unsetNfe() {
       this.nfe = null;
     }
 
     // Returns true if field nfe is set (has been asigned a value) and false otherwise
     public boolean isSetNfe() {
       return this.nfe != null;
     }
 
     public void setNfeIsSet(boolean value) {
       if (!value) {
         this.nfe = null;
       }
     }
 
     public void setFieldValue(int fieldID, Object value) {
       switch (fieldID) {
       case SUCCESS:
         if (value == null) {
           unsetSuccess();
         } else {
           setSuccess((SuperColumn)value);
         }
         break;
 
       case IRE:
         if (value == null) {
           unsetIre();
         } else {
           setIre((InvalidRequestException)value);
         }
         break;
 
       case NFE:
         if (value == null) {
           unsetNfe();
         } else {
           setNfe((NotFoundException)value);
         }
         break;
 
       default:
         throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
       }
     }
 
     public Object getFieldValue(int fieldID) {
       switch (fieldID) {
       case SUCCESS:
         return getSuccess();
 
       case IRE:
         return getIre();
 
       case NFE:
         return getNfe();
 
       default:
         throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
       }
     }
 
     // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
     public boolean isSet(int fieldID) {
       switch (fieldID) {
       case SUCCESS:
         return isSetSuccess();
       case IRE:
         return isSetIre();
       case NFE:
         return isSetNfe();
       default:
         throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
       }
     }
 
     @Override
     public boolean equals(Object that) {
       if (that == null)
         return false;
       if (that instanceof get_super_column_result)
         return this.equals((get_super_column_result)that);
       return false;
     }
 
     public boolean equals(get_super_column_result that) {
       if (that == null)
         return false;
 
       boolean this_present_success = true && this.isSetSuccess();
       boolean that_present_success = true && that.isSetSuccess();
       if (this_present_success || that_present_success) {
         if (!(this_present_success && that_present_success))
           return false;
         if (!this.success.equals(that.success))
           return false;
       }
 
       boolean this_present_ire = true && this.isSetIre();
       boolean that_present_ire = true && that.isSetIre();
       if (this_present_ire || that_present_ire) {
         if (!(this_present_ire && that_present_ire))
           return false;
         if (!this.ire.equals(that.ire))
           return false;
       }
 
       boolean this_present_nfe = true && this.isSetNfe();
       boolean that_present_nfe = true && that.isSetNfe();
       if (this_present_nfe || that_present_nfe) {
         if (!(this_present_nfe && that_present_nfe))
           return false;
         if (!this.nfe.equals(that.nfe))
           return false;
       }
 
       return true;
     }
 
     @Override
     public int hashCode() {
       return 0;
     }
 
     public void read(TProtocol iprot) throws TException {
       TField field;
       iprot.readStructBegin();
       while (true)
       {
         field = iprot.readFieldBegin();
         if (field.type == TType.STOP) { 
           break;
         }
         switch (field.id)
         {
           case SUCCESS:
             if (field.type == TType.STRUCT) {
               this.success = new SuperColumn();
               this.success.read(iprot);
             } else { 
               TProtocolUtil.skip(iprot, field.type);
             }
             break;
           case IRE:
             if (field.type == TType.STRUCT) {
               this.ire = new InvalidRequestException();
               this.ire.read(iprot);
             } else { 
               TProtocolUtil.skip(iprot, field.type);
             }
             break;
           case NFE:
             if (field.type == TType.STRUCT) {
               this.nfe = new NotFoundException();
               this.nfe.read(iprot);
             } else { 
               TProtocolUtil.skip(iprot, field.type);
             }
             break;
           default:
             TProtocolUtil.skip(iprot, field.type);
             break;
         }
         iprot.readFieldEnd();
       }
       iprot.readStructEnd();
 
 
       // check for required fields of primitive type, which can't be checked in the validate method
       validate();
     }
 
     public void write(TProtocol oprot) throws TException {
       oprot.writeStructBegin(STRUCT_DESC);
 
       if (this.isSetSuccess()) {
         oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
         this.success.write(oprot);
         oprot.writeFieldEnd();
       } else if (this.isSetIre()) {
         oprot.writeFieldBegin(IRE_FIELD_DESC);
         this.ire.write(oprot);
         oprot.writeFieldEnd();
       } else if (this.isSetNfe()) {
         oprot.writeFieldBegin(NFE_FIELD_DESC);
         this.nfe.write(oprot);
         oprot.writeFieldEnd();
       }
       oprot.writeFieldStop();
       oprot.writeStructEnd();
     }
 
     @Override
     public String toString() {
       StringBuilder sb = new StringBuilder("get_super_column_result(");
       boolean first = true;
 
       sb.append("success:");
       if (this.success == null) {
         sb.append("null");
       } else {
         sb.append(this.success);
       }
       first = false;
       if (!first) sb.append(", ");
       sb.append("ire:");
       if (this.ire == null) {
         sb.append("null");
       } else {
         sb.append(this.ire);
       }
       first = false;
       if (!first) sb.append(", ");
       sb.append("nfe:");
       if (this.nfe == null) {
         sb.append("null");
       } else {
         sb.append(this.nfe);
       }
       first = false;
       sb.append(")");
       return sb.toString();
     }
 
     public void validate() throws TException {
       // check for required fields
       // check that fields of type enum have valid values
     }
 
   }
 
   public static class batch_insert_super_column_args implements TBase, java.io.Serializable, Cloneable   {
     private static final TStruct STRUCT_DESC = new TStruct("batch_insert_super_column_args");
     private static final TField TABLE_FIELD_DESC = new TField("table", TType.STRING, (short)1);
     private static final TField BATCH_MUTATION_SUPER_FIELD_DESC = new TField("batch_mutation_super", TType.STRUCT, (short)2);
     private static final TField BLOCK_FOR_FIELD_DESC = new TField("block_for", TType.I32, (short)3);
 
     public String table;
     public static final int TABLE = 1;
     public BatchMutationSuper batch_mutation_super;
     public static final int BATCH_MUTATION_SUPER = 2;
     public int block_for;
     public static final int BLOCK_FOR = 3;
 
     private final Isset __isset = new Isset();
     private static final class Isset implements java.io.Serializable {
       public boolean block_for = false;
     }
 
     public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
       put(TABLE, new FieldMetaData("table", TFieldRequirementType.DEFAULT, 
           new FieldValueMetaData(TType.STRING)));
       put(BATCH_MUTATION_SUPER, new FieldMetaData("batch_mutation_super", TFieldRequirementType.DEFAULT, 
           new StructMetaData(TType.STRUCT, BatchMutationSuper.class)));
       put(BLOCK_FOR, new FieldMetaData("block_for", TFieldRequirementType.DEFAULT, 
           new FieldValueMetaData(TType.I32)));
     }});
 
     static {
       FieldMetaData.addStructMetaDataMap(batch_insert_super_column_args.class, metaDataMap);
     }
 
     public batch_insert_super_column_args() {
       this.block_for = 0;
 
     }
 
     public batch_insert_super_column_args(
       String table,
       BatchMutationSuper batch_mutation_super,
       int block_for)
     {
       this();
       this.table = table;
       this.batch_mutation_super = batch_mutation_super;
       this.block_for = block_for;
       this.__isset.block_for = true;
     }
 
     /**
      * Performs a deep copy on <i>other</i>.
      */
     public batch_insert_super_column_args(batch_insert_super_column_args other) {
       if (other.isSetTable()) {
         this.table = other.table;
       }
       if (other.isSetBatch_mutation_super()) {
         this.batch_mutation_super = new BatchMutationSuper(other.batch_mutation_super);
       }
       __isset.block_for = other.__isset.block_for;
       this.block_for = other.block_for;
     }
 
     @Override
     public batch_insert_super_column_args clone() {
       return new batch_insert_super_column_args(this);
     }
 
     public String getTable() {
       return this.table;
     }
 
     public void setTable(String table) {
       this.table = table;
     }
 
     public void unsetTable() {
       this.table = null;
     }
 
     // Returns true if field table is set (has been asigned a value) and false otherwise
     public boolean isSetTable() {
       return this.table != null;
     }
 
     public void setTableIsSet(boolean value) {
       if (!value) {
         this.table = null;
       }
     }
 
     public BatchMutationSuper getBatch_mutation_super() {
       return this.batch_mutation_super;
     }
 
     public void setBatch_mutation_super(BatchMutationSuper batch_mutation_super) {
       this.batch_mutation_super = batch_mutation_super;
     }
 
     public void unsetBatch_mutation_super() {
       this.batch_mutation_super = null;
     }
 
     // Returns true if field batch_mutation_super is set (has been asigned a value) and false otherwise
     public boolean isSetBatch_mutation_super() {
       return this.batch_mutation_super != null;
     }
 
     public void setBatch_mutation_superIsSet(boolean value) {
       if (!value) {
         this.batch_mutation_super = null;
       }
     }
 
     public int getBlock_for() {
       return this.block_for;
     }
 
     public void setBlock_for(int block_for) {
       this.block_for = block_for;
       this.__isset.block_for = true;
     }
 
     public void unsetBlock_for() {
       this.__isset.block_for = false;
     }
 
     // Returns true if field block_for is set (has been asigned a value) and false otherwise
     public boolean isSetBlock_for() {
       return this.__isset.block_for;
     }
 
     public void setBlock_forIsSet(boolean value) {
       this.__isset.block_for = value;
     }
 
     public void setFieldValue(int fieldID, Object value) {
       switch (fieldID) {
       case TABLE:
         if (value == null) {
           unsetTable();
         } else {
           setTable((String)value);
         }
         break;
 
       case BATCH_MUTATION_SUPER:
         if (value == null) {
           unsetBatch_mutation_super();
         } else {
           setBatch_mutation_super((BatchMutationSuper)value);
         }
         break;
 
       case BLOCK_FOR:
         if (value == null) {
           unsetBlock_for();
         } else {
           setBlock_for((Integer)value);
         }
         break;
 
       default:
         throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
       }
     }
 
     public Object getFieldValue(int fieldID) {
       switch (fieldID) {
       case TABLE:
         return getTable();
 
       case BATCH_MUTATION_SUPER:
         return getBatch_mutation_super();
 
       case BLOCK_FOR:
         return new Integer(getBlock_for());
 
       default:
         throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
       }
     }
 
     // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
     public boolean isSet(int fieldID) {
       switch (fieldID) {
       case TABLE:
         return isSetTable();
       case BATCH_MUTATION_SUPER:
         return isSetBatch_mutation_super();
       case BLOCK_FOR:
         return isSetBlock_for();
       default:
         throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
       }
     }
 
     @Override
     public boolean equals(Object that) {
       if (that == null)
         return false;
       if (that instanceof batch_insert_super_column_args)
         return this.equals((batch_insert_super_column_args)that);
       return false;
     }
 
     public boolean equals(batch_insert_super_column_args that) {
       if (that == null)
         return false;
 
       boolean this_present_table = true && this.isSetTable();
       boolean that_present_table = true && that.isSetTable();
       if (this_present_table || that_present_table) {
         if (!(this_present_table && that_present_table))
           return false;
         if (!this.table.equals(that.table))
           return false;
       }
 
       boolean this_present_batch_mutation_super = true && this.isSetBatch_mutation_super();
       boolean that_present_batch_mutation_super = true && that.isSetBatch_mutation_super();
       if (this_present_batch_mutation_super || that_present_batch_mutation_super) {
         if (!(this_present_batch_mutation_super && that_present_batch_mutation_super))
           return false;
         if (!this.batch_mutation_super.equals(that.batch_mutation_super))
           return false;
       }
 
       boolean this_present_block_for = true;
       boolean that_present_block_for = true;
       if (this_present_block_for || that_present_block_for) {
         if (!(this_present_block_for && that_present_block_for))
           return false;
         if (this.block_for != that.block_for)
           return false;
       }
 
       return true;
     }
 
     @Override
     public int hashCode() {
       return 0;
     }
 
     public void read(TProtocol iprot) throws TException {
       TField field;
       iprot.readStructBegin();
       while (true)
       {
         field = iprot.readFieldBegin();
         if (field.type == TType.STOP) { 
           break;
         }
         switch (field.id)
         {
           case TABLE:
             if (field.type == TType.STRING) {
               this.table = iprot.readString();
             } else { 
               TProtocolUtil.skip(iprot, field.type);
             }
             break;
           case BATCH_MUTATION_SUPER:
             if (field.type == TType.STRUCT) {
               this.batch_mutation_super = new BatchMutationSuper();
               this.batch_mutation_super.read(iprot);
             } else { 
               TProtocolUtil.skip(iprot, field.type);
             }
             break;
           case BLOCK_FOR:
             if (field.type == TType.I32) {
               this.block_for = iprot.readI32();
               this.__isset.block_for = true;
             } else { 
               TProtocolUtil.skip(iprot, field.type);
             }
             break;
           default:
             TProtocolUtil.skip(iprot, field.type);
             break;
         }
         iprot.readFieldEnd();
       }
       iprot.readStructEnd();
 
 
       // check for required fields of primitive type, which can't be checked in the validate method
       validate();
     }
 
     public void write(TProtocol oprot) throws TException {
       validate();
 
       oprot.writeStructBegin(STRUCT_DESC);
       if (this.table != null) {
         oprot.writeFieldBegin(TABLE_FIELD_DESC);
         oprot.writeString(this.table);
         oprot.writeFieldEnd();
       }
       if (this.batch_mutation_super != null) {
         oprot.writeFieldBegin(BATCH_MUTATION_SUPER_FIELD_DESC);
         this.batch_mutation_super.write(oprot);
         oprot.writeFieldEnd();
       }
       oprot.writeFieldBegin(BLOCK_FOR_FIELD_DESC);
       oprot.writeI32(this.block_for);
       oprot.writeFieldEnd();
       oprot.writeFieldStop();
       oprot.writeStructEnd();
     }
 
     @Override
     public String toString() {
       StringBuilder sb = new StringBuilder("batch_insert_super_column_args(");
       boolean first = true;
 
       sb.append("table:");
       if (this.table == null) {
         sb.append("null");
       } else {
         sb.append(this.table);
       }
       first = false;
       if (!first) sb.append(", ");
       sb.append("batch_mutation_super:");
       if (this.batch_mutation_super == null) {
         sb.append("null");
       } else {
         sb.append(this.batch_mutation_super);
       }
       first = false;
       if (!first) sb.append(", ");
       sb.append("block_for:");
       sb.append(this.block_for);
       first = false;
       sb.append(")");
       return sb.toString();
     }
 
     public void validate() throws TException {
       // check for required fields
       // check that fields of type enum have valid values
     }
 
   }
 
   public static class batch_insert_super_column_result implements TBase, java.io.Serializable, Cloneable   {
     private static final TStruct STRUCT_DESC = new TStruct("batch_insert_super_column_result");
     private static final TField IRE_FIELD_DESC = new TField("ire", TType.STRUCT, (short)1);
     private static final TField UE_FIELD_DESC = new TField("ue", TType.STRUCT, (short)2);
 
     public InvalidRequestException ire;
     public static final int IRE = 1;
     public UnavailableException ue;
     public static final int UE = 2;
 
     private final Isset __isset = new Isset();
     private static final class Isset implements java.io.Serializable {
     }
 
     public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
       put(IRE, new FieldMetaData("ire", TFieldRequirementType.DEFAULT, 
           new FieldValueMetaData(TType.STRUCT)));
       put(UE, new FieldMetaData("ue", TFieldRequirementType.DEFAULT, 
           new FieldValueMetaData(TType.STRUCT)));
     }});
 
     static {
       FieldMetaData.addStructMetaDataMap(batch_insert_super_column_result.class, metaDataMap);
     }
 
     public batch_insert_super_column_result() {
     }
 
     public batch_insert_super_column_result(
       InvalidRequestException ire,
       UnavailableException ue)
     {
       this();
       this.ire = ire;
       this.ue = ue;
     }
 
     /**
      * Performs a deep copy on <i>other</i>.
      */
     public batch_insert_super_column_result(batch_insert_super_column_result other) {
       if (other.isSetIre()) {
         this.ire = new InvalidRequestException(other.ire);
       }
       if (other.isSetUe()) {
         this.ue = new UnavailableException(other.ue);
       }
     }
 
     @Override
     public batch_insert_super_column_result clone() {
       return new batch_insert_super_column_result(this);
     }
 
     public InvalidRequestException getIre() {
       return this.ire;
     }
 
     public void setIre(InvalidRequestException ire) {
       this.ire = ire;
     }
 
     public void unsetIre() {
       this.ire = null;
     }
 
     // Returns true if field ire is set (has been asigned a value) and false otherwise
     public boolean isSetIre() {
       return this.ire != null;
     }
 
     public void setIreIsSet(boolean value) {
       if (!value) {
         this.ire = null;
       }
     }
 
     public UnavailableException getUe() {
       return this.ue;
     }
 
     public void setUe(UnavailableException ue) {
       this.ue = ue;
     }
 
     public void unsetUe() {
       this.ue = null;
     }
 
     // Returns true if field ue is set (has been asigned a value) and false otherwise
     public boolean isSetUe() {
       return this.ue != null;
     }
 
     public void setUeIsSet(boolean value) {
       if (!value) {
         this.ue = null;
       }
     }
 
     public void setFieldValue(int fieldID, Object value) {
       switch (fieldID) {
       case IRE:
         if (value == null) {
           unsetIre();
         } else {
           setIre((InvalidRequestException)value);
         }
         break;
 
       case UE:
         if (value == null) {
           unsetUe();
         } else {
           setUe((UnavailableException)value);
         }
         break;
 
       default:
         throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
       }
     }
 
     public Object getFieldValue(int fieldID) {
       switch (fieldID) {
       case IRE:
         return getIre();
 
       case UE:
         return getUe();
 
       default:
         throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
       }
     }
 
     // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
     public boolean isSet(int fieldID) {
       switch (fieldID) {
       case IRE:
         return isSetIre();
       case UE:
         return isSetUe();
       default:
         throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
       }
     }
 
     @Override
     public boolean equals(Object that) {
       if (that == null)
         return false;
       if (that instanceof batch_insert_super_column_result)
         return this.equals((batch_insert_super_column_result)that);
       return false;
     }
 
     public boolean equals(batch_insert_super_column_result that) {
       if (that == null)
         return false;
 
       boolean this_present_ire = true && this.isSetIre();
       boolean that_present_ire = true && that.isSetIre();
       if (this_present_ire || that_present_ire) {
         if (!(this_present_ire && that_present_ire))
           return false;
         if (!this.ire.equals(that.ire))
           return false;
       }
 
       boolean this_present_ue = true && this.isSetUe();
       boolean that_present_ue = true && that.isSetUe();
       if (this_present_ue || that_present_ue) {
         if (!(this_present_ue && that_present_ue))
           return false;
         if (!this.ue.equals(that.ue))
           return false;
       }
 
       return true;
     }
 
     @Override
     public int hashCode() {
       return 0;
     }
 
     public void read(TProtocol iprot) throws TException {
       TField field;
       iprot.readStructBegin();
       while (true)
       {
         field = iprot.readFieldBegin();
         if (field.type == TType.STOP) { 
           break;
         }
         switch (field.id)
         {
           case IRE:
             if (field.type == TType.STRUCT) {
               this.ire = new InvalidRequestException();
               this.ire.read(iprot);
             } else { 
               TProtocolUtil.skip(iprot, field.type);
             }
             break;
           case UE:
             if (field.type == TType.STRUCT) {
               this.ue = new UnavailableException();
               this.ue.read(iprot);
             } else { 
               TProtocolUtil.skip(iprot, field.type);
             }
             break;
           default:
             TProtocolUtil.skip(iprot, field.type);
             break;
         }
         iprot.readFieldEnd();
       }
       iprot.readStructEnd();
 
 
       // check for required fields of primitive type, which can't be checked in the validate method
       validate();
     }
 
     public void write(TProtocol oprot) throws TException {
       oprot.writeStructBegin(STRUCT_DESC);
 
       if (this.isSetIre()) {
         oprot.writeFieldBegin(IRE_FIELD_DESC);
         this.ire.write(oprot);
         oprot.writeFieldEnd();
       } else if (this.isSetUe()) {
         oprot.writeFieldBegin(UE_FIELD_DESC);
         this.ue.write(oprot);
         oprot.writeFieldEnd();
       }
       oprot.writeFieldStop();
       oprot.writeStructEnd();
     }
 
     @Override
     public String toString() {
       StringBuilder sb = new StringBuilder("batch_insert_super_column_result(");
       boolean first = true;
 
       sb.append("ire:");
       if (this.ire == null) {
         sb.append("null");
       } else {
         sb.append(this.ire);
       }
       first = false;
       if (!first) sb.append(", ");
       sb.append("ue:");
       if (this.ue == null) {
         sb.append("null");
       } else {
         sb.append(this.ue);
       }
       first = false;
       sb.append(")");
       return sb.toString();
     }
 
     public void validate() throws TException {
       // check for required fields
       // check that fields of type enum have valid values
     }
 
   }
 
   public static class get_key_range_args implements TBase, java.io.Serializable, Cloneable   {
     private static final TStruct STRUCT_DESC = new TStruct("get_key_range_args");
     private static final TField TABLE_FIELD_DESC = new TField("table", TType.STRING, (short)1);
     private static final TField COLUMN_FAMILY_FIELD_DESC = new TField("column_family", TType.STRING, (short)2);
    private static final TField START_WITH_FIELD_DESC = new TField("startWith", TType.STRING, (short)3);
    private static final TField STOP_AT_FIELD_DESC = new TField("stopAt", TType.STRING, (short)4);
    private static final TField MAX_RESULTS_FIELD_DESC = new TField("maxResults", TType.I32, (short)5);
 
     public String table;
     public static final int TABLE = 1;
     public String column_family;
     public static final int COLUMN_FAMILY = 2;
    public String startWith;
    public static final int STARTWITH = 3;
    public String stopAt;
    public static final int STOPAT = 4;
    public int maxResults;
    public static final int MAXRESULTS = 5;
 
     private final Isset __isset = new Isset();
     private static final class Isset implements java.io.Serializable {
      public boolean maxResults = false;
     }
 
     public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
       put(TABLE, new FieldMetaData("table", TFieldRequirementType.DEFAULT, 
           new FieldValueMetaData(TType.STRING)));
       put(COLUMN_FAMILY, new FieldMetaData("column_family", TFieldRequirementType.DEFAULT, 
           new FieldValueMetaData(TType.STRING)));
      put(STARTWITH, new FieldMetaData("startWith", TFieldRequirementType.DEFAULT, 
           new FieldValueMetaData(TType.STRING)));
      put(STOPAT, new FieldMetaData("stopAt", TFieldRequirementType.DEFAULT, 
           new FieldValueMetaData(TType.STRING)));
      put(MAXRESULTS, new FieldMetaData("maxResults", TFieldRequirementType.DEFAULT, 
           new FieldValueMetaData(TType.I32)));
     }});
 
     static {
       FieldMetaData.addStructMetaDataMap(get_key_range_args.class, metaDataMap);
     }
 
     public get_key_range_args() {
      this.startWith = "";
 
      this.stopAt = "";
 
      this.maxResults = 100;
 
     }
 
     public get_key_range_args(
       String table,
       String column_family,
      String startWith,
      String stopAt,
      int maxResults)
     {
       this();
       this.table = table;
       this.column_family = column_family;
      this.startWith = startWith;
      this.stopAt = stopAt;
      this.maxResults = maxResults;
      this.__isset.maxResults = true;
     }
 
     /**
      * Performs a deep copy on <i>other</i>.
      */
     public get_key_range_args(get_key_range_args other) {
       if (other.isSetTable()) {
         this.table = other.table;
       }
       if (other.isSetColumn_family()) {
         this.column_family = other.column_family;
       }
      if (other.isSetStartWith()) {
        this.startWith = other.startWith;
       }
      if (other.isSetStopAt()) {
        this.stopAt = other.stopAt;
       }
      __isset.maxResults = other.__isset.maxResults;
      this.maxResults = other.maxResults;
     }
 
     @Override
     public get_key_range_args clone() {
       return new get_key_range_args(this);
     }
 
     public String getTable() {
       return this.table;
     }
 
     public void setTable(String table) {
       this.table = table;
     }
 
     public void unsetTable() {
       this.table = null;
     }
 
     // Returns true if field table is set (has been asigned a value) and false otherwise
     public boolean isSetTable() {
       return this.table != null;
     }
 
     public void setTableIsSet(boolean value) {
       if (!value) {
         this.table = null;
       }
     }
 
     public String getColumn_family() {
       return this.column_family;
     }
 
     public void setColumn_family(String column_family) {
       this.column_family = column_family;
     }
 
     public void unsetColumn_family() {
       this.column_family = null;
     }
 
     // Returns true if field column_family is set (has been asigned a value) and false otherwise
     public boolean isSetColumn_family() {
       return this.column_family != null;
     }
 
     public void setColumn_familyIsSet(boolean value) {
       if (!value) {
         this.column_family = null;
       }
     }
 
    public String getStartWith() {
      return this.startWith;
     }
 
    public void setStartWith(String startWith) {
      this.startWith = startWith;
     }
 
    public void unsetStartWith() {
      this.startWith = null;
     }
 
    // Returns true if field startWith is set (has been asigned a value) and false otherwise
    public boolean isSetStartWith() {
      return this.startWith != null;
     }
 
    public void setStartWithIsSet(boolean value) {
       if (!value) {
        this.startWith = null;
       }
     }
 
    public String getStopAt() {
      return this.stopAt;
     }
 
    public void setStopAt(String stopAt) {
      this.stopAt = stopAt;
     }
 
    public void unsetStopAt() {
      this.stopAt = null;
     }
 
    // Returns true if field stopAt is set (has been asigned a value) and false otherwise
    public boolean isSetStopAt() {
      return this.stopAt != null;
     }
 
    public void setStopAtIsSet(boolean value) {
       if (!value) {
        this.stopAt = null;
       }
     }
 
    public int getMaxResults() {
      return this.maxResults;
     }
 
    public void setMaxResults(int maxResults) {
      this.maxResults = maxResults;
      this.__isset.maxResults = true;
     }
 
    public void unsetMaxResults() {
      this.__isset.maxResults = false;
     }
 
    // Returns true if field maxResults is set (has been asigned a value) and false otherwise
    public boolean isSetMaxResults() {
      return this.__isset.maxResults;
     }
 
    public void setMaxResultsIsSet(boolean value) {
      this.__isset.maxResults = value;
     }
 
     public void setFieldValue(int fieldID, Object value) {
       switch (fieldID) {
       case TABLE:
         if (value == null) {
           unsetTable();
         } else {
           setTable((String)value);
         }
         break;
 
       case COLUMN_FAMILY:
         if (value == null) {
           unsetColumn_family();
         } else {
           setColumn_family((String)value);
         }
         break;
 
      case STARTWITH:
         if (value == null) {
          unsetStartWith();
         } else {
          setStartWith((String)value);
         }
         break;
 
      case STOPAT:
         if (value == null) {
          unsetStopAt();
         } else {
          setStopAt((String)value);
         }
         break;
 
      case MAXRESULTS:
         if (value == null) {
          unsetMaxResults();
         } else {
          setMaxResults((Integer)value);
         }
         break;
 
       default:
         throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
       }
     }
 
     public Object getFieldValue(int fieldID) {
       switch (fieldID) {
       case TABLE:
         return getTable();
 
       case COLUMN_FAMILY:
         return getColumn_family();
 
      case STARTWITH:
        return getStartWith();
 
      case STOPAT:
        return getStopAt();
 
      case MAXRESULTS:
        return new Integer(getMaxResults());
 
       default:
         throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
       }
     }
 
     // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
     public boolean isSet(int fieldID) {
       switch (fieldID) {
       case TABLE:
         return isSetTable();
       case COLUMN_FAMILY:
         return isSetColumn_family();
      case STARTWITH:
        return isSetStartWith();
      case STOPAT:
        return isSetStopAt();
      case MAXRESULTS:
        return isSetMaxResults();
       default:
         throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
       }
     }
 
     @Override
     public boolean equals(Object that) {
       if (that == null)
         return false;
       if (that instanceof get_key_range_args)
         return this.equals((get_key_range_args)that);
       return false;
     }
 
     public boolean equals(get_key_range_args that) {
       if (that == null)
         return false;
 
       boolean this_present_table = true && this.isSetTable();
       boolean that_present_table = true && that.isSetTable();
       if (this_present_table || that_present_table) {
         if (!(this_present_table && that_present_table))
           return false;
         if (!this.table.equals(that.table))
           return false;
       }
 
       boolean this_present_column_family = true && this.isSetColumn_family();
       boolean that_present_column_family = true && that.isSetColumn_family();
       if (this_present_column_family || that_present_column_family) {
         if (!(this_present_column_family && that_present_column_family))
           return false;
         if (!this.column_family.equals(that.column_family))
           return false;
       }
 
      boolean this_present_startWith = true && this.isSetStartWith();
      boolean that_present_startWith = true && that.isSetStartWith();
      if (this_present_startWith || that_present_startWith) {
        if (!(this_present_startWith && that_present_startWith))
           return false;
        if (!this.startWith.equals(that.startWith))
           return false;
       }
 
      boolean this_present_stopAt = true && this.isSetStopAt();
      boolean that_present_stopAt = true && that.isSetStopAt();
      if (this_present_stopAt || that_present_stopAt) {
        if (!(this_present_stopAt && that_present_stopAt))
           return false;
        if (!this.stopAt.equals(that.stopAt))
           return false;
       }
 
      boolean this_present_maxResults = true;
      boolean that_present_maxResults = true;
      if (this_present_maxResults || that_present_maxResults) {
        if (!(this_present_maxResults && that_present_maxResults))
           return false;
        if (this.maxResults != that.maxResults)
           return false;
       }
 
       return true;
     }
 
     @Override
     public int hashCode() {
       return 0;
     }
 
     public void read(TProtocol iprot) throws TException {
       TField field;
       iprot.readStructBegin();
       while (true)
       {
         field = iprot.readFieldBegin();
         if (field.type == TType.STOP) { 
           break;
         }
         switch (field.id)
         {
           case TABLE:
             if (field.type == TType.STRING) {
               this.table = iprot.readString();
             } else { 
               TProtocolUtil.skip(iprot, field.type);
             }
             break;
           case COLUMN_FAMILY:
             if (field.type == TType.STRING) {
               this.column_family = iprot.readString();
             } else { 
               TProtocolUtil.skip(iprot, field.type);
             }
             break;
          case STARTWITH:
             if (field.type == TType.STRING) {
              this.startWith = iprot.readString();
             } else { 
               TProtocolUtil.skip(iprot, field.type);
             }
             break;
          case STOPAT:
             if (field.type == TType.STRING) {
              this.stopAt = iprot.readString();
             } else { 
               TProtocolUtil.skip(iprot, field.type);
             }
             break;
          case MAXRESULTS:
             if (field.type == TType.I32) {
              this.maxResults = iprot.readI32();
              this.__isset.maxResults = true;
             } else { 
               TProtocolUtil.skip(iprot, field.type);
             }
             break;
           default:
             TProtocolUtil.skip(iprot, field.type);
             break;
         }
         iprot.readFieldEnd();
       }
       iprot.readStructEnd();
 
 
       // check for required fields of primitive type, which can't be checked in the validate method
       validate();
     }
 
     public void write(TProtocol oprot) throws TException {
       validate();
 
       oprot.writeStructBegin(STRUCT_DESC);
       if (this.table != null) {
         oprot.writeFieldBegin(TABLE_FIELD_DESC);
         oprot.writeString(this.table);
         oprot.writeFieldEnd();
       }
       if (this.column_family != null) {
         oprot.writeFieldBegin(COLUMN_FAMILY_FIELD_DESC);
         oprot.writeString(this.column_family);
         oprot.writeFieldEnd();
       }
      if (this.startWith != null) {
        oprot.writeFieldBegin(START_WITH_FIELD_DESC);
        oprot.writeString(this.startWith);
         oprot.writeFieldEnd();
       }
      if (this.stopAt != null) {
        oprot.writeFieldBegin(STOP_AT_FIELD_DESC);
        oprot.writeString(this.stopAt);
         oprot.writeFieldEnd();
       }
      oprot.writeFieldBegin(MAX_RESULTS_FIELD_DESC);
      oprot.writeI32(this.maxResults);
       oprot.writeFieldEnd();
       oprot.writeFieldStop();
       oprot.writeStructEnd();
     }
 
     @Override
     public String toString() {
       StringBuilder sb = new StringBuilder("get_key_range_args(");
       boolean first = true;
 
       sb.append("table:");
       if (this.table == null) {
         sb.append("null");
       } else {
         sb.append(this.table);
       }
       first = false;
       if (!first) sb.append(", ");
       sb.append("column_family:");
       if (this.column_family == null) {
         sb.append("null");
       } else {
         sb.append(this.column_family);
       }
       first = false;
       if (!first) sb.append(", ");
      sb.append("startWith:");
      if (this.startWith == null) {
         sb.append("null");
       } else {
        sb.append(this.startWith);
       }
       first = false;
       if (!first) sb.append(", ");
      sb.append("stopAt:");
      if (this.stopAt == null) {
         sb.append("null");
       } else {
        sb.append(this.stopAt);
       }
       first = false;
       if (!first) sb.append(", ");
      sb.append("maxResults:");
      sb.append(this.maxResults);
       first = false;
       sb.append(")");
       return sb.toString();
     }
 
     public void validate() throws TException {
       // check for required fields
       // check that fields of type enum have valid values
     }
 
   }
 
   public static class get_key_range_result implements TBase, java.io.Serializable, Cloneable   {
     private static final TStruct STRUCT_DESC = new TStruct("get_key_range_result");
     private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.LIST, (short)0);
     private static final TField IRE_FIELD_DESC = new TField("ire", TType.STRUCT, (short)1);
 
     public List<String> success;
     public static final int SUCCESS = 0;
     public InvalidRequestException ire;
     public static final int IRE = 1;
 
     private final Isset __isset = new Isset();
     private static final class Isset implements java.io.Serializable {
     }
 
     public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
       put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
           new ListMetaData(TType.LIST, 
               new FieldValueMetaData(TType.STRING))));
       put(IRE, new FieldMetaData("ire", TFieldRequirementType.DEFAULT, 
           new FieldValueMetaData(TType.STRUCT)));
     }});
 
     static {
       FieldMetaData.addStructMetaDataMap(get_key_range_result.class, metaDataMap);
     }
 
     public get_key_range_result() {
     }
 
     public get_key_range_result(
       List<String> success,
       InvalidRequestException ire)
     {
       this();
       this.success = success;
       this.ire = ire;
     }
 
     /**
      * Performs a deep copy on <i>other</i>.
      */
     public get_key_range_result(get_key_range_result other) {
       if (other.isSetSuccess()) {
         List<String> __this__success = new ArrayList<String>();
         for (String other_element : other.success) {
           __this__success.add(other_element);
         }
         this.success = __this__success;
       }
       if (other.isSetIre()) {
         this.ire = new InvalidRequestException(other.ire);
       }
     }
 
     @Override
     public get_key_range_result clone() {
       return new get_key_range_result(this);
     }
 
     public int getSuccessSize() {
       return (this.success == null) ? 0 : this.success.size();
     }
 
     public java.util.Iterator<String> getSuccessIterator() {
       return (this.success == null) ? null : this.success.iterator();
     }
 
     public void addToSuccess(String elem) {
       if (this.success == null) {
         this.success = new ArrayList<String>();
       }
       this.success.add(elem);
     }
 
     public List<String> getSuccess() {
       return this.success;
     }
 
     public void setSuccess(List<String> success) {
       this.success = success;
     }
 
     public void unsetSuccess() {
       this.success = null;
     }
 
     // Returns true if field success is set (has been asigned a value) and false otherwise
     public boolean isSetSuccess() {
       return this.success != null;
     }
 
     public void setSuccessIsSet(boolean value) {
       if (!value) {
         this.success = null;
       }
     }
 
     public InvalidRequestException getIre() {
       return this.ire;
     }
 
     public void setIre(InvalidRequestException ire) {
       this.ire = ire;
     }
 
     public void unsetIre() {
       this.ire = null;
     }
 
     // Returns true if field ire is set (has been asigned a value) and false otherwise
     public boolean isSetIre() {
       return this.ire != null;
     }
 
     public void setIreIsSet(boolean value) {
       if (!value) {
         this.ire = null;
       }
     }
 
     public void setFieldValue(int fieldID, Object value) {
       switch (fieldID) {
       case SUCCESS:
         if (value == null) {
           unsetSuccess();
         } else {
           setSuccess((List<String>)value);
         }
         break;
 
       case IRE:
         if (value == null) {
           unsetIre();
         } else {
           setIre((InvalidRequestException)value);
         }
         break;
 
       default:
         throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
       }
     }
 
     public Object getFieldValue(int fieldID) {
       switch (fieldID) {
       case SUCCESS:
         return getSuccess();
 
       case IRE:
         return getIre();
 
       default:
         throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
       }
     }
 
     // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
     public boolean isSet(int fieldID) {
       switch (fieldID) {
       case SUCCESS:
         return isSetSuccess();
       case IRE:
         return isSetIre();
       default:
         throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
       }
     }
 
     @Override
     public boolean equals(Object that) {
       if (that == null)
         return false;
       if (that instanceof get_key_range_result)
         return this.equals((get_key_range_result)that);
       return false;
     }
 
     public boolean equals(get_key_range_result that) {
       if (that == null)
         return false;
 
       boolean this_present_success = true && this.isSetSuccess();
       boolean that_present_success = true && that.isSetSuccess();
       if (this_present_success || that_present_success) {
         if (!(this_present_success && that_present_success))
           return false;
         if (!this.success.equals(that.success))
           return false;
       }
 
       boolean this_present_ire = true && this.isSetIre();
       boolean that_present_ire = true && that.isSetIre();
       if (this_present_ire || that_present_ire) {
         if (!(this_present_ire && that_present_ire))
           return false;
         if (!this.ire.equals(that.ire))
           return false;
       }
 
       return true;
     }
 
     @Override
     public int hashCode() {
       return 0;
     }
 
     public void read(TProtocol iprot) throws TException {
       TField field;
       iprot.readStructBegin();
       while (true)
       {
         field = iprot.readFieldBegin();
         if (field.type == TType.STOP) { 
           break;
         }
         switch (field.id)
         {
           case SUCCESS:
             if (field.type == TType.LIST) {
               {
                 TList _list55 = iprot.readListBegin();
                 this.success = new ArrayList<String>(_list55.size);
                 for (int _i56 = 0; _i56 < _list55.size; ++_i56)
                 {
                   String _elem57;
                   _elem57 = iprot.readString();
                   this.success.add(_elem57);
                 }
                 iprot.readListEnd();
               }
             } else { 
               TProtocolUtil.skip(iprot, field.type);
             }
             break;
           case IRE:
             if (field.type == TType.STRUCT) {
               this.ire = new InvalidRequestException();
               this.ire.read(iprot);
             } else { 
               TProtocolUtil.skip(iprot, field.type);
             }
             break;
           default:
             TProtocolUtil.skip(iprot, field.type);
             break;
         }
         iprot.readFieldEnd();
       }
       iprot.readStructEnd();
 
 
       // check for required fields of primitive type, which can't be checked in the validate method
       validate();
     }
 
     public void write(TProtocol oprot) throws TException {
       oprot.writeStructBegin(STRUCT_DESC);
 
       if (this.isSetSuccess()) {
         oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
         {
           oprot.writeListBegin(new TList(TType.STRING, this.success.size()));
           for (String _iter58 : this.success)          {
             oprot.writeString(_iter58);
           }
           oprot.writeListEnd();
         }
         oprot.writeFieldEnd();
       } else if (this.isSetIre()) {
         oprot.writeFieldBegin(IRE_FIELD_DESC);
         this.ire.write(oprot);
         oprot.writeFieldEnd();
       }
       oprot.writeFieldStop();
       oprot.writeStructEnd();
     }
 
     @Override
     public String toString() {
       StringBuilder sb = new StringBuilder("get_key_range_result(");
       boolean first = true;
 
       sb.append("success:");
       if (this.success == null) {
         sb.append("null");
       } else {
         sb.append(this.success);
       }
       first = false;
       if (!first) sb.append(", ");
       sb.append("ire:");
       if (this.ire == null) {
         sb.append("null");
       } else {
         sb.append(this.ire);
       }
       first = false;
       sb.append(")");
       return sb.toString();
     }
 
     public void validate() throws TException {
       // check for required fields
       // check that fields of type enum have valid values
     }
 
   }
 
  public static class getStringProperty_args implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("getStringProperty_args");
    private static final TField PROPERTY_NAME_FIELD_DESC = new TField("propertyName", TType.STRING, (short)1);
 
    public String propertyName;
    public static final int PROPERTYNAME = 1;
 
     private final Isset __isset = new Isset();
     private static final class Isset implements java.io.Serializable {
     }
 
     public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(PROPERTYNAME, new FieldMetaData("propertyName", TFieldRequirementType.DEFAULT, 
           new FieldValueMetaData(TType.STRING)));
     }});
 
     static {
      FieldMetaData.addStructMetaDataMap(getStringProperty_args.class, metaDataMap);
     }
 
    public getStringProperty_args() {
     }
 
    public getStringProperty_args(
      String propertyName)
     {
       this();
      this.propertyName = propertyName;
     }
 
     /**
      * Performs a deep copy on <i>other</i>.
      */
    public getStringProperty_args(getStringProperty_args other) {
      if (other.isSetPropertyName()) {
        this.propertyName = other.propertyName;
       }
     }
 
     @Override
    public getStringProperty_args clone() {
      return new getStringProperty_args(this);
     }
 
    public String getPropertyName() {
      return this.propertyName;
     }
 
    public void setPropertyName(String propertyName) {
      this.propertyName = propertyName;
     }
 
    public void unsetPropertyName() {
      this.propertyName = null;
     }
 
    // Returns true if field propertyName is set (has been asigned a value) and false otherwise
    public boolean isSetPropertyName() {
      return this.propertyName != null;
     }
 
    public void setPropertyNameIsSet(boolean value) {
       if (!value) {
        this.propertyName = null;
       }
     }
 
     public void setFieldValue(int fieldID, Object value) {
       switch (fieldID) {
      case PROPERTYNAME:
         if (value == null) {
          unsetPropertyName();
         } else {
          setPropertyName((String)value);
         }
         break;
 
       default:
         throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
       }
     }
 
     public Object getFieldValue(int fieldID) {
       switch (fieldID) {
      case PROPERTYNAME:
        return getPropertyName();
 
       default:
         throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
       }
     }
 
     // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
     public boolean isSet(int fieldID) {
       switch (fieldID) {
      case PROPERTYNAME:
        return isSetPropertyName();
       default:
         throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
       }
     }
 
     @Override
     public boolean equals(Object that) {
       if (that == null)
         return false;
      if (that instanceof getStringProperty_args)
        return this.equals((getStringProperty_args)that);
       return false;
     }
 
    public boolean equals(getStringProperty_args that) {
       if (that == null)
         return false;
 
      boolean this_present_propertyName = true && this.isSetPropertyName();
      boolean that_present_propertyName = true && that.isSetPropertyName();
      if (this_present_propertyName || that_present_propertyName) {
        if (!(this_present_propertyName && that_present_propertyName))
           return false;
        if (!this.propertyName.equals(that.propertyName))
           return false;
       }
 
       return true;
     }
 
     @Override
     public int hashCode() {
       return 0;
     }
 
     public void read(TProtocol iprot) throws TException {
       TField field;
       iprot.readStructBegin();
       while (true)
       {
         field = iprot.readFieldBegin();
         if (field.type == TType.STOP) { 
           break;
         }
         switch (field.id)
         {
          case PROPERTYNAME:
             if (field.type == TType.STRING) {
              this.propertyName = iprot.readString();
             } else { 
               TProtocolUtil.skip(iprot, field.type);
             }
             break;
           default:
             TProtocolUtil.skip(iprot, field.type);
             break;
         }
         iprot.readFieldEnd();
       }
       iprot.readStructEnd();
 
 
       // check for required fields of primitive type, which can't be checked in the validate method
       validate();
     }
 
     public void write(TProtocol oprot) throws TException {
       validate();
 
       oprot.writeStructBegin(STRUCT_DESC);
      if (this.propertyName != null) {
        oprot.writeFieldBegin(PROPERTY_NAME_FIELD_DESC);
        oprot.writeString(this.propertyName);
         oprot.writeFieldEnd();
       }
       oprot.writeFieldStop();
       oprot.writeStructEnd();
     }
 
     @Override
     public String toString() {
      StringBuilder sb = new StringBuilder("getStringProperty_args(");
       boolean first = true;
 
      sb.append("propertyName:");
      if (this.propertyName == null) {
         sb.append("null");
       } else {
        sb.append(this.propertyName);
       }
       first = false;
       sb.append(")");
       return sb.toString();
     }
 
     public void validate() throws TException {
       // check for required fields
       // check that fields of type enum have valid values
     }
 
   }
 
  public static class getStringProperty_result implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("getStringProperty_result");
     private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRING, (short)0);
 
     public String success;
     public static final int SUCCESS = 0;
 
     private final Isset __isset = new Isset();
     private static final class Isset implements java.io.Serializable {
     }
 
     public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
       put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
           new FieldValueMetaData(TType.STRING)));
     }});
 
     static {
      FieldMetaData.addStructMetaDataMap(getStringProperty_result.class, metaDataMap);
     }
 
    public getStringProperty_result() {
     }
 
    public getStringProperty_result(
       String success)
     {
       this();
       this.success = success;
     }
 
     /**
      * Performs a deep copy on <i>other</i>.
      */
    public getStringProperty_result(getStringProperty_result other) {
       if (other.isSetSuccess()) {
         this.success = other.success;
       }
     }
 
     @Override
    public getStringProperty_result clone() {
      return new getStringProperty_result(this);
     }
 
     public String getSuccess() {
       return this.success;
     }
 
     public void setSuccess(String success) {
       this.success = success;
     }
 
     public void unsetSuccess() {
       this.success = null;
     }
 
     // Returns true if field success is set (has been asigned a value) and false otherwise
     public boolean isSetSuccess() {
       return this.success != null;
     }
 
     public void setSuccessIsSet(boolean value) {
       if (!value) {
         this.success = null;
       }
     }
 
     public void setFieldValue(int fieldID, Object value) {
       switch (fieldID) {
       case SUCCESS:
         if (value == null) {
           unsetSuccess();
         } else {
           setSuccess((String)value);
         }
         break;
 
       default:
         throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
       }
     }
 
     public Object getFieldValue(int fieldID) {
       switch (fieldID) {
       case SUCCESS:
         return getSuccess();
 
       default:
         throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
       }
     }
 
     // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
     public boolean isSet(int fieldID) {
       switch (fieldID) {
       case SUCCESS:
         return isSetSuccess();
       default:
         throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
       }
     }
 
     @Override
     public boolean equals(Object that) {
       if (that == null)
         return false;
      if (that instanceof getStringProperty_result)
        return this.equals((getStringProperty_result)that);
       return false;
     }
 
    public boolean equals(getStringProperty_result that) {
       if (that == null)
         return false;
 
       boolean this_present_success = true && this.isSetSuccess();
       boolean that_present_success = true && that.isSetSuccess();
       if (this_present_success || that_present_success) {
         if (!(this_present_success && that_present_success))
           return false;
         if (!this.success.equals(that.success))
           return false;
       }
 
       return true;
     }
 
     @Override
     public int hashCode() {
       return 0;
     }
 
     public void read(TProtocol iprot) throws TException {
       TField field;
       iprot.readStructBegin();
       while (true)
       {
         field = iprot.readFieldBegin();
         if (field.type == TType.STOP) { 
           break;
         }
         switch (field.id)
         {
           case SUCCESS:
             if (field.type == TType.STRING) {
               this.success = iprot.readString();
             } else { 
               TProtocolUtil.skip(iprot, field.type);
             }
             break;
           default:
             TProtocolUtil.skip(iprot, field.type);
             break;
         }
         iprot.readFieldEnd();
       }
       iprot.readStructEnd();
 
 
       // check for required fields of primitive type, which can't be checked in the validate method
       validate();
     }
 
     public void write(TProtocol oprot) throws TException {
       oprot.writeStructBegin(STRUCT_DESC);
 
       if (this.isSetSuccess()) {
         oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
         oprot.writeString(this.success);
         oprot.writeFieldEnd();
       }
       oprot.writeFieldStop();
       oprot.writeStructEnd();
     }
 
     @Override
     public String toString() {
      StringBuilder sb = new StringBuilder("getStringProperty_result(");
       boolean first = true;
 
       sb.append("success:");
       if (this.success == null) {
         sb.append("null");
       } else {
         sb.append(this.success);
       }
       first = false;
       sb.append(")");
       return sb.toString();
     }
 
     public void validate() throws TException {
       // check for required fields
       // check that fields of type enum have valid values
     }
 
   }
 
  public static class getStringListProperty_args implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("getStringListProperty_args");
    private static final TField PROPERTY_NAME_FIELD_DESC = new TField("propertyName", TType.STRING, (short)1);
 
    public String propertyName;
    public static final int PROPERTYNAME = 1;
 
     private final Isset __isset = new Isset();
     private static final class Isset implements java.io.Serializable {
     }
 
     public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(PROPERTYNAME, new FieldMetaData("propertyName", TFieldRequirementType.DEFAULT, 
           new FieldValueMetaData(TType.STRING)));
     }});
 
     static {
      FieldMetaData.addStructMetaDataMap(getStringListProperty_args.class, metaDataMap);
     }
 
    public getStringListProperty_args() {
     }
 
    public getStringListProperty_args(
      String propertyName)
     {
       this();
      this.propertyName = propertyName;
     }
 
     /**
      * Performs a deep copy on <i>other</i>.
      */
    public getStringListProperty_args(getStringListProperty_args other) {
      if (other.isSetPropertyName()) {
        this.propertyName = other.propertyName;
       }
     }
 
     @Override
    public getStringListProperty_args clone() {
      return new getStringListProperty_args(this);
     }
 
    public String getPropertyName() {
      return this.propertyName;
     }
 
    public void setPropertyName(String propertyName) {
      this.propertyName = propertyName;
     }
 
    public void unsetPropertyName() {
      this.propertyName = null;
     }
 
    // Returns true if field propertyName is set (has been asigned a value) and false otherwise
    public boolean isSetPropertyName() {
      return this.propertyName != null;
     }
 
    public void setPropertyNameIsSet(boolean value) {
       if (!value) {
        this.propertyName = null;
       }
     }
 
     public void setFieldValue(int fieldID, Object value) {
       switch (fieldID) {
      case PROPERTYNAME:
         if (value == null) {
          unsetPropertyName();
         } else {
          setPropertyName((String)value);
         }
         break;
 
       default:
         throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
       }
     }
 
     public Object getFieldValue(int fieldID) {
       switch (fieldID) {
      case PROPERTYNAME:
        return getPropertyName();
 
       default:
         throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
       }
     }
 
     // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
     public boolean isSet(int fieldID) {
       switch (fieldID) {
      case PROPERTYNAME:
        return isSetPropertyName();
       default:
         throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
       }
     }
 
     @Override
     public boolean equals(Object that) {
       if (that == null)
         return false;
      if (that instanceof getStringListProperty_args)
        return this.equals((getStringListProperty_args)that);
       return false;
     }
 
    public boolean equals(getStringListProperty_args that) {
       if (that == null)
         return false;
 
      boolean this_present_propertyName = true && this.isSetPropertyName();
      boolean that_present_propertyName = true && that.isSetPropertyName();
      if (this_present_propertyName || that_present_propertyName) {
        if (!(this_present_propertyName && that_present_propertyName))
           return false;
        if (!this.propertyName.equals(that.propertyName))
           return false;
       }
 
       return true;
     }
 
     @Override
     public int hashCode() {
       return 0;
     }
 
     public void read(TProtocol iprot) throws TException {
       TField field;
       iprot.readStructBegin();
       while (true)
       {
         field = iprot.readFieldBegin();
         if (field.type == TType.STOP) { 
           break;
         }
         switch (field.id)
         {
          case PROPERTYNAME:
             if (field.type == TType.STRING) {
              this.propertyName = iprot.readString();
             } else { 
               TProtocolUtil.skip(iprot, field.type);
             }
             break;
           default:
             TProtocolUtil.skip(iprot, field.type);
             break;
         }
         iprot.readFieldEnd();
       }
       iprot.readStructEnd();
 
 
       // check for required fields of primitive type, which can't be checked in the validate method
       validate();
     }
 
     public void write(TProtocol oprot) throws TException {
       validate();
 
       oprot.writeStructBegin(STRUCT_DESC);
      if (this.propertyName != null) {
        oprot.writeFieldBegin(PROPERTY_NAME_FIELD_DESC);
        oprot.writeString(this.propertyName);
         oprot.writeFieldEnd();
       }
       oprot.writeFieldStop();
       oprot.writeStructEnd();
     }
 
     @Override
     public String toString() {
      StringBuilder sb = new StringBuilder("getStringListProperty_args(");
       boolean first = true;
 
      sb.append("propertyName:");
      if (this.propertyName == null) {
         sb.append("null");
       } else {
        sb.append(this.propertyName);
       }
       first = false;
       sb.append(")");
       return sb.toString();
     }
 
     public void validate() throws TException {
       // check for required fields
       // check that fields of type enum have valid values
     }
 
   }
 
  public static class getStringListProperty_result implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("getStringListProperty_result");
     private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.LIST, (short)0);
 
     public List<String> success;
     public static final int SUCCESS = 0;
 
     private final Isset __isset = new Isset();
     private static final class Isset implements java.io.Serializable {
     }
 
     public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
       put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
           new ListMetaData(TType.LIST, 
               new FieldValueMetaData(TType.STRING))));
     }});
 
     static {
      FieldMetaData.addStructMetaDataMap(getStringListProperty_result.class, metaDataMap);
     }
 
    public getStringListProperty_result() {
     }
 
    public getStringListProperty_result(
       List<String> success)
     {
       this();
       this.success = success;
     }
 
     /**
      * Performs a deep copy on <i>other</i>.
      */
    public getStringListProperty_result(getStringListProperty_result other) {
       if (other.isSetSuccess()) {
         List<String> __this__success = new ArrayList<String>();
         for (String other_element : other.success) {
           __this__success.add(other_element);
         }
         this.success = __this__success;
       }
     }
 
     @Override
    public getStringListProperty_result clone() {
      return new getStringListProperty_result(this);
     }
 
     public int getSuccessSize() {
       return (this.success == null) ? 0 : this.success.size();
     }
 
     public java.util.Iterator<String> getSuccessIterator() {
       return (this.success == null) ? null : this.success.iterator();
     }
 
     public void addToSuccess(String elem) {
       if (this.success == null) {
         this.success = new ArrayList<String>();
       }
       this.success.add(elem);
     }
 
     public List<String> getSuccess() {
       return this.success;
     }
 
     public void setSuccess(List<String> success) {
       this.success = success;
     }
 
     public void unsetSuccess() {
       this.success = null;
     }
 
     // Returns true if field success is set (has been asigned a value) and false otherwise
     public boolean isSetSuccess() {
       return this.success != null;
     }
 
     public void setSuccessIsSet(boolean value) {
       if (!value) {
         this.success = null;
       }
     }
 
     public void setFieldValue(int fieldID, Object value) {
       switch (fieldID) {
       case SUCCESS:
         if (value == null) {
           unsetSuccess();
         } else {
           setSuccess((List<String>)value);
         }
         break;
 
       default:
         throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
       }
     }
 
     public Object getFieldValue(int fieldID) {
       switch (fieldID) {
       case SUCCESS:
         return getSuccess();
 
       default:
         throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
       }
     }
 
     // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
     public boolean isSet(int fieldID) {
       switch (fieldID) {
       case SUCCESS:
         return isSetSuccess();
       default:
         throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
       }
     }
 
     @Override
     public boolean equals(Object that) {
       if (that == null)
         return false;
      if (that instanceof getStringListProperty_result)
        return this.equals((getStringListProperty_result)that);
       return false;
     }
 
    public boolean equals(getStringListProperty_result that) {
       if (that == null)
         return false;
 
       boolean this_present_success = true && this.isSetSuccess();
       boolean that_present_success = true && that.isSetSuccess();
       if (this_present_success || that_present_success) {
         if (!(this_present_success && that_present_success))
           return false;
         if (!this.success.equals(that.success))
           return false;
       }
 
       return true;
     }
 
     @Override
     public int hashCode() {
       return 0;
     }
 
     public void read(TProtocol iprot) throws TException {
       TField field;
       iprot.readStructBegin();
       while (true)
       {
         field = iprot.readFieldBegin();
         if (field.type == TType.STOP) { 
           break;
         }
         switch (field.id)
         {
           case SUCCESS:
             if (field.type == TType.LIST) {
               {
                 TList _list59 = iprot.readListBegin();
                 this.success = new ArrayList<String>(_list59.size);
                 for (int _i60 = 0; _i60 < _list59.size; ++_i60)
                 {
                   String _elem61;
                   _elem61 = iprot.readString();
                   this.success.add(_elem61);
                 }
                 iprot.readListEnd();
               }
             } else { 
               TProtocolUtil.skip(iprot, field.type);
             }
             break;
           default:
             TProtocolUtil.skip(iprot, field.type);
             break;
         }
         iprot.readFieldEnd();
       }
       iprot.readStructEnd();
 
 
       // check for required fields of primitive type, which can't be checked in the validate method
       validate();
     }
 
     public void write(TProtocol oprot) throws TException {
       oprot.writeStructBegin(STRUCT_DESC);
 
       if (this.isSetSuccess()) {
         oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
         {
           oprot.writeListBegin(new TList(TType.STRING, this.success.size()));
           for (String _iter62 : this.success)          {
             oprot.writeString(_iter62);
           }
           oprot.writeListEnd();
         }
         oprot.writeFieldEnd();
       }
       oprot.writeFieldStop();
       oprot.writeStructEnd();
     }
 
     @Override
     public String toString() {
      StringBuilder sb = new StringBuilder("getStringListProperty_result(");
       boolean first = true;
 
       sb.append("success:");
       if (this.success == null) {
         sb.append("null");
       } else {
         sb.append(this.success);
       }
       first = false;
       sb.append(")");
       return sb.toString();
     }
 
     public void validate() throws TException {
       // check for required fields
       // check that fields of type enum have valid values
     }
 
   }
 
  public static class describeTable_args implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("describeTable_args");
    private static final TField TABLE_NAME_FIELD_DESC = new TField("tableName", TType.STRING, (short)1);
 
    public String tableName;
    public static final int TABLENAME = 1;
 
     private final Isset __isset = new Isset();
     private static final class Isset implements java.io.Serializable {
     }
 
     public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(TABLENAME, new FieldMetaData("tableName", TFieldRequirementType.DEFAULT, 
           new FieldValueMetaData(TType.STRING)));
     }});
 
     static {
      FieldMetaData.addStructMetaDataMap(describeTable_args.class, metaDataMap);
     }
 
    public describeTable_args() {
     }
 
    public describeTable_args(
      String tableName)
     {
       this();
      this.tableName = tableName;
     }
 
     /**
      * Performs a deep copy on <i>other</i>.
      */
    public describeTable_args(describeTable_args other) {
      if (other.isSetTableName()) {
        this.tableName = other.tableName;
       }
     }
 
     @Override
    public describeTable_args clone() {
      return new describeTable_args(this);
     }
 
    public String getTableName() {
      return this.tableName;
     }
 
    public void setTableName(String tableName) {
      this.tableName = tableName;
     }
 
    public void unsetTableName() {
      this.tableName = null;
     }
 
    // Returns true if field tableName is set (has been asigned a value) and false otherwise
    public boolean isSetTableName() {
      return this.tableName != null;
     }
 
    public void setTableNameIsSet(boolean value) {
       if (!value) {
        this.tableName = null;
       }
     }
 
     public void setFieldValue(int fieldID, Object value) {
       switch (fieldID) {
      case TABLENAME:
         if (value == null) {
          unsetTableName();
         } else {
          setTableName((String)value);
         }
         break;
 
       default:
         throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
       }
     }
 
     public Object getFieldValue(int fieldID) {
       switch (fieldID) {
      case TABLENAME:
        return getTableName();
 
       default:
         throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
       }
     }
 
     // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
     public boolean isSet(int fieldID) {
       switch (fieldID) {
      case TABLENAME:
        return isSetTableName();
       default:
         throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
       }
     }
 
     @Override
     public boolean equals(Object that) {
       if (that == null)
         return false;
      if (that instanceof describeTable_args)
        return this.equals((describeTable_args)that);
       return false;
     }
 
    public boolean equals(describeTable_args that) {
       if (that == null)
         return false;
 
      boolean this_present_tableName = true && this.isSetTableName();
      boolean that_present_tableName = true && that.isSetTableName();
      if (this_present_tableName || that_present_tableName) {
        if (!(this_present_tableName && that_present_tableName))
           return false;
        if (!this.tableName.equals(that.tableName))
           return false;
       }
 
       return true;
     }
 
     @Override
     public int hashCode() {
       return 0;
     }
 
     public void read(TProtocol iprot) throws TException {
       TField field;
       iprot.readStructBegin();
       while (true)
       {
         field = iprot.readFieldBegin();
         if (field.type == TType.STOP) { 
           break;
         }
         switch (field.id)
         {
          case TABLENAME:
             if (field.type == TType.STRING) {
              this.tableName = iprot.readString();
             } else { 
               TProtocolUtil.skip(iprot, field.type);
             }
             break;
           default:
             TProtocolUtil.skip(iprot, field.type);
             break;
         }
         iprot.readFieldEnd();
       }
       iprot.readStructEnd();
 
 
       // check for required fields of primitive type, which can't be checked in the validate method
       validate();
     }
 
     public void write(TProtocol oprot) throws TException {
       validate();
 
       oprot.writeStructBegin(STRUCT_DESC);
      if (this.tableName != null) {
        oprot.writeFieldBegin(TABLE_NAME_FIELD_DESC);
        oprot.writeString(this.tableName);
         oprot.writeFieldEnd();
       }
       oprot.writeFieldStop();
       oprot.writeStructEnd();
     }
 
     @Override
     public String toString() {
      StringBuilder sb = new StringBuilder("describeTable_args(");
       boolean first = true;
 
      sb.append("tableName:");
      if (this.tableName == null) {
         sb.append("null");
       } else {
        sb.append(this.tableName);
       }
       first = false;
       sb.append(")");
       return sb.toString();
     }
 
     public void validate() throws TException {
       // check for required fields
       // check that fields of type enum have valid values
     }
 
   }
 
  public static class describeTable_result implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("describeTable_result");
     private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.MAP, (short)0);
     private static final TField NFE_FIELD_DESC = new TField("nfe", TType.STRUCT, (short)1);
 
     public Map<String,Map<String,String>> success;
     public static final int SUCCESS = 0;
     public NotFoundException nfe;
     public static final int NFE = 1;
 
     private final Isset __isset = new Isset();
     private static final class Isset implements java.io.Serializable {
     }
 
     public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
       put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
           new MapMetaData(TType.MAP, 
               new FieldValueMetaData(TType.STRING), 
               new MapMetaData(TType.MAP, 
                   new FieldValueMetaData(TType.STRING), 
                   new FieldValueMetaData(TType.STRING)))));
       put(NFE, new FieldMetaData("nfe", TFieldRequirementType.DEFAULT, 
           new FieldValueMetaData(TType.STRUCT)));
     }});
 
     static {
      FieldMetaData.addStructMetaDataMap(describeTable_result.class, metaDataMap);
     }
 
    public describeTable_result() {
     }
 
    public describeTable_result(
       Map<String,Map<String,String>> success,
       NotFoundException nfe)
     {
       this();
       this.success = success;
       this.nfe = nfe;
     }
 
     /**
      * Performs a deep copy on <i>other</i>.
      */
    public describeTable_result(describeTable_result other) {
       if (other.isSetSuccess()) {
         Map<String,Map<String,String>> __this__success = new HashMap<String,Map<String,String>>();
         for (Map.Entry<String, Map<String,String>> other_element : other.success.entrySet()) {
 
           String other_element_key = other_element.getKey();
           Map<String,String> other_element_value = other_element.getValue();
 
           String __this__success_copy_key = other_element_key;
 
           Map<String,String> __this__success_copy_value = new HashMap<String,String>();
           for (Map.Entry<String, String> other_element_value_element : other_element_value.entrySet()) {
 
             String other_element_value_element_key = other_element_value_element.getKey();
             String other_element_value_element_value = other_element_value_element.getValue();
 
             String __this__success_copy_value_copy_key = other_element_value_element_key;
 
             String __this__success_copy_value_copy_value = other_element_value_element_value;
 
             __this__success_copy_value.put(__this__success_copy_value_copy_key, __this__success_copy_value_copy_value);
           }
 
           __this__success.put(__this__success_copy_key, __this__success_copy_value);
         }
         this.success = __this__success;
       }
       if (other.isSetNfe()) {
         this.nfe = new NotFoundException(other.nfe);
       }
     }
 
     @Override
    public describeTable_result clone() {
      return new describeTable_result(this);
     }
 
     public int getSuccessSize() {
       return (this.success == null) ? 0 : this.success.size();
     }
 
     public void putToSuccess(String key, Map<String,String> val) {
       if (this.success == null) {
         this.success = new HashMap<String,Map<String,String>>();
       }
       this.success.put(key, val);
     }
 
     public Map<String,Map<String,String>> getSuccess() {
       return this.success;
     }
 
     public void setSuccess(Map<String,Map<String,String>> success) {
       this.success = success;
     }
 
     public void unsetSuccess() {
       this.success = null;
     }
 
     // Returns true if field success is set (has been asigned a value) and false otherwise
     public boolean isSetSuccess() {
       return this.success != null;
     }
 
     public void setSuccessIsSet(boolean value) {
       if (!value) {
         this.success = null;
       }
     }
 
     public NotFoundException getNfe() {
       return this.nfe;
     }
 
     public void setNfe(NotFoundException nfe) {
       this.nfe = nfe;
     }
 
     public void unsetNfe() {
       this.nfe = null;
     }
 
     // Returns true if field nfe is set (has been asigned a value) and false otherwise
     public boolean isSetNfe() {
       return this.nfe != null;
     }
 
     public void setNfeIsSet(boolean value) {
       if (!value) {
         this.nfe = null;
       }
     }
 
     public void setFieldValue(int fieldID, Object value) {
       switch (fieldID) {
       case SUCCESS:
         if (value == null) {
           unsetSuccess();
         } else {
           setSuccess((Map<String,Map<String,String>>)value);
         }
         break;
 
       case NFE:
         if (value == null) {
           unsetNfe();
         } else {
           setNfe((NotFoundException)value);
         }
         break;
 
       default:
         throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
       }
     }
 
     public Object getFieldValue(int fieldID) {
       switch (fieldID) {
       case SUCCESS:
         return getSuccess();
 
       case NFE:
         return getNfe();
 
       default:
         throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
       }
     }
 
     // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
     public boolean isSet(int fieldID) {
       switch (fieldID) {
       case SUCCESS:
         return isSetSuccess();
       case NFE:
         return isSetNfe();
       default:
         throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
       }
     }
 
     @Override
     public boolean equals(Object that) {
       if (that == null)
         return false;
      if (that instanceof describeTable_result)
        return this.equals((describeTable_result)that);
       return false;
     }
 
    public boolean equals(describeTable_result that) {
       if (that == null)
         return false;
 
       boolean this_present_success = true && this.isSetSuccess();
       boolean that_present_success = true && that.isSetSuccess();
       if (this_present_success || that_present_success) {
         if (!(this_present_success && that_present_success))
           return false;
         if (!this.success.equals(that.success))
           return false;
       }
 
       boolean this_present_nfe = true && this.isSetNfe();
       boolean that_present_nfe = true && that.isSetNfe();
       if (this_present_nfe || that_present_nfe) {
         if (!(this_present_nfe && that_present_nfe))
           return false;
         if (!this.nfe.equals(that.nfe))
           return false;
       }
 
       return true;
     }
 
     @Override
     public int hashCode() {
       return 0;
     }
 
     public void read(TProtocol iprot) throws TException {
       TField field;
       iprot.readStructBegin();
       while (true)
       {
         field = iprot.readFieldBegin();
         if (field.type == TType.STOP) { 
           break;
         }
         switch (field.id)
         {
           case SUCCESS:
             if (field.type == TType.MAP) {
               {
                 TMap _map63 = iprot.readMapBegin();
                 this.success = new HashMap<String,Map<String,String>>(2*_map63.size);
                 for (int _i64 = 0; _i64 < _map63.size; ++_i64)
                 {
                   String _key65;
                   Map<String,String> _val66;
                   _key65 = iprot.readString();
                   {
                     TMap _map67 = iprot.readMapBegin();
                     _val66 = new HashMap<String,String>(2*_map67.size);
                     for (int _i68 = 0; _i68 < _map67.size; ++_i68)
                     {
                       String _key69;
                       String _val70;
                       _key69 = iprot.readString();
                       _val70 = iprot.readString();
                       _val66.put(_key69, _val70);
                     }
                     iprot.readMapEnd();
                   }
                   this.success.put(_key65, _val66);
                 }
                 iprot.readMapEnd();
               }
             } else { 
               TProtocolUtil.skip(iprot, field.type);
             }
             break;
           case NFE:
             if (field.type == TType.STRUCT) {
               this.nfe = new NotFoundException();
               this.nfe.read(iprot);
             } else { 
               TProtocolUtil.skip(iprot, field.type);
             }
             break;
           default:
             TProtocolUtil.skip(iprot, field.type);
             break;
         }
         iprot.readFieldEnd();
       }
       iprot.readStructEnd();
 
 
       // check for required fields of primitive type, which can't be checked in the validate method
       validate();
     }
 
     public void write(TProtocol oprot) throws TException {
       oprot.writeStructBegin(STRUCT_DESC);
 
       if (this.isSetSuccess()) {
         oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
         {
           oprot.writeMapBegin(new TMap(TType.STRING, TType.MAP, this.success.size()));
           for (Map.Entry<String, Map<String,String>> _iter71 : this.success.entrySet())          {
             oprot.writeString(_iter71.getKey());
             {
               oprot.writeMapBegin(new TMap(TType.STRING, TType.STRING, _iter71.getValue().size()));
               for (Map.Entry<String, String> _iter72 : _iter71.getValue().entrySet())              {
                 oprot.writeString(_iter72.getKey());
                 oprot.writeString(_iter72.getValue());
               }
               oprot.writeMapEnd();
             }
           }
           oprot.writeMapEnd();
         }
         oprot.writeFieldEnd();
       } else if (this.isSetNfe()) {
         oprot.writeFieldBegin(NFE_FIELD_DESC);
         this.nfe.write(oprot);
         oprot.writeFieldEnd();
       }
       oprot.writeFieldStop();
       oprot.writeStructEnd();
     }
 
     @Override
     public String toString() {
      StringBuilder sb = new StringBuilder("describeTable_result(");
       boolean first = true;
 
       sb.append("success:");
       if (this.success == null) {
         sb.append("null");
       } else {
         sb.append(this.success);
       }
       first = false;
       if (!first) sb.append(", ");
       sb.append("nfe:");
       if (this.nfe == null) {
         sb.append("null");
       } else {
         sb.append(this.nfe);
       }
       first = false;
       sb.append(")");
       return sb.toString();
     }
 
     public void validate() throws TException {
       // check for required fields
       // check that fields of type enum have valid values
     }
 
   }
 
  public static class executeQuery_args implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("executeQuery_args");
     private static final TField QUERY_FIELD_DESC = new TField("query", TType.STRING, (short)1);
 
     public String query;
     public static final int QUERY = 1;
 
     private final Isset __isset = new Isset();
     private static final class Isset implements java.io.Serializable {
     }
 
     public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
       put(QUERY, new FieldMetaData("query", TFieldRequirementType.DEFAULT, 
           new FieldValueMetaData(TType.STRING)));
     }});
 
     static {
      FieldMetaData.addStructMetaDataMap(executeQuery_args.class, metaDataMap);
     }
 
    public executeQuery_args() {
     }
 
    public executeQuery_args(
       String query)
     {
       this();
       this.query = query;
     }
 
     /**
      * Performs a deep copy on <i>other</i>.
      */
    public executeQuery_args(executeQuery_args other) {
       if (other.isSetQuery()) {
         this.query = other.query;
       }
     }
 
     @Override
    public executeQuery_args clone() {
      return new executeQuery_args(this);
     }
 
     public String getQuery() {
       return this.query;
     }
 
     public void setQuery(String query) {
       this.query = query;
     }
 
     public void unsetQuery() {
       this.query = null;
     }
 
     // Returns true if field query is set (has been asigned a value) and false otherwise
     public boolean isSetQuery() {
       return this.query != null;
     }
 
     public void setQueryIsSet(boolean value) {
       if (!value) {
         this.query = null;
       }
     }
 
     public void setFieldValue(int fieldID, Object value) {
       switch (fieldID) {
       case QUERY:
         if (value == null) {
           unsetQuery();
         } else {
           setQuery((String)value);
         }
         break;
 
       default:
         throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
       }
     }
 
     public Object getFieldValue(int fieldID) {
       switch (fieldID) {
       case QUERY:
         return getQuery();
 
       default:
         throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
       }
     }
 
     // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
     public boolean isSet(int fieldID) {
       switch (fieldID) {
       case QUERY:
         return isSetQuery();
       default:
         throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
       }
     }
 
     @Override
     public boolean equals(Object that) {
       if (that == null)
         return false;
      if (that instanceof executeQuery_args)
        return this.equals((executeQuery_args)that);
       return false;
     }
 
    public boolean equals(executeQuery_args that) {
       if (that == null)
         return false;
 
       boolean this_present_query = true && this.isSetQuery();
       boolean that_present_query = true && that.isSetQuery();
       if (this_present_query || that_present_query) {
         if (!(this_present_query && that_present_query))
           return false;
         if (!this.query.equals(that.query))
           return false;
       }
 
       return true;
     }
 
     @Override
     public int hashCode() {
       return 0;
     }
 
     public void read(TProtocol iprot) throws TException {
       TField field;
       iprot.readStructBegin();
       while (true)
       {
         field = iprot.readFieldBegin();
         if (field.type == TType.STOP) { 
           break;
         }
         switch (field.id)
         {
           case QUERY:
             if (field.type == TType.STRING) {
               this.query = iprot.readString();
             } else { 
               TProtocolUtil.skip(iprot, field.type);
             }
             break;
           default:
             TProtocolUtil.skip(iprot, field.type);
             break;
         }
         iprot.readFieldEnd();
       }
       iprot.readStructEnd();
 
 
       // check for required fields of primitive type, which can't be checked in the validate method
       validate();
     }
 
     public void write(TProtocol oprot) throws TException {
       validate();
 
       oprot.writeStructBegin(STRUCT_DESC);
       if (this.query != null) {
         oprot.writeFieldBegin(QUERY_FIELD_DESC);
         oprot.writeString(this.query);
         oprot.writeFieldEnd();
       }
       oprot.writeFieldStop();
       oprot.writeStructEnd();
     }
 
     @Override
     public String toString() {
      StringBuilder sb = new StringBuilder("executeQuery_args(");
       boolean first = true;
 
       sb.append("query:");
       if (this.query == null) {
         sb.append("null");
       } else {
         sb.append(this.query);
       }
       first = false;
       sb.append(")");
       return sb.toString();
     }
 
     public void validate() throws TException {
       // check for required fields
       // check that fields of type enum have valid values
     }
 
   }
 
  public static class executeQuery_result implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("executeQuery_result");
     private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);
 
     public CqlResult success;
     public static final int SUCCESS = 0;
 
     private final Isset __isset = new Isset();
     private static final class Isset implements java.io.Serializable {
     }
 
     public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
       put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
           new StructMetaData(TType.STRUCT, CqlResult.class)));
     }});
 
     static {
      FieldMetaData.addStructMetaDataMap(executeQuery_result.class, metaDataMap);
     }
 
    public executeQuery_result() {
     }
 
    public executeQuery_result(
       CqlResult success)
     {
       this();
       this.success = success;
     }
 
     /**
      * Performs a deep copy on <i>other</i>.
      */
    public executeQuery_result(executeQuery_result other) {
       if (other.isSetSuccess()) {
         this.success = new CqlResult(other.success);
       }
     }
 
     @Override
    public executeQuery_result clone() {
      return new executeQuery_result(this);
     }
 
     public CqlResult getSuccess() {
       return this.success;
     }
 
     public void setSuccess(CqlResult success) {
       this.success = success;
     }
 
     public void unsetSuccess() {
       this.success = null;
     }
 
     // Returns true if field success is set (has been asigned a value) and false otherwise
     public boolean isSetSuccess() {
       return this.success != null;
     }
 
     public void setSuccessIsSet(boolean value) {
       if (!value) {
         this.success = null;
       }
     }
 
     public void setFieldValue(int fieldID, Object value) {
       switch (fieldID) {
       case SUCCESS:
         if (value == null) {
           unsetSuccess();
         } else {
           setSuccess((CqlResult)value);
         }
         break;
 
       default:
         throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
       }
     }
 
     public Object getFieldValue(int fieldID) {
       switch (fieldID) {
       case SUCCESS:
         return getSuccess();
 
       default:
         throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
       }
     }
 
     // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
     public boolean isSet(int fieldID) {
       switch (fieldID) {
       case SUCCESS:
         return isSetSuccess();
       default:
         throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
       }
     }
 
     @Override
     public boolean equals(Object that) {
       if (that == null)
         return false;
      if (that instanceof executeQuery_result)
        return this.equals((executeQuery_result)that);
       return false;
     }
 
    public boolean equals(executeQuery_result that) {
       if (that == null)
         return false;
 
       boolean this_present_success = true && this.isSetSuccess();
       boolean that_present_success = true && that.isSetSuccess();
       if (this_present_success || that_present_success) {
         if (!(this_present_success && that_present_success))
           return false;
         if (!this.success.equals(that.success))
           return false;
       }
 
       return true;
     }
 
     @Override
     public int hashCode() {
       return 0;
     }
 
     public void read(TProtocol iprot) throws TException {
       TField field;
       iprot.readStructBegin();
       while (true)
       {
         field = iprot.readFieldBegin();
         if (field.type == TType.STOP) { 
           break;
         }
         switch (field.id)
         {
           case SUCCESS:
             if (field.type == TType.STRUCT) {
               this.success = new CqlResult();
               this.success.read(iprot);
             } else { 
               TProtocolUtil.skip(iprot, field.type);
             }
             break;
           default:
             TProtocolUtil.skip(iprot, field.type);
             break;
         }
         iprot.readFieldEnd();
       }
       iprot.readStructEnd();
 
 
       // check for required fields of primitive type, which can't be checked in the validate method
       validate();
     }
 
     public void write(TProtocol oprot) throws TException {
       oprot.writeStructBegin(STRUCT_DESC);
 
       if (this.isSetSuccess()) {
         oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
         this.success.write(oprot);
         oprot.writeFieldEnd();
       }
       oprot.writeFieldStop();
       oprot.writeStructEnd();
     }
 
     @Override
     public String toString() {
      StringBuilder sb = new StringBuilder("executeQuery_result(");
       boolean first = true;
 
       sb.append("success:");
       if (this.success == null) {
         sb.append("null");
       } else {
         sb.append(this.success);
       }
       first = false;
       sb.append(")");
       return sb.toString();
     }
 
     public void validate() throws TException {
       // check for required fields
       // check that fields of type enum have valid values
     }
 
   }
 
 }
