 /**
  * Autogenerated by Thrift
  *
  * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
  */
 package org.apache.cassandra.service;
 
 import java.util.List;
 import java.util.ArrayList;
 import java.util.Map;
 import java.util.HashMap;
 import java.util.Set;
 import java.util.HashSet;
 import java.util.Collections;
 import org.apache.log4j.Logger;
 
 import org.apache.thrift.*;
 import org.apache.thrift.meta_data.*;
 import org.apache.thrift.protocol.*;
 
 public class SliceRange implements TBase, java.io.Serializable, Cloneable {
   private static final TStruct STRUCT_DESC = new TStruct("SliceRange");
   private static final TField START_FIELD_DESC = new TField("start", TType.STRING, (short)1);
   private static final TField FINISH_FIELD_DESC = new TField("finish", TType.STRING, (short)2);
   private static final TField IS_ASCENDING_FIELD_DESC = new TField("is_ascending", TType.BOOL, (short)3);
   private static final TField COUNT_FIELD_DESC = new TField("count", TType.I32, (short)4);
 
   public byte[] start;
   public static final int START = 1;
   public byte[] finish;
   public static final int FINISH = 2;
   public boolean is_ascending;
   public static final int IS_ASCENDING = 3;
   public int count;
   public static final int COUNT = 4;
 
   private final Isset __isset = new Isset();
   private static final class Isset implements java.io.Serializable {
     public boolean is_ascending = false;
     public boolean count = false;
   }
 
   public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
     put(START, new FieldMetaData("start", TFieldRequirementType.DEFAULT, 
         new FieldValueMetaData(TType.STRING)));
     put(FINISH, new FieldMetaData("finish", TFieldRequirementType.DEFAULT, 
         new FieldValueMetaData(TType.STRING)));
     put(IS_ASCENDING, new FieldMetaData("is_ascending", TFieldRequirementType.DEFAULT, 
         new FieldValueMetaData(TType.BOOL)));
     put(COUNT, new FieldMetaData("count", TFieldRequirementType.DEFAULT, 
         new FieldValueMetaData(TType.I32)));
   }});
 
   static {
     FieldMetaData.addStructMetaDataMap(SliceRange.class, metaDataMap);
   }
 
   public SliceRange() {
     this.is_ascending = true;
 
     this.count = 100;
 
   }
 
   public SliceRange(
     byte[] start,
     byte[] finish,
     boolean is_ascending,
     int count)
   {
     this();
     this.start = start;
     this.finish = finish;
     this.is_ascending = is_ascending;
     this.__isset.is_ascending = true;
     this.count = count;
     this.__isset.count = true;
   }
 
   /**
    * Performs a deep copy on <i>other</i>.
    */
   public SliceRange(SliceRange other) {
     if (other.isSetStart()) {
       this.start = new byte[other.start.length];
       System.arraycopy(other.start, 0, start, 0, other.start.length);
     }
     if (other.isSetFinish()) {
       this.finish = new byte[other.finish.length];
       System.arraycopy(other.finish, 0, finish, 0, other.finish.length);
     }
     __isset.is_ascending = other.__isset.is_ascending;
     this.is_ascending = other.is_ascending;
     __isset.count = other.__isset.count;
     this.count = other.count;
   }
 
   @Override
   public SliceRange clone() {
     return new SliceRange(this);
   }
 
   public byte[] getStart() {
     return this.start;
   }
 
  public SliceRange setStart(byte[] start) {
     this.start = start;
    return this;
   }
 
   public void unsetStart() {
     this.start = null;
   }
 
   // Returns true if field start is set (has been asigned a value) and false otherwise
   public boolean isSetStart() {
     return this.start != null;
   }
 
   public void setStartIsSet(boolean value) {
     if (!value) {
       this.start = null;
     }
   }
 
   public byte[] getFinish() {
     return this.finish;
   }
 
  public SliceRange setFinish(byte[] finish) {
     this.finish = finish;
    return this;
   }
 
   public void unsetFinish() {
     this.finish = null;
   }
 
   // Returns true if field finish is set (has been asigned a value) and false otherwise
   public boolean isSetFinish() {
     return this.finish != null;
   }
 
   public void setFinishIsSet(boolean value) {
     if (!value) {
       this.finish = null;
     }
   }
 
   public boolean isIs_ascending() {
     return this.is_ascending;
   }
 
  public SliceRange setIs_ascending(boolean is_ascending) {
     this.is_ascending = is_ascending;
     this.__isset.is_ascending = true;
    return this;
   }
 
   public void unsetIs_ascending() {
     this.__isset.is_ascending = false;
   }
 
   // Returns true if field is_ascending is set (has been asigned a value) and false otherwise
   public boolean isSetIs_ascending() {
     return this.__isset.is_ascending;
   }
 
   public void setIs_ascendingIsSet(boolean value) {
     this.__isset.is_ascending = value;
   }
 
   public int getCount() {
     return this.count;
   }
 
  public SliceRange setCount(int count) {
     this.count = count;
     this.__isset.count = true;
    return this;
   }
 
   public void unsetCount() {
     this.__isset.count = false;
   }
 
   // Returns true if field count is set (has been asigned a value) and false otherwise
   public boolean isSetCount() {
     return this.__isset.count;
   }
 
   public void setCountIsSet(boolean value) {
     this.__isset.count = value;
   }
 
   public void setFieldValue(int fieldID, Object value) {
     switch (fieldID) {
     case START:
       if (value == null) {
         unsetStart();
       } else {
         setStart((byte[])value);
       }
       break;
 
     case FINISH:
       if (value == null) {
         unsetFinish();
       } else {
         setFinish((byte[])value);
       }
       break;
 
     case IS_ASCENDING:
       if (value == null) {
         unsetIs_ascending();
       } else {
         setIs_ascending((Boolean)value);
       }
       break;
 
     case COUNT:
       if (value == null) {
         unsetCount();
       } else {
         setCount((Integer)value);
       }
       break;
 
     default:
       throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
     }
   }
 
   public Object getFieldValue(int fieldID) {
     switch (fieldID) {
     case START:
       return getStart();
 
     case FINISH:
       return getFinish();
 
     case IS_ASCENDING:
       return new Boolean(isIs_ascending());
 
     case COUNT:
       return new Integer(getCount());
 
     default:
       throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
     }
   }
 
   // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
   public boolean isSet(int fieldID) {
     switch (fieldID) {
     case START:
       return isSetStart();
     case FINISH:
       return isSetFinish();
     case IS_ASCENDING:
       return isSetIs_ascending();
     case COUNT:
       return isSetCount();
     default:
       throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
     }
   }
 
   @Override
   public boolean equals(Object that) {
     if (that == null)
       return false;
     if (that instanceof SliceRange)
       return this.equals((SliceRange)that);
     return false;
   }
 
   public boolean equals(SliceRange that) {
     if (that == null)
       return false;
 
     boolean this_present_start = true && this.isSetStart();
     boolean that_present_start = true && that.isSetStart();
     if (this_present_start || that_present_start) {
       if (!(this_present_start && that_present_start))
         return false;
       if (!java.util.Arrays.equals(this.start, that.start))
         return false;
     }
 
     boolean this_present_finish = true && this.isSetFinish();
     boolean that_present_finish = true && that.isSetFinish();
     if (this_present_finish || that_present_finish) {
       if (!(this_present_finish && that_present_finish))
         return false;
       if (!java.util.Arrays.equals(this.finish, that.finish))
         return false;
     }
 
     boolean this_present_is_ascending = true;
     boolean that_present_is_ascending = true;
     if (this_present_is_ascending || that_present_is_ascending) {
       if (!(this_present_is_ascending && that_present_is_ascending))
         return false;
       if (this.is_ascending != that.is_ascending)
         return false;
     }
 
     boolean this_present_count = true;
     boolean that_present_count = true;
     if (this_present_count || that_present_count) {
       if (!(this_present_count && that_present_count))
         return false;
       if (this.count != that.count)
         return false;
     }
 
     return true;
   }
 
   @Override
   public int hashCode() {
     return 0;
   }
 
   public void read(TProtocol iprot) throws TException {
     TField field;
     iprot.readStructBegin();
     while (true)
     {
       field = iprot.readFieldBegin();
       if (field.type == TType.STOP) { 
         break;
       }
       switch (field.id)
       {
         case START:
           if (field.type == TType.STRING) {
             this.start = iprot.readBinary();
           } else { 
             TProtocolUtil.skip(iprot, field.type);
           }
           break;
         case FINISH:
           if (field.type == TType.STRING) {
             this.finish = iprot.readBinary();
           } else { 
             TProtocolUtil.skip(iprot, field.type);
           }
           break;
         case IS_ASCENDING:
           if (field.type == TType.BOOL) {
             this.is_ascending = iprot.readBool();
             this.__isset.is_ascending = true;
           } else { 
             TProtocolUtil.skip(iprot, field.type);
           }
           break;
         case COUNT:
           if (field.type == TType.I32) {
             this.count = iprot.readI32();
             this.__isset.count = true;
           } else { 
             TProtocolUtil.skip(iprot, field.type);
           }
           break;
         default:
           TProtocolUtil.skip(iprot, field.type);
           break;
       }
       iprot.readFieldEnd();
     }
     iprot.readStructEnd();
 
 
     // check for required fields of primitive type, which can't be checked in the validate method
     validate();
   }
 
   public void write(TProtocol oprot) throws TException {
     validate();
 
     oprot.writeStructBegin(STRUCT_DESC);
     if (this.start != null) {
       oprot.writeFieldBegin(START_FIELD_DESC);
       oprot.writeBinary(this.start);
       oprot.writeFieldEnd();
     }
     if (this.finish != null) {
       oprot.writeFieldBegin(FINISH_FIELD_DESC);
       oprot.writeBinary(this.finish);
       oprot.writeFieldEnd();
     }
     oprot.writeFieldBegin(IS_ASCENDING_FIELD_DESC);
     oprot.writeBool(this.is_ascending);
     oprot.writeFieldEnd();
     oprot.writeFieldBegin(COUNT_FIELD_DESC);
     oprot.writeI32(this.count);
     oprot.writeFieldEnd();
     oprot.writeFieldStop();
     oprot.writeStructEnd();
   }
 
   @Override
   public String toString() {
     StringBuilder sb = new StringBuilder("SliceRange(");
     boolean first = true;
 
     sb.append("start:");
     if (this.start == null) {
       sb.append("null");
     } else {
         int __start_size = Math.min(this.start.length, 128);
         for (int i = 0; i < __start_size; i++) {
           if (i != 0) sb.append(" ");
           sb.append(Integer.toHexString(this.start[i]).length() > 1 ? Integer.toHexString(this.start[i]).substring(Integer.toHexString(this.start[i]).length() - 2).toUpperCase() : "0" + Integer.toHexString(this.start[i]).toUpperCase());
         }
         if (this.start.length > 128) sb.append(" ...");
     }
     first = false;
     if (!first) sb.append(", ");
     sb.append("finish:");
     if (this.finish == null) {
       sb.append("null");
     } else {
         int __finish_size = Math.min(this.finish.length, 128);
         for (int i = 0; i < __finish_size; i++) {
           if (i != 0) sb.append(" ");
           sb.append(Integer.toHexString(this.finish[i]).length() > 1 ? Integer.toHexString(this.finish[i]).substring(Integer.toHexString(this.finish[i]).length() - 2).toUpperCase() : "0" + Integer.toHexString(this.finish[i]).toUpperCase());
         }
         if (this.finish.length > 128) sb.append(" ...");
     }
     first = false;
     if (!first) sb.append(", ");
     sb.append("is_ascending:");
     sb.append(this.is_ascending);
     first = false;
     if (!first) sb.append(", ");
     sb.append("count:");
     sb.append(this.count);
     first = false;
     sb.append(")");
     return sb.toString();
   }
 
   public void validate() throws TException {
     // check for required fields
     // check that fields of type enum have valid values
   }
 
 }
 
