 /**
  * Autogenerated by Thrift
  *
  * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
  */
 package org.apache.cassandra.service;
 
 import java.util.List;
 import java.util.ArrayList;
 import java.util.Map;
 import java.util.HashMap;
 import java.util.Set;
 import java.util.HashSet;
 import java.util.Collections;
 import org.apache.log4j.Logger;
 
 import org.apache.thrift.*;
 import org.apache.thrift.meta_data.*;
 import org.apache.thrift.protocol.*;
 
 public class Cassandra {
 
   public interface Iface {
 
     public List<ColumnOrSuperColumn> get_slice(String keyspace, String key, ColumnParent column_parent, SlicePredicate predicate, int consistency_level) throws InvalidRequestException, NotFoundException, TException;
 
     public ColumnOrSuperColumn get(String keyspace, String key, ColumnPath column_path, int consistency_level) throws InvalidRequestException, NotFoundException, TException;
 
     public int get_count(String keyspace, String key, ColumnParent column_parent, int consistency_level) throws InvalidRequestException, TException;
 
     public void insert(String keyspace, String key, ColumnPath column_path, byte[] value, long timestamp, int consistency_level) throws InvalidRequestException, UnavailableException, TException;
 
     public void batch_insert(String keyspace, BatchMutation batch_mutation, int consistency_level) throws InvalidRequestException, UnavailableException, TException;
 
    public void remove(String keyspace, String key, ColumnPath column_path, long timestamp, int consistency_level) throws InvalidRequestException, UnavailableException, TException;
 
     public void batch_insert_super_column(String keyspace, BatchMutationSuper batch_mutation_super, int consistency_level) throws InvalidRequestException, UnavailableException, TException;
 
     public List<String> get_key_range(String keyspace, String column_family, String start, String finish, int count) throws InvalidRequestException, TException;
 
     public String get_string_property(String property) throws TException;
 
     public List<String> get_string_list_property(String property) throws TException;
 
     public Map<String,Map<String,String>> describe_keyspace(String keyspace) throws NotFoundException, TException;
 
   }
 
   public static class Client implements Iface {
     public Client(TProtocol prot)
     {
       this(prot, prot);
     }
 
     public Client(TProtocol iprot, TProtocol oprot)
     {
       iprot_ = iprot;
       oprot_ = oprot;
     }
 
     protected TProtocol iprot_;
     protected TProtocol oprot_;
 
     protected int seqid_;
 
     public TProtocol getInputProtocol()
     {
       return this.iprot_;
     }
 
     public TProtocol getOutputProtocol()
     {
       return this.oprot_;
     }
 
     public List<ColumnOrSuperColumn> get_slice(String keyspace, String key, ColumnParent column_parent, SlicePredicate predicate, int consistency_level) throws InvalidRequestException, NotFoundException, TException
     {
       send_get_slice(keyspace, key, column_parent, predicate, consistency_level);
       return recv_get_slice();
     }
 
     public void send_get_slice(String keyspace, String key, ColumnParent column_parent, SlicePredicate predicate, int consistency_level) throws TException
     {
       oprot_.writeMessageBegin(new TMessage("get_slice", TMessageType.CALL, seqid_));
       get_slice_args args = new get_slice_args();
       args.keyspace = keyspace;
       args.key = key;
       args.column_parent = column_parent;
       args.predicate = predicate;
       args.consistency_level = consistency_level;
       args.write(oprot_);
       oprot_.writeMessageEnd();
       oprot_.getTransport().flush();
     }
 
     public List<ColumnOrSuperColumn> recv_get_slice() throws InvalidRequestException, NotFoundException, TException
     {
       TMessage msg = iprot_.readMessageBegin();
       if (msg.type == TMessageType.EXCEPTION) {
         TApplicationException x = TApplicationException.read(iprot_);
         iprot_.readMessageEnd();
         throw x;
       }
       get_slice_result result = new get_slice_result();
       result.read(iprot_);
       iprot_.readMessageEnd();
       if (result.isSetSuccess()) {
         return result.success;
       }
       if (result.ire != null) {
         throw result.ire;
       }
       if (result.nfe != null) {
         throw result.nfe;
       }
       throw new TApplicationException(TApplicationException.MISSING_RESULT, "get_slice failed: unknown result");
     }
 
     public ColumnOrSuperColumn get(String keyspace, String key, ColumnPath column_path, int consistency_level) throws InvalidRequestException, NotFoundException, TException
     {
       send_get(keyspace, key, column_path, consistency_level);
       return recv_get();
     }
 
     public void send_get(String keyspace, String key, ColumnPath column_path, int consistency_level) throws TException
     {
       oprot_.writeMessageBegin(new TMessage("get", TMessageType.CALL, seqid_));
       get_args args = new get_args();
       args.keyspace = keyspace;
       args.key = key;
       args.column_path = column_path;
       args.consistency_level = consistency_level;
       args.write(oprot_);
       oprot_.writeMessageEnd();
       oprot_.getTransport().flush();
     }
 
     public ColumnOrSuperColumn recv_get() throws InvalidRequestException, NotFoundException, TException
     {
       TMessage msg = iprot_.readMessageBegin();
       if (msg.type == TMessageType.EXCEPTION) {
         TApplicationException x = TApplicationException.read(iprot_);
         iprot_.readMessageEnd();
         throw x;
       }
       get_result result = new get_result();
       result.read(iprot_);
       iprot_.readMessageEnd();
       if (result.isSetSuccess()) {
         return result.success;
       }
       if (result.ire != null) {
         throw result.ire;
       }
       if (result.nfe != null) {
         throw result.nfe;
       }
       throw new TApplicationException(TApplicationException.MISSING_RESULT, "get failed: unknown result");
     }
 
     public int get_count(String keyspace, String key, ColumnParent column_parent, int consistency_level) throws InvalidRequestException, TException
     {
       send_get_count(keyspace, key, column_parent, consistency_level);
       return recv_get_count();
     }
 
     public void send_get_count(String keyspace, String key, ColumnParent column_parent, int consistency_level) throws TException
     {
       oprot_.writeMessageBegin(new TMessage("get_count", TMessageType.CALL, seqid_));
       get_count_args args = new get_count_args();
       args.keyspace = keyspace;
       args.key = key;
       args.column_parent = column_parent;
       args.consistency_level = consistency_level;
       args.write(oprot_);
       oprot_.writeMessageEnd();
       oprot_.getTransport().flush();
     }
 
     public int recv_get_count() throws InvalidRequestException, TException
     {
       TMessage msg = iprot_.readMessageBegin();
       if (msg.type == TMessageType.EXCEPTION) {
         TApplicationException x = TApplicationException.read(iprot_);
         iprot_.readMessageEnd();
         throw x;
       }
       get_count_result result = new get_count_result();
       result.read(iprot_);
       iprot_.readMessageEnd();
       if (result.isSetSuccess()) {
         return result.success;
       }
       if (result.ire != null) {
         throw result.ire;
       }
       throw new TApplicationException(TApplicationException.MISSING_RESULT, "get_count failed: unknown result");
     }
 
     public void insert(String keyspace, String key, ColumnPath column_path, byte[] value, long timestamp, int consistency_level) throws InvalidRequestException, UnavailableException, TException
     {
       send_insert(keyspace, key, column_path, value, timestamp, consistency_level);
       recv_insert();
     }
 
     public void send_insert(String keyspace, String key, ColumnPath column_path, byte[] value, long timestamp, int consistency_level) throws TException
     {
       oprot_.writeMessageBegin(new TMessage("insert", TMessageType.CALL, seqid_));
       insert_args args = new insert_args();
       args.keyspace = keyspace;
       args.key = key;
       args.column_path = column_path;
       args.value = value;
       args.timestamp = timestamp;
       args.consistency_level = consistency_level;
       args.write(oprot_);
       oprot_.writeMessageEnd();
       oprot_.getTransport().flush();
     }
 
     public void recv_insert() throws InvalidRequestException, UnavailableException, TException
     {
       TMessage msg = iprot_.readMessageBegin();
       if (msg.type == TMessageType.EXCEPTION) {
         TApplicationException x = TApplicationException.read(iprot_);
         iprot_.readMessageEnd();
         throw x;
       }
       insert_result result = new insert_result();
       result.read(iprot_);
       iprot_.readMessageEnd();
       if (result.ire != null) {
         throw result.ire;
       }
       if (result.ue != null) {
         throw result.ue;
       }
       return;
     }
 
     public void batch_insert(String keyspace, BatchMutation batch_mutation, int consistency_level) throws InvalidRequestException, UnavailableException, TException
     {
       send_batch_insert(keyspace, batch_mutation, consistency_level);
       recv_batch_insert();
     }
 
     public void send_batch_insert(String keyspace, BatchMutation batch_mutation, int consistency_level) throws TException
     {
       oprot_.writeMessageBegin(new TMessage("batch_insert", TMessageType.CALL, seqid_));
       batch_insert_args args = new batch_insert_args();
       args.keyspace = keyspace;
       args.batch_mutation = batch_mutation;
       args.consistency_level = consistency_level;
       args.write(oprot_);
       oprot_.writeMessageEnd();
       oprot_.getTransport().flush();
     }
 
     public void recv_batch_insert() throws InvalidRequestException, UnavailableException, TException
     {
       TMessage msg = iprot_.readMessageBegin();
       if (msg.type == TMessageType.EXCEPTION) {
         TApplicationException x = TApplicationException.read(iprot_);
         iprot_.readMessageEnd();
         throw x;
       }
       batch_insert_result result = new batch_insert_result();
       result.read(iprot_);
       iprot_.readMessageEnd();
       if (result.ire != null) {
         throw result.ire;
       }
       if (result.ue != null) {
         throw result.ue;
       }
       return;
     }
 
    public void remove(String keyspace, String key, ColumnPath column_path, long timestamp, int consistency_level) throws InvalidRequestException, UnavailableException, TException
     {
      send_remove(keyspace, key, column_path, timestamp, consistency_level);
       recv_remove();
     }
 
    public void send_remove(String keyspace, String key, ColumnPath column_path, long timestamp, int consistency_level) throws TException
     {
       oprot_.writeMessageBegin(new TMessage("remove", TMessageType.CALL, seqid_));
       remove_args args = new remove_args();
       args.keyspace = keyspace;
       args.key = key;
      args.column_path = column_path;
       args.timestamp = timestamp;
       args.consistency_level = consistency_level;
       args.write(oprot_);
       oprot_.writeMessageEnd();
       oprot_.getTransport().flush();
     }
 
     public void recv_remove() throws InvalidRequestException, UnavailableException, TException
     {
       TMessage msg = iprot_.readMessageBegin();
       if (msg.type == TMessageType.EXCEPTION) {
         TApplicationException x = TApplicationException.read(iprot_);
         iprot_.readMessageEnd();
         throw x;
       }
       remove_result result = new remove_result();
       result.read(iprot_);
       iprot_.readMessageEnd();
       if (result.ire != null) {
         throw result.ire;
       }
       if (result.ue != null) {
         throw result.ue;
       }
       return;
     }
 
     public void batch_insert_super_column(String keyspace, BatchMutationSuper batch_mutation_super, int consistency_level) throws InvalidRequestException, UnavailableException, TException
     {
       send_batch_insert_super_column(keyspace, batch_mutation_super, consistency_level);
       recv_batch_insert_super_column();
     }
 
     public void send_batch_insert_super_column(String keyspace, BatchMutationSuper batch_mutation_super, int consistency_level) throws TException
     {
       oprot_.writeMessageBegin(new TMessage("batch_insert_super_column", TMessageType.CALL, seqid_));
       batch_insert_super_column_args args = new batch_insert_super_column_args();
       args.keyspace = keyspace;
       args.batch_mutation_super = batch_mutation_super;
       args.consistency_level = consistency_level;
       args.write(oprot_);
       oprot_.writeMessageEnd();
       oprot_.getTransport().flush();
     }
 
     public void recv_batch_insert_super_column() throws InvalidRequestException, UnavailableException, TException
     {
       TMessage msg = iprot_.readMessageBegin();
       if (msg.type == TMessageType.EXCEPTION) {
         TApplicationException x = TApplicationException.read(iprot_);
         iprot_.readMessageEnd();
         throw x;
       }
       batch_insert_super_column_result result = new batch_insert_super_column_result();
       result.read(iprot_);
       iprot_.readMessageEnd();
       if (result.ire != null) {
         throw result.ire;
       }
       if (result.ue != null) {
         throw result.ue;
       }
       return;
     }
 
     public List<String> get_key_range(String keyspace, String column_family, String start, String finish, int count) throws InvalidRequestException, TException
     {
       send_get_key_range(keyspace, column_family, start, finish, count);
       return recv_get_key_range();
     }
 
     public void send_get_key_range(String keyspace, String column_family, String start, String finish, int count) throws TException
     {
       oprot_.writeMessageBegin(new TMessage("get_key_range", TMessageType.CALL, seqid_));
       get_key_range_args args = new get_key_range_args();
       args.keyspace = keyspace;
       args.column_family = column_family;
       args.start = start;
       args.finish = finish;
       args.count = count;
       args.write(oprot_);
       oprot_.writeMessageEnd();
       oprot_.getTransport().flush();
     }
 
     public List<String> recv_get_key_range() throws InvalidRequestException, TException
     {
       TMessage msg = iprot_.readMessageBegin();
       if (msg.type == TMessageType.EXCEPTION) {
         TApplicationException x = TApplicationException.read(iprot_);
         iprot_.readMessageEnd();
         throw x;
       }
       get_key_range_result result = new get_key_range_result();
       result.read(iprot_);
       iprot_.readMessageEnd();
       if (result.isSetSuccess()) {
         return result.success;
       }
       if (result.ire != null) {
         throw result.ire;
       }
       throw new TApplicationException(TApplicationException.MISSING_RESULT, "get_key_range failed: unknown result");
     }
 
     public String get_string_property(String property) throws TException
     {
       send_get_string_property(property);
       return recv_get_string_property();
     }
 
     public void send_get_string_property(String property) throws TException
     {
       oprot_.writeMessageBegin(new TMessage("get_string_property", TMessageType.CALL, seqid_));
       get_string_property_args args = new get_string_property_args();
       args.property = property;
       args.write(oprot_);
       oprot_.writeMessageEnd();
       oprot_.getTransport().flush();
     }
 
     public String recv_get_string_property() throws TException
     {
       TMessage msg = iprot_.readMessageBegin();
       if (msg.type == TMessageType.EXCEPTION) {
         TApplicationException x = TApplicationException.read(iprot_);
         iprot_.readMessageEnd();
         throw x;
       }
       get_string_property_result result = new get_string_property_result();
       result.read(iprot_);
       iprot_.readMessageEnd();
       if (result.isSetSuccess()) {
         return result.success;
       }
       throw new TApplicationException(TApplicationException.MISSING_RESULT, "get_string_property failed: unknown result");
     }
 
     public List<String> get_string_list_property(String property) throws TException
     {
       send_get_string_list_property(property);
       return recv_get_string_list_property();
     }
 
     public void send_get_string_list_property(String property) throws TException
     {
       oprot_.writeMessageBegin(new TMessage("get_string_list_property", TMessageType.CALL, seqid_));
       get_string_list_property_args args = new get_string_list_property_args();
       args.property = property;
       args.write(oprot_);
       oprot_.writeMessageEnd();
       oprot_.getTransport().flush();
     }
 
     public List<String> recv_get_string_list_property() throws TException
     {
       TMessage msg = iprot_.readMessageBegin();
       if (msg.type == TMessageType.EXCEPTION) {
         TApplicationException x = TApplicationException.read(iprot_);
         iprot_.readMessageEnd();
         throw x;
       }
       get_string_list_property_result result = new get_string_list_property_result();
       result.read(iprot_);
       iprot_.readMessageEnd();
       if (result.isSetSuccess()) {
         return result.success;
       }
       throw new TApplicationException(TApplicationException.MISSING_RESULT, "get_string_list_property failed: unknown result");
     }
 
     public Map<String,Map<String,String>> describe_keyspace(String keyspace) throws NotFoundException, TException
     {
       send_describe_keyspace(keyspace);
       return recv_describe_keyspace();
     }
 
     public void send_describe_keyspace(String keyspace) throws TException
     {
       oprot_.writeMessageBegin(new TMessage("describe_keyspace", TMessageType.CALL, seqid_));
       describe_keyspace_args args = new describe_keyspace_args();
       args.keyspace = keyspace;
       args.write(oprot_);
       oprot_.writeMessageEnd();
       oprot_.getTransport().flush();
     }
 
     public Map<String,Map<String,String>> recv_describe_keyspace() throws NotFoundException, TException
     {
       TMessage msg = iprot_.readMessageBegin();
       if (msg.type == TMessageType.EXCEPTION) {
         TApplicationException x = TApplicationException.read(iprot_);
         iprot_.readMessageEnd();
         throw x;
       }
       describe_keyspace_result result = new describe_keyspace_result();
       result.read(iprot_);
       iprot_.readMessageEnd();
       if (result.isSetSuccess()) {
         return result.success;
       }
       if (result.nfe != null) {
         throw result.nfe;
       }
       throw new TApplicationException(TApplicationException.MISSING_RESULT, "describe_keyspace failed: unknown result");
     }
 
   }
   public static class Processor implements TProcessor {
     private static final Logger LOGGER = Logger.getLogger(Processor.class.getName());
     public Processor(Iface iface)
     {
       iface_ = iface;
       processMap_.put("get_slice", new get_slice());
       processMap_.put("get", new get());
       processMap_.put("get_count", new get_count());
       processMap_.put("insert", new insert());
       processMap_.put("batch_insert", new batch_insert());
       processMap_.put("remove", new remove());
       processMap_.put("batch_insert_super_column", new batch_insert_super_column());
       processMap_.put("get_key_range", new get_key_range());
       processMap_.put("get_string_property", new get_string_property());
       processMap_.put("get_string_list_property", new get_string_list_property());
       processMap_.put("describe_keyspace", new describe_keyspace());
     }
 
     protected static interface ProcessFunction {
       public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException;
     }
 
     private Iface iface_;
     protected final HashMap<String,ProcessFunction> processMap_ = new HashMap<String,ProcessFunction>();
 
     public boolean process(TProtocol iprot, TProtocol oprot) throws TException
     {
       TMessage msg = iprot.readMessageBegin();
       ProcessFunction fn = processMap_.get(msg.name);
       if (fn == null) {
         TProtocolUtil.skip(iprot, TType.STRUCT);
         iprot.readMessageEnd();
         TApplicationException x = new TApplicationException(TApplicationException.UNKNOWN_METHOD, "Invalid method name: '"+msg.name+"'");
         oprot.writeMessageBegin(new TMessage(msg.name, TMessageType.EXCEPTION, msg.seqid));
         x.write(oprot);
         oprot.writeMessageEnd();
         oprot.getTransport().flush();
         return true;
       }
       fn.process(msg.seqid, iprot, oprot);
       return true;
     }
 
     private class get_slice implements ProcessFunction {
       public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
       {
         get_slice_args args = new get_slice_args();
         args.read(iprot);
         iprot.readMessageEnd();
         get_slice_result result = new get_slice_result();
         try {
           result.success = iface_.get_slice(args.keyspace, args.key, args.column_parent, args.predicate, args.consistency_level);
         } catch (InvalidRequestException ire) {
           result.ire = ire;
         } catch (NotFoundException nfe) {
           result.nfe = nfe;
         } catch (Throwable th) {
           LOGGER.error("Internal error processing get_slice", th);
           TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing get_slice");
           oprot.writeMessageBegin(new TMessage("get_slice", TMessageType.EXCEPTION, seqid));
           x.write(oprot);
           oprot.writeMessageEnd();
           oprot.getTransport().flush();
           return;
         }
         oprot.writeMessageBegin(new TMessage("get_slice", TMessageType.REPLY, seqid));
         result.write(oprot);
         oprot.writeMessageEnd();
         oprot.getTransport().flush();
       }
 
     }
 
     private class get implements ProcessFunction {
       public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
       {
         get_args args = new get_args();
         args.read(iprot);
         iprot.readMessageEnd();
         get_result result = new get_result();
         try {
           result.success = iface_.get(args.keyspace, args.key, args.column_path, args.consistency_level);
         } catch (InvalidRequestException ire) {
           result.ire = ire;
         } catch (NotFoundException nfe) {
           result.nfe = nfe;
         } catch (Throwable th) {
           LOGGER.error("Internal error processing get", th);
           TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing get");
           oprot.writeMessageBegin(new TMessage("get", TMessageType.EXCEPTION, seqid));
           x.write(oprot);
           oprot.writeMessageEnd();
           oprot.getTransport().flush();
           return;
         }
         oprot.writeMessageBegin(new TMessage("get", TMessageType.REPLY, seqid));
         result.write(oprot);
         oprot.writeMessageEnd();
         oprot.getTransport().flush();
       }
 
     }
 
     private class get_count implements ProcessFunction {
       public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
       {
         get_count_args args = new get_count_args();
         args.read(iprot);
         iprot.readMessageEnd();
         get_count_result result = new get_count_result();
         try {
           result.success = iface_.get_count(args.keyspace, args.key, args.column_parent, args.consistency_level);
           result.__isset.success = true;
         } catch (InvalidRequestException ire) {
           result.ire = ire;
         } catch (Throwable th) {
           LOGGER.error("Internal error processing get_count", th);
           TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing get_count");
           oprot.writeMessageBegin(new TMessage("get_count", TMessageType.EXCEPTION, seqid));
           x.write(oprot);
           oprot.writeMessageEnd();
           oprot.getTransport().flush();
           return;
         }
         oprot.writeMessageBegin(new TMessage("get_count", TMessageType.REPLY, seqid));
         result.write(oprot);
         oprot.writeMessageEnd();
         oprot.getTransport().flush();
       }
 
     }
 
     private class insert implements ProcessFunction {
       public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
       {
         insert_args args = new insert_args();
         args.read(iprot);
         iprot.readMessageEnd();
         insert_result result = new insert_result();
         try {
           iface_.insert(args.keyspace, args.key, args.column_path, args.value, args.timestamp, args.consistency_level);
         } catch (InvalidRequestException ire) {
           result.ire = ire;
         } catch (UnavailableException ue) {
           result.ue = ue;
         } catch (Throwable th) {
           LOGGER.error("Internal error processing insert", th);
           TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing insert");
           oprot.writeMessageBegin(new TMessage("insert", TMessageType.EXCEPTION, seqid));
           x.write(oprot);
           oprot.writeMessageEnd();
           oprot.getTransport().flush();
           return;
         }
         oprot.writeMessageBegin(new TMessage("insert", TMessageType.REPLY, seqid));
         result.write(oprot);
         oprot.writeMessageEnd();
         oprot.getTransport().flush();
       }
 
     }
 
     private class batch_insert implements ProcessFunction {
       public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
       {
         batch_insert_args args = new batch_insert_args();
         args.read(iprot);
         iprot.readMessageEnd();
         batch_insert_result result = new batch_insert_result();
         try {
           iface_.batch_insert(args.keyspace, args.batch_mutation, args.consistency_level);
         } catch (InvalidRequestException ire) {
           result.ire = ire;
         } catch (UnavailableException ue) {
           result.ue = ue;
         } catch (Throwable th) {
           LOGGER.error("Internal error processing batch_insert", th);
           TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing batch_insert");
           oprot.writeMessageBegin(new TMessage("batch_insert", TMessageType.EXCEPTION, seqid));
           x.write(oprot);
           oprot.writeMessageEnd();
           oprot.getTransport().flush();
           return;
         }
         oprot.writeMessageBegin(new TMessage("batch_insert", TMessageType.REPLY, seqid));
         result.write(oprot);
         oprot.writeMessageEnd();
         oprot.getTransport().flush();
       }
 
     }
 
     private class remove implements ProcessFunction {
       public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
       {
         remove_args args = new remove_args();
         args.read(iprot);
         iprot.readMessageEnd();
         remove_result result = new remove_result();
         try {
          iface_.remove(args.keyspace, args.key, args.column_path, args.timestamp, args.consistency_level);
         } catch (InvalidRequestException ire) {
           result.ire = ire;
         } catch (UnavailableException ue) {
           result.ue = ue;
         } catch (Throwable th) {
           LOGGER.error("Internal error processing remove", th);
           TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing remove");
           oprot.writeMessageBegin(new TMessage("remove", TMessageType.EXCEPTION, seqid));
           x.write(oprot);
           oprot.writeMessageEnd();
           oprot.getTransport().flush();
           return;
         }
         oprot.writeMessageBegin(new TMessage("remove", TMessageType.REPLY, seqid));
         result.write(oprot);
         oprot.writeMessageEnd();
         oprot.getTransport().flush();
       }
 
     }
 
     private class batch_insert_super_column implements ProcessFunction {
       public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
       {
         batch_insert_super_column_args args = new batch_insert_super_column_args();
         args.read(iprot);
         iprot.readMessageEnd();
         batch_insert_super_column_result result = new batch_insert_super_column_result();
         try {
           iface_.batch_insert_super_column(args.keyspace, args.batch_mutation_super, args.consistency_level);
         } catch (InvalidRequestException ire) {
           result.ire = ire;
         } catch (UnavailableException ue) {
           result.ue = ue;
         } catch (Throwable th) {
           LOGGER.error("Internal error processing batch_insert_super_column", th);
           TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing batch_insert_super_column");
           oprot.writeMessageBegin(new TMessage("batch_insert_super_column", TMessageType.EXCEPTION, seqid));
           x.write(oprot);
           oprot.writeMessageEnd();
           oprot.getTransport().flush();
           return;
         }
         oprot.writeMessageBegin(new TMessage("batch_insert_super_column", TMessageType.REPLY, seqid));
         result.write(oprot);
         oprot.writeMessageEnd();
         oprot.getTransport().flush();
       }
 
     }
 
     private class get_key_range implements ProcessFunction {
       public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
       {
         get_key_range_args args = new get_key_range_args();
         args.read(iprot);
         iprot.readMessageEnd();
         get_key_range_result result = new get_key_range_result();
         try {
           result.success = iface_.get_key_range(args.keyspace, args.column_family, args.start, args.finish, args.count);
         } catch (InvalidRequestException ire) {
           result.ire = ire;
         } catch (Throwable th) {
           LOGGER.error("Internal error processing get_key_range", th);
           TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing get_key_range");
           oprot.writeMessageBegin(new TMessage("get_key_range", TMessageType.EXCEPTION, seqid));
           x.write(oprot);
           oprot.writeMessageEnd();
           oprot.getTransport().flush();
           return;
         }
         oprot.writeMessageBegin(new TMessage("get_key_range", TMessageType.REPLY, seqid));
         result.write(oprot);
         oprot.writeMessageEnd();
         oprot.getTransport().flush();
       }
 
     }
 
     private class get_string_property implements ProcessFunction {
       public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
       {
         get_string_property_args args = new get_string_property_args();
         args.read(iprot);
         iprot.readMessageEnd();
         get_string_property_result result = new get_string_property_result();
         result.success = iface_.get_string_property(args.property);
         oprot.writeMessageBegin(new TMessage("get_string_property", TMessageType.REPLY, seqid));
         result.write(oprot);
         oprot.writeMessageEnd();
         oprot.getTransport().flush();
       }
 
     }
 
     private class get_string_list_property implements ProcessFunction {
       public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
       {
         get_string_list_property_args args = new get_string_list_property_args();
         args.read(iprot);
         iprot.readMessageEnd();
         get_string_list_property_result result = new get_string_list_property_result();
         result.success = iface_.get_string_list_property(args.property);
         oprot.writeMessageBegin(new TMessage("get_string_list_property", TMessageType.REPLY, seqid));
         result.write(oprot);
         oprot.writeMessageEnd();
         oprot.getTransport().flush();
       }
 
     }
 
     private class describe_keyspace implements ProcessFunction {
       public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
       {
         describe_keyspace_args args = new describe_keyspace_args();
         args.read(iprot);
         iprot.readMessageEnd();
         describe_keyspace_result result = new describe_keyspace_result();
         try {
           result.success = iface_.describe_keyspace(args.keyspace);
         } catch (NotFoundException nfe) {
           result.nfe = nfe;
         } catch (Throwable th) {
           LOGGER.error("Internal error processing describe_keyspace", th);
           TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing describe_keyspace");
           oprot.writeMessageBegin(new TMessage("describe_keyspace", TMessageType.EXCEPTION, seqid));
           x.write(oprot);
           oprot.writeMessageEnd();
           oprot.getTransport().flush();
           return;
         }
         oprot.writeMessageBegin(new TMessage("describe_keyspace", TMessageType.REPLY, seqid));
         result.write(oprot);
         oprot.writeMessageEnd();
         oprot.getTransport().flush();
       }
 
     }
 
   }
 
   public static class get_slice_args implements TBase, java.io.Serializable, Cloneable   {
     private static final TStruct STRUCT_DESC = new TStruct("get_slice_args");
     private static final TField KEYSPACE_FIELD_DESC = new TField("keyspace", TType.STRING, (short)1);
     private static final TField KEY_FIELD_DESC = new TField("key", TType.STRING, (short)2);
     private static final TField COLUMN_PARENT_FIELD_DESC = new TField("column_parent", TType.STRUCT, (short)3);
     private static final TField PREDICATE_FIELD_DESC = new TField("predicate", TType.STRUCT, (short)4);
     private static final TField CONSISTENCY_LEVEL_FIELD_DESC = new TField("consistency_level", TType.I32, (short)5);
 
     public String keyspace;
     public static final int KEYSPACE = 1;
     public String key;
     public static final int KEY = 2;
     public ColumnParent column_parent;
     public static final int COLUMN_PARENT = 3;
     public SlicePredicate predicate;
     public static final int PREDICATE = 4;
    /**
     * 
     * @see ConsistencyLevel
     */
     public int consistency_level;
     public static final int CONSISTENCY_LEVEL = 5;
 
     private final Isset __isset = new Isset();
     private static final class Isset implements java.io.Serializable {
       public boolean consistency_level = false;
     }
 
     public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
       put(KEYSPACE, new FieldMetaData("keyspace", TFieldRequirementType.DEFAULT, 
           new FieldValueMetaData(TType.STRING)));
       put(KEY, new FieldMetaData("key", TFieldRequirementType.DEFAULT, 
           new FieldValueMetaData(TType.STRING)));
       put(COLUMN_PARENT, new FieldMetaData("column_parent", TFieldRequirementType.DEFAULT, 
           new StructMetaData(TType.STRUCT, ColumnParent.class)));
       put(PREDICATE, new FieldMetaData("predicate", TFieldRequirementType.DEFAULT, 
           new StructMetaData(TType.STRUCT, SlicePredicate.class)));
       put(CONSISTENCY_LEVEL, new FieldMetaData("consistency_level", TFieldRequirementType.DEFAULT, 
           new FieldValueMetaData(TType.I32)));
     }});
 
     static {
       FieldMetaData.addStructMetaDataMap(get_slice_args.class, metaDataMap);
     }
 
     public get_slice_args() {
       this.consistency_level = 1;
 
     }
 
     public get_slice_args(
       String keyspace,
       String key,
       ColumnParent column_parent,
       SlicePredicate predicate,
       int consistency_level)
     {
       this();
       this.keyspace = keyspace;
       this.key = key;
       this.column_parent = column_parent;
       this.predicate = predicate;
       this.consistency_level = consistency_level;
       this.__isset.consistency_level = true;
     }
 
     /**
      * Performs a deep copy on <i>other</i>.
      */
     public get_slice_args(get_slice_args other) {
       if (other.isSetKeyspace()) {
         this.keyspace = other.keyspace;
       }
       if (other.isSetKey()) {
         this.key = other.key;
       }
       if (other.isSetColumn_parent()) {
         this.column_parent = new ColumnParent(other.column_parent);
       }
       if (other.isSetPredicate()) {
         this.predicate = new SlicePredicate(other.predicate);
       }
       __isset.consistency_level = other.__isset.consistency_level;
       this.consistency_level = other.consistency_level;
     }
 
     @Override
     public get_slice_args clone() {
       return new get_slice_args(this);
     }
 
     public String getKeyspace() {
       return this.keyspace;
     }
 
    public get_slice_args setKeyspace(String keyspace) {
       this.keyspace = keyspace;
      return this;
     }
 
     public void unsetKeyspace() {
       this.keyspace = null;
     }
 
     // Returns true if field keyspace is set (has been asigned a value) and false otherwise
     public boolean isSetKeyspace() {
       return this.keyspace != null;
     }
 
     public void setKeyspaceIsSet(boolean value) {
       if (!value) {
         this.keyspace = null;
       }
     }
 
     public String getKey() {
       return this.key;
     }
 
    public get_slice_args setKey(String key) {
       this.key = key;
      return this;
     }
 
     public void unsetKey() {
       this.key = null;
     }
 
     // Returns true if field key is set (has been asigned a value) and false otherwise
     public boolean isSetKey() {
       return this.key != null;
     }
 
     public void setKeyIsSet(boolean value) {
       if (!value) {
         this.key = null;
       }
     }
 
     public ColumnParent getColumn_parent() {
       return this.column_parent;
     }
 
    public get_slice_args setColumn_parent(ColumnParent column_parent) {
       this.column_parent = column_parent;
      return this;
     }
 
     public void unsetColumn_parent() {
       this.column_parent = null;
     }
 
     // Returns true if field column_parent is set (has been asigned a value) and false otherwise
     public boolean isSetColumn_parent() {
       return this.column_parent != null;
     }
 
     public void setColumn_parentIsSet(boolean value) {
       if (!value) {
         this.column_parent = null;
       }
     }
 
     public SlicePredicate getPredicate() {
       return this.predicate;
     }
 
    public get_slice_args setPredicate(SlicePredicate predicate) {
       this.predicate = predicate;
      return this;
     }
 
     public void unsetPredicate() {
       this.predicate = null;
     }
 
     // Returns true if field predicate is set (has been asigned a value) and false otherwise
     public boolean isSetPredicate() {
       return this.predicate != null;
     }
 
     public void setPredicateIsSet(boolean value) {
       if (!value) {
         this.predicate = null;
       }
     }
 
    /**
     * 
     * @see ConsistencyLevel
     */
     public int getConsistency_level() {
       return this.consistency_level;
     }
 
    /**
     * 
     * @see ConsistencyLevel
     */
    public get_slice_args setConsistency_level(int consistency_level) {
       this.consistency_level = consistency_level;
       this.__isset.consistency_level = true;
      return this;
     }
 
     public void unsetConsistency_level() {
       this.__isset.consistency_level = false;
     }
 
     // Returns true if field consistency_level is set (has been asigned a value) and false otherwise
     public boolean isSetConsistency_level() {
       return this.__isset.consistency_level;
     }
 
     public void setConsistency_levelIsSet(boolean value) {
       this.__isset.consistency_level = value;
     }
 
     public void setFieldValue(int fieldID, Object value) {
       switch (fieldID) {
       case KEYSPACE:
         if (value == null) {
           unsetKeyspace();
         } else {
           setKeyspace((String)value);
         }
         break;
 
       case KEY:
         if (value == null) {
           unsetKey();
         } else {
           setKey((String)value);
         }
         break;
 
       case COLUMN_PARENT:
         if (value == null) {
           unsetColumn_parent();
         } else {
           setColumn_parent((ColumnParent)value);
         }
         break;
 
       case PREDICATE:
         if (value == null) {
           unsetPredicate();
         } else {
           setPredicate((SlicePredicate)value);
         }
         break;
 
       case CONSISTENCY_LEVEL:
         if (value == null) {
           unsetConsistency_level();
         } else {
           setConsistency_level((Integer)value);
         }
         break;
 
       default:
         throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
       }
     }
 
     public Object getFieldValue(int fieldID) {
       switch (fieldID) {
       case KEYSPACE:
         return getKeyspace();
 
       case KEY:
         return getKey();
 
       case COLUMN_PARENT:
         return getColumn_parent();
 
       case PREDICATE:
         return getPredicate();
 
       case CONSISTENCY_LEVEL:
         return getConsistency_level();
 
       default:
         throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
       }
     }
 
     // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
     public boolean isSet(int fieldID) {
       switch (fieldID) {
       case KEYSPACE:
         return isSetKeyspace();
       case KEY:
         return isSetKey();
       case COLUMN_PARENT:
         return isSetColumn_parent();
       case PREDICATE:
         return isSetPredicate();
       case CONSISTENCY_LEVEL:
         return isSetConsistency_level();
       default:
         throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
       }
     }
 
     @Override
     public boolean equals(Object that) {
       if (that == null)
         return false;
       if (that instanceof get_slice_args)
         return this.equals((get_slice_args)that);
       return false;
     }
 
     public boolean equals(get_slice_args that) {
       if (that == null)
         return false;
 
       boolean this_present_keyspace = true && this.isSetKeyspace();
       boolean that_present_keyspace = true && that.isSetKeyspace();
       if (this_present_keyspace || that_present_keyspace) {
         if (!(this_present_keyspace && that_present_keyspace))
           return false;
         if (!this.keyspace.equals(that.keyspace))
           return false;
       }
 
       boolean this_present_key = true && this.isSetKey();
       boolean that_present_key = true && that.isSetKey();
       if (this_present_key || that_present_key) {
         if (!(this_present_key && that_present_key))
           return false;
         if (!this.key.equals(that.key))
           return false;
       }
 
       boolean this_present_column_parent = true && this.isSetColumn_parent();
       boolean that_present_column_parent = true && that.isSetColumn_parent();
       if (this_present_column_parent || that_present_column_parent) {
         if (!(this_present_column_parent && that_present_column_parent))
           return false;
         if (!this.column_parent.equals(that.column_parent))
           return false;
       }
 
       boolean this_present_predicate = true && this.isSetPredicate();
       boolean that_present_predicate = true && that.isSetPredicate();
       if (this_present_predicate || that_present_predicate) {
         if (!(this_present_predicate && that_present_predicate))
           return false;
         if (!this.predicate.equals(that.predicate))
           return false;
       }
 
       boolean this_present_consistency_level = true;
       boolean that_present_consistency_level = true;
       if (this_present_consistency_level || that_present_consistency_level) {
         if (!(this_present_consistency_level && that_present_consistency_level))
           return false;
         if (this.consistency_level != that.consistency_level)
           return false;
       }
 
       return true;
     }
 
     @Override
     public int hashCode() {
       return 0;
     }
 
     public void read(TProtocol iprot) throws TException {
       TField field;
       iprot.readStructBegin();
       while (true)
       {
         field = iprot.readFieldBegin();
         if (field.type == TType.STOP) { 
           break;
         }
         switch (field.id)
         {
           case KEYSPACE:
             if (field.type == TType.STRING) {
               this.keyspace = iprot.readString();
             } else { 
               TProtocolUtil.skip(iprot, field.type);
             }
             break;
           case KEY:
             if (field.type == TType.STRING) {
               this.key = iprot.readString();
             } else { 
               TProtocolUtil.skip(iprot, field.type);
             }
             break;
           case COLUMN_PARENT:
             if (field.type == TType.STRUCT) {
               this.column_parent = new ColumnParent();
               this.column_parent.read(iprot);
             } else { 
               TProtocolUtil.skip(iprot, field.type);
             }
             break;
           case PREDICATE:
             if (field.type == TType.STRUCT) {
               this.predicate = new SlicePredicate();
               this.predicate.read(iprot);
             } else { 
               TProtocolUtil.skip(iprot, field.type);
             }
             break;
           case CONSISTENCY_LEVEL:
             if (field.type == TType.I32) {
               this.consistency_level = iprot.readI32();
               this.__isset.consistency_level = true;
             } else { 
               TProtocolUtil.skip(iprot, field.type);
             }
             break;
           default:
             TProtocolUtil.skip(iprot, field.type);
             break;
         }
         iprot.readFieldEnd();
       }
       iprot.readStructEnd();
 
 
       // check for required fields of primitive type, which can't be checked in the validate method
       validate();
     }
 
     public void write(TProtocol oprot) throws TException {
       validate();
 
       oprot.writeStructBegin(STRUCT_DESC);
       if (this.keyspace != null) {
         oprot.writeFieldBegin(KEYSPACE_FIELD_DESC);
         oprot.writeString(this.keyspace);
         oprot.writeFieldEnd();
       }
       if (this.key != null) {
         oprot.writeFieldBegin(KEY_FIELD_DESC);
         oprot.writeString(this.key);
         oprot.writeFieldEnd();
       }
       if (this.column_parent != null) {
         oprot.writeFieldBegin(COLUMN_PARENT_FIELD_DESC);
         this.column_parent.write(oprot);
         oprot.writeFieldEnd();
       }
       if (this.predicate != null) {
         oprot.writeFieldBegin(PREDICATE_FIELD_DESC);
         this.predicate.write(oprot);
         oprot.writeFieldEnd();
       }
       oprot.writeFieldBegin(CONSISTENCY_LEVEL_FIELD_DESC);
       oprot.writeI32(this.consistency_level);
       oprot.writeFieldEnd();
       oprot.writeFieldStop();
       oprot.writeStructEnd();
     }
 
     @Override
     public String toString() {
       StringBuilder sb = new StringBuilder("get_slice_args(");
       boolean first = true;
 
       sb.append("keyspace:");
       if (this.keyspace == null) {
         sb.append("null");
       } else {
         sb.append(this.keyspace);
       }
       first = false;
       if (!first) sb.append(", ");
       sb.append("key:");
       if (this.key == null) {
         sb.append("null");
       } else {
         sb.append(this.key);
       }
       first = false;
       if (!first) sb.append(", ");
       sb.append("column_parent:");
       if (this.column_parent == null) {
         sb.append("null");
       } else {
         sb.append(this.column_parent);
       }
       first = false;
       if (!first) sb.append(", ");
       sb.append("predicate:");
       if (this.predicate == null) {
         sb.append("null");
       } else {
         sb.append(this.predicate);
       }
       first = false;
       if (!first) sb.append(", ");
       sb.append("consistency_level:");
       String consistency_level_name = ConsistencyLevel.VALUES_TO_NAMES.get(this.consistency_level);
       if (consistency_level_name != null) {
         sb.append(consistency_level_name);
         sb.append(" (");
       }
       sb.append(this.consistency_level);
       if (consistency_level_name != null) {
         sb.append(")");
       }
       first = false;
       sb.append(")");
       return sb.toString();
     }
 
     public void validate() throws TException {
       // check for required fields
       // check that fields of type enum have valid values
       if (isSetConsistency_level() && !ConsistencyLevel.VALID_VALUES.contains(consistency_level)){
         throw new TProtocolException("The field 'consistency_level' has been assigned the invalid value " + consistency_level);
       }
     }
 
   }
 
   public static class get_slice_result implements TBase, java.io.Serializable, Cloneable   {
     private static final TStruct STRUCT_DESC = new TStruct("get_slice_result");
     private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.LIST, (short)0);
     private static final TField IRE_FIELD_DESC = new TField("ire", TType.STRUCT, (short)1);
     private static final TField NFE_FIELD_DESC = new TField("nfe", TType.STRUCT, (short)2);
 
     public List<ColumnOrSuperColumn> success;
     public static final int SUCCESS = 0;
     public InvalidRequestException ire;
     public static final int IRE = 1;
     public NotFoundException nfe;
     public static final int NFE = 2;
 
     private final Isset __isset = new Isset();
     private static final class Isset implements java.io.Serializable {
     }
 
     public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
       put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
           new ListMetaData(TType.LIST, 
               new StructMetaData(TType.STRUCT, ColumnOrSuperColumn.class))));
       put(IRE, new FieldMetaData("ire", TFieldRequirementType.DEFAULT, 
           new FieldValueMetaData(TType.STRUCT)));
       put(NFE, new FieldMetaData("nfe", TFieldRequirementType.DEFAULT, 
           new FieldValueMetaData(TType.STRUCT)));
     }});
 
     static {
       FieldMetaData.addStructMetaDataMap(get_slice_result.class, metaDataMap);
     }
 
     public get_slice_result() {
     }
 
     public get_slice_result(
       List<ColumnOrSuperColumn> success,
       InvalidRequestException ire,
       NotFoundException nfe)
     {
       this();
       this.success = success;
       this.ire = ire;
       this.nfe = nfe;
     }
 
     /**
      * Performs a deep copy on <i>other</i>.
      */
     public get_slice_result(get_slice_result other) {
       if (other.isSetSuccess()) {
         List<ColumnOrSuperColumn> __this__success = new ArrayList<ColumnOrSuperColumn>();
         for (ColumnOrSuperColumn other_element : other.success) {
           __this__success.add(new ColumnOrSuperColumn(other_element));
         }
         this.success = __this__success;
       }
       if (other.isSetIre()) {
         this.ire = new InvalidRequestException(other.ire);
       }
       if (other.isSetNfe()) {
         this.nfe = new NotFoundException(other.nfe);
       }
     }
 
     @Override
     public get_slice_result clone() {
       return new get_slice_result(this);
     }
 
     public List<ColumnOrSuperColumn> getSuccess() {
       return this.success;
     }
 
    public get_slice_result setSuccess(List<ColumnOrSuperColumn> success) {
       this.success = success;
      return this;
     }
 
     public void unsetSuccess() {
       this.success = null;
     }
 
     // Returns true if field success is set (has been asigned a value) and false otherwise
     public boolean isSetSuccess() {
       return this.success != null;
     }
 
     public void setSuccessIsSet(boolean value) {
       if (!value) {
         this.success = null;
       }
     }
 
     public InvalidRequestException getIre() {
       return this.ire;
     }
 
    public get_slice_result setIre(InvalidRequestException ire) {
       this.ire = ire;
      return this;
     }
 
     public void unsetIre() {
       this.ire = null;
     }
 
     // Returns true if field ire is set (has been asigned a value) and false otherwise
     public boolean isSetIre() {
       return this.ire != null;
     }
 
     public void setIreIsSet(boolean value) {
       if (!value) {
         this.ire = null;
       }
     }
 
     public NotFoundException getNfe() {
       return this.nfe;
     }
 
    public get_slice_result setNfe(NotFoundException nfe) {
       this.nfe = nfe;
      return this;
     }
 
     public void unsetNfe() {
       this.nfe = null;
     }
 
     // Returns true if field nfe is set (has been asigned a value) and false otherwise
     public boolean isSetNfe() {
       return this.nfe != null;
     }
 
     public void setNfeIsSet(boolean value) {
       if (!value) {
         this.nfe = null;
       }
     }
 
     public void setFieldValue(int fieldID, Object value) {
       switch (fieldID) {
       case SUCCESS:
         if (value == null) {
           unsetSuccess();
         } else {
           setSuccess((List<ColumnOrSuperColumn>)value);
         }
         break;
 
       case IRE:
         if (value == null) {
           unsetIre();
         } else {
           setIre((InvalidRequestException)value);
         }
         break;
 
       case NFE:
         if (value == null) {
           unsetNfe();
         } else {
           setNfe((NotFoundException)value);
         }
         break;
 
       default:
         throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
       }
     }
 
     public Object getFieldValue(int fieldID) {
       switch (fieldID) {
       case SUCCESS:
         return getSuccess();
 
       case IRE:
         return getIre();
 
       case NFE:
         return getNfe();
 
       default:
         throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
       }
     }
 
     // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
     public boolean isSet(int fieldID) {
       switch (fieldID) {
       case SUCCESS:
         return isSetSuccess();
       case IRE:
         return isSetIre();
       case NFE:
         return isSetNfe();
       default:
         throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
       }
     }
 
     @Override
     public boolean equals(Object that) {
       if (that == null)
         return false;
       if (that instanceof get_slice_result)
         return this.equals((get_slice_result)that);
       return false;
     }
 
     public boolean equals(get_slice_result that) {
       if (that == null)
         return false;
 
       boolean this_present_success = true && this.isSetSuccess();
       boolean that_present_success = true && that.isSetSuccess();
       if (this_present_success || that_present_success) {
         if (!(this_present_success && that_present_success))
           return false;
         if (!this.success.equals(that.success))
           return false;
       }
 
       boolean this_present_ire = true && this.isSetIre();
       boolean that_present_ire = true && that.isSetIre();
       if (this_present_ire || that_present_ire) {
         if (!(this_present_ire && that_present_ire))
           return false;
         if (!this.ire.equals(that.ire))
           return false;
       }
 
       boolean this_present_nfe = true && this.isSetNfe();
       boolean that_present_nfe = true && that.isSetNfe();
       if (this_present_nfe || that_present_nfe) {
         if (!(this_present_nfe && that_present_nfe))
           return false;
         if (!this.nfe.equals(that.nfe))
           return false;
       }
 
       return true;
     }
 
     @Override
     public int hashCode() {
       return 0;
     }
 
     public void read(TProtocol iprot) throws TException {
       TField field;
       iprot.readStructBegin();
       while (true)
       {
         field = iprot.readFieldBegin();
         if (field.type == TType.STOP) { 
           break;
         }
         switch (field.id)
         {
           case SUCCESS:
             if (field.type == TType.LIST) {
               {
                 TList _list35 = iprot.readListBegin();
                 this.success = new ArrayList<ColumnOrSuperColumn>(_list35.size);
                 for (int _i36 = 0; _i36 < _list35.size; ++_i36)
                 {
                   ColumnOrSuperColumn _elem37;
                   _elem37 = new ColumnOrSuperColumn();
                   _elem37.read(iprot);
                   this.success.add(_elem37);
                 }
                 iprot.readListEnd();
               }
             } else { 
               TProtocolUtil.skip(iprot, field.type);
             }
             break;
           case IRE:
             if (field.type == TType.STRUCT) {
               this.ire = new InvalidRequestException();
               this.ire.read(iprot);
             } else { 
               TProtocolUtil.skip(iprot, field.type);
             }
             break;
           case NFE:
             if (field.type == TType.STRUCT) {
               this.nfe = new NotFoundException();
               this.nfe.read(iprot);
             } else { 
               TProtocolUtil.skip(iprot, field.type);
             }
             break;
           default:
             TProtocolUtil.skip(iprot, field.type);
             break;
         }
         iprot.readFieldEnd();
       }
       iprot.readStructEnd();
 
 
       // check for required fields of primitive type, which can't be checked in the validate method
       validate();
     }
 
     public void write(TProtocol oprot) throws TException {
       oprot.writeStructBegin(STRUCT_DESC);
 
       if (this.isSetSuccess()) {
         oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
         {
           oprot.writeListBegin(new TList(TType.STRUCT, this.success.size()));
           for (ColumnOrSuperColumn _iter38 : this.success)          {
             _iter38.write(oprot);
           }
           oprot.writeListEnd();
         }
         oprot.writeFieldEnd();
       } else if (this.isSetIre()) {
         oprot.writeFieldBegin(IRE_FIELD_DESC);
         this.ire.write(oprot);
         oprot.writeFieldEnd();
       } else if (this.isSetNfe()) {
         oprot.writeFieldBegin(NFE_FIELD_DESC);
         this.nfe.write(oprot);
         oprot.writeFieldEnd();
       }
       oprot.writeFieldStop();
       oprot.writeStructEnd();
     }
 
     @Override
     public String toString() {
       StringBuilder sb = new StringBuilder("get_slice_result(");
       boolean first = true;
 
       sb.append("success:");
       if (this.success == null) {
         sb.append("null");
       } else {
         sb.append(this.success);
       }
       first = false;
       if (!first) sb.append(", ");
       sb.append("ire:");
       if (this.ire == null) {
         sb.append("null");
       } else {
         sb.append(this.ire);
       }
       first = false;
       if (!first) sb.append(", ");
       sb.append("nfe:");
       if (this.nfe == null) {
         sb.append("null");
       } else {
         sb.append(this.nfe);
       }
       first = false;
       sb.append(")");
       return sb.toString();
     }
 
     public void validate() throws TException {
       // check for required fields
       // check that fields of type enum have valid values
     }
 
   }
 
   public static class get_args implements TBase, java.io.Serializable, Cloneable   {
     private static final TStruct STRUCT_DESC = new TStruct("get_args");
     private static final TField KEYSPACE_FIELD_DESC = new TField("keyspace", TType.STRING, (short)1);
     private static final TField KEY_FIELD_DESC = new TField("key", TType.STRING, (short)2);
     private static final TField COLUMN_PATH_FIELD_DESC = new TField("column_path", TType.STRUCT, (short)3);
     private static final TField CONSISTENCY_LEVEL_FIELD_DESC = new TField("consistency_level", TType.I32, (short)4);
 
     public String keyspace;
     public static final int KEYSPACE = 1;
     public String key;
     public static final int KEY = 2;
     public ColumnPath column_path;
     public static final int COLUMN_PATH = 3;
    /**
     * 
     * @see ConsistencyLevel
     */
     public int consistency_level;
     public static final int CONSISTENCY_LEVEL = 4;
 
     private final Isset __isset = new Isset();
     private static final class Isset implements java.io.Serializable {
       public boolean consistency_level = false;
     }
 
     public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
       put(KEYSPACE, new FieldMetaData("keyspace", TFieldRequirementType.DEFAULT, 
           new FieldValueMetaData(TType.STRING)));
       put(KEY, new FieldMetaData("key", TFieldRequirementType.DEFAULT, 
           new FieldValueMetaData(TType.STRING)));
       put(COLUMN_PATH, new FieldMetaData("column_path", TFieldRequirementType.DEFAULT, 
           new StructMetaData(TType.STRUCT, ColumnPath.class)));
       put(CONSISTENCY_LEVEL, new FieldMetaData("consistency_level", TFieldRequirementType.DEFAULT, 
           new FieldValueMetaData(TType.I32)));
     }});
 
     static {
       FieldMetaData.addStructMetaDataMap(get_args.class, metaDataMap);
     }
 
     public get_args() {
       this.consistency_level = 1;
 
     }
 
     public get_args(
       String keyspace,
       String key,
       ColumnPath column_path,
       int consistency_level)
     {
       this();
       this.keyspace = keyspace;
       this.key = key;
       this.column_path = column_path;
       this.consistency_level = consistency_level;
       this.__isset.consistency_level = true;
     }
 
     /**
      * Performs a deep copy on <i>other</i>.
      */
     public get_args(get_args other) {
       if (other.isSetKeyspace()) {
         this.keyspace = other.keyspace;
       }
       if (other.isSetKey()) {
         this.key = other.key;
       }
       if (other.isSetColumn_path()) {
         this.column_path = new ColumnPath(other.column_path);
       }
       __isset.consistency_level = other.__isset.consistency_level;
       this.consistency_level = other.consistency_level;
     }
 
     @Override
     public get_args clone() {
       return new get_args(this);
     }
 
     public String getKeyspace() {
       return this.keyspace;
     }
 
    public get_args setKeyspace(String keyspace) {
       this.keyspace = keyspace;
      return this;
     }
 
     public void unsetKeyspace() {
       this.keyspace = null;
     }
 
     // Returns true if field keyspace is set (has been asigned a value) and false otherwise
     public boolean isSetKeyspace() {
       return this.keyspace != null;
     }
 
     public void setKeyspaceIsSet(boolean value) {
       if (!value) {
         this.keyspace = null;
       }
     }
 
     public String getKey() {
       return this.key;
     }
 
    public get_args setKey(String key) {
       this.key = key;
      return this;
     }
 
     public void unsetKey() {
       this.key = null;
     }
 
     // Returns true if field key is set (has been asigned a value) and false otherwise
     public boolean isSetKey() {
       return this.key != null;
     }
 
     public void setKeyIsSet(boolean value) {
       if (!value) {
         this.key = null;
       }
     }
 
     public ColumnPath getColumn_path() {
       return this.column_path;
     }
 
    public get_args setColumn_path(ColumnPath column_path) {
       this.column_path = column_path;
      return this;
     }
 
     public void unsetColumn_path() {
       this.column_path = null;
     }
 
     // Returns true if field column_path is set (has been asigned a value) and false otherwise
     public boolean isSetColumn_path() {
       return this.column_path != null;
     }
 
     public void setColumn_pathIsSet(boolean value) {
       if (!value) {
         this.column_path = null;
       }
     }
 
    /**
     * 
     * @see ConsistencyLevel
     */
     public int getConsistency_level() {
       return this.consistency_level;
     }
 
    /**
     * 
     * @see ConsistencyLevel
     */
    public get_args setConsistency_level(int consistency_level) {
       this.consistency_level = consistency_level;
       this.__isset.consistency_level = true;
      return this;
     }
 
     public void unsetConsistency_level() {
       this.__isset.consistency_level = false;
     }
 
     // Returns true if field consistency_level is set (has been asigned a value) and false otherwise
     public boolean isSetConsistency_level() {
       return this.__isset.consistency_level;
     }
 
     public void setConsistency_levelIsSet(boolean value) {
       this.__isset.consistency_level = value;
     }
 
     public void setFieldValue(int fieldID, Object value) {
       switch (fieldID) {
       case KEYSPACE:
         if (value == null) {
           unsetKeyspace();
         } else {
           setKeyspace((String)value);
         }
         break;
 
       case KEY:
         if (value == null) {
           unsetKey();
         } else {
           setKey((String)value);
         }
         break;
 
       case COLUMN_PATH:
         if (value == null) {
           unsetColumn_path();
         } else {
           setColumn_path((ColumnPath)value);
         }
         break;
 
       case CONSISTENCY_LEVEL:
         if (value == null) {
           unsetConsistency_level();
         } else {
           setConsistency_level((Integer)value);
         }
         break;
 
       default:
         throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
       }
     }
 
     public Object getFieldValue(int fieldID) {
       switch (fieldID) {
       case KEYSPACE:
         return getKeyspace();
 
       case KEY:
         return getKey();
 
       case COLUMN_PATH:
         return getColumn_path();
 
       case CONSISTENCY_LEVEL:
         return getConsistency_level();
 
       default:
         throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
       }
     }
 
     // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
     public boolean isSet(int fieldID) {
       switch (fieldID) {
       case KEYSPACE:
         return isSetKeyspace();
       case KEY:
         return isSetKey();
       case COLUMN_PATH:
         return isSetColumn_path();
       case CONSISTENCY_LEVEL:
         return isSetConsistency_level();
       default:
         throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
       }
     }
 
     @Override
     public boolean equals(Object that) {
       if (that == null)
         return false;
       if (that instanceof get_args)
         return this.equals((get_args)that);
       return false;
     }
 
     public boolean equals(get_args that) {
       if (that == null)
         return false;
 
       boolean this_present_keyspace = true && this.isSetKeyspace();
       boolean that_present_keyspace = true && that.isSetKeyspace();
       if (this_present_keyspace || that_present_keyspace) {
         if (!(this_present_keyspace && that_present_keyspace))
           return false;
         if (!this.keyspace.equals(that.keyspace))
           return false;
       }
 
       boolean this_present_key = true && this.isSetKey();
       boolean that_present_key = true && that.isSetKey();
       if (this_present_key || that_present_key) {
         if (!(this_present_key && that_present_key))
           return false;
         if (!this.key.equals(that.key))
           return false;
       }
 
       boolean this_present_column_path = true && this.isSetColumn_path();
       boolean that_present_column_path = true && that.isSetColumn_path();
       if (this_present_column_path || that_present_column_path) {
         if (!(this_present_column_path && that_present_column_path))
           return false;
         if (!this.column_path.equals(that.column_path))
           return false;
       }
 
       boolean this_present_consistency_level = true;
       boolean that_present_consistency_level = true;
       if (this_present_consistency_level || that_present_consistency_level) {
         if (!(this_present_consistency_level && that_present_consistency_level))
           return false;
         if (this.consistency_level != that.consistency_level)
           return false;
       }
 
       return true;
     }
 
     @Override
     public int hashCode() {
       return 0;
     }
 
     public void read(TProtocol iprot) throws TException {
       TField field;
       iprot.readStructBegin();
       while (true)
       {
         field = iprot.readFieldBegin();
         if (field.type == TType.STOP) { 
           break;
         }
         switch (field.id)
         {
           case KEYSPACE:
             if (field.type == TType.STRING) {
               this.keyspace = iprot.readString();
             } else { 
               TProtocolUtil.skip(iprot, field.type);
             }
             break;
           case KEY:
             if (field.type == TType.STRING) {
               this.key = iprot.readString();
             } else { 
               TProtocolUtil.skip(iprot, field.type);
             }
             break;
           case COLUMN_PATH:
             if (field.type == TType.STRUCT) {
               this.column_path = new ColumnPath();
               this.column_path.read(iprot);
             } else { 
               TProtocolUtil.skip(iprot, field.type);
             }
             break;
           case CONSISTENCY_LEVEL:
             if (field.type == TType.I32) {
               this.consistency_level = iprot.readI32();
               this.__isset.consistency_level = true;
             } else { 
               TProtocolUtil.skip(iprot, field.type);
             }
             break;
           default:
             TProtocolUtil.skip(iprot, field.type);
             break;
         }
         iprot.readFieldEnd();
       }
       iprot.readStructEnd();
 
 
       // check for required fields of primitive type, which can't be checked in the validate method
       validate();
     }
 
     public void write(TProtocol oprot) throws TException {
       validate();
 
       oprot.writeStructBegin(STRUCT_DESC);
       if (this.keyspace != null) {
         oprot.writeFieldBegin(KEYSPACE_FIELD_DESC);
         oprot.writeString(this.keyspace);
         oprot.writeFieldEnd();
       }
       if (this.key != null) {
         oprot.writeFieldBegin(KEY_FIELD_DESC);
         oprot.writeString(this.key);
         oprot.writeFieldEnd();
       }
       if (this.column_path != null) {
         oprot.writeFieldBegin(COLUMN_PATH_FIELD_DESC);
         this.column_path.write(oprot);
         oprot.writeFieldEnd();
       }
       oprot.writeFieldBegin(CONSISTENCY_LEVEL_FIELD_DESC);
       oprot.writeI32(this.consistency_level);
       oprot.writeFieldEnd();
       oprot.writeFieldStop();
       oprot.writeStructEnd();
     }
 
     @Override
     public String toString() {
       StringBuilder sb = new StringBuilder("get_args(");
       boolean first = true;
 
       sb.append("keyspace:");
       if (this.keyspace == null) {
         sb.append("null");
       } else {
         sb.append(this.keyspace);
       }
       first = false;
       if (!first) sb.append(", ");
       sb.append("key:");
       if (this.key == null) {
         sb.append("null");
       } else {
         sb.append(this.key);
       }
       first = false;
       if (!first) sb.append(", ");
       sb.append("column_path:");
       if (this.column_path == null) {
         sb.append("null");
       } else {
         sb.append(this.column_path);
       }
       first = false;
       if (!first) sb.append(", ");
       sb.append("consistency_level:");
       String consistency_level_name = ConsistencyLevel.VALUES_TO_NAMES.get(this.consistency_level);
       if (consistency_level_name != null) {
         sb.append(consistency_level_name);
         sb.append(" (");
       }
       sb.append(this.consistency_level);
       if (consistency_level_name != null) {
         sb.append(")");
       }
       first = false;
       sb.append(")");
       return sb.toString();
     }
 
     public void validate() throws TException {
       // check for required fields
       // check that fields of type enum have valid values
       if (isSetConsistency_level() && !ConsistencyLevel.VALID_VALUES.contains(consistency_level)){
         throw new TProtocolException("The field 'consistency_level' has been assigned the invalid value " + consistency_level);
       }
     }
 
   }
 
   public static class get_result implements TBase, java.io.Serializable, Cloneable   {
     private static final TStruct STRUCT_DESC = new TStruct("get_result");
     private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);
     private static final TField IRE_FIELD_DESC = new TField("ire", TType.STRUCT, (short)1);
     private static final TField NFE_FIELD_DESC = new TField("nfe", TType.STRUCT, (short)2);
 
     public ColumnOrSuperColumn success;
     public static final int SUCCESS = 0;
     public InvalidRequestException ire;
     public static final int IRE = 1;
     public NotFoundException nfe;
     public static final int NFE = 2;
 
     private final Isset __isset = new Isset();
     private static final class Isset implements java.io.Serializable {
     }
 
     public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
       put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
           new StructMetaData(TType.STRUCT, ColumnOrSuperColumn.class)));
       put(IRE, new FieldMetaData("ire", TFieldRequirementType.DEFAULT, 
           new FieldValueMetaData(TType.STRUCT)));
       put(NFE, new FieldMetaData("nfe", TFieldRequirementType.DEFAULT, 
           new FieldValueMetaData(TType.STRUCT)));
     }});
 
     static {
       FieldMetaData.addStructMetaDataMap(get_result.class, metaDataMap);
     }
 
     public get_result() {
     }
 
     public get_result(
       ColumnOrSuperColumn success,
       InvalidRequestException ire,
       NotFoundException nfe)
     {
       this();
       this.success = success;
       this.ire = ire;
       this.nfe = nfe;
     }
 
     /**
      * Performs a deep copy on <i>other</i>.
      */
     public get_result(get_result other) {
       if (other.isSetSuccess()) {
         this.success = new ColumnOrSuperColumn(other.success);
       }
       if (other.isSetIre()) {
         this.ire = new InvalidRequestException(other.ire);
       }
       if (other.isSetNfe()) {
         this.nfe = new NotFoundException(other.nfe);
       }
     }
 
     @Override
     public get_result clone() {
       return new get_result(this);
     }
 
     public ColumnOrSuperColumn getSuccess() {
       return this.success;
     }
 
    public get_result setSuccess(ColumnOrSuperColumn success) {
       this.success = success;
      return this;
     }
 
     public void unsetSuccess() {
       this.success = null;
     }
 
     // Returns true if field success is set (has been asigned a value) and false otherwise
     public boolean isSetSuccess() {
       return this.success != null;
     }
 
     public void setSuccessIsSet(boolean value) {
       if (!value) {
         this.success = null;
       }
     }
 
     public InvalidRequestException getIre() {
       return this.ire;
     }
 
    public get_result setIre(InvalidRequestException ire) {
       this.ire = ire;
      return this;
     }
 
     public void unsetIre() {
       this.ire = null;
     }
 
     // Returns true if field ire is set (has been asigned a value) and false otherwise
     public boolean isSetIre() {
       return this.ire != null;
     }
 
     public void setIreIsSet(boolean value) {
       if (!value) {
         this.ire = null;
       }
     }
 
     public NotFoundException getNfe() {
       return this.nfe;
     }
 
    public get_result setNfe(NotFoundException nfe) {
       this.nfe = nfe;
      return this;
     }
 
     public void unsetNfe() {
       this.nfe = null;
     }
 
     // Returns true if field nfe is set (has been asigned a value) and false otherwise
     public boolean isSetNfe() {
       return this.nfe != null;
     }
 
     public void setNfeIsSet(boolean value) {
       if (!value) {
         this.nfe = null;
       }
     }
 
     public void setFieldValue(int fieldID, Object value) {
       switch (fieldID) {
       case SUCCESS:
         if (value == null) {
           unsetSuccess();
         } else {
           setSuccess((ColumnOrSuperColumn)value);
         }
         break;
 
       case IRE:
         if (value == null) {
           unsetIre();
         } else {
           setIre((InvalidRequestException)value);
         }
         break;
 
       case NFE:
         if (value == null) {
           unsetNfe();
         } else {
           setNfe((NotFoundException)value);
         }
         break;
 
       default:
         throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
       }
     }
 
     public Object getFieldValue(int fieldID) {
       switch (fieldID) {
       case SUCCESS:
         return getSuccess();
 
       case IRE:
         return getIre();
 
       case NFE:
         return getNfe();
 
       default:
         throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
       }
     }
 
     // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
     public boolean isSet(int fieldID) {
       switch (fieldID) {
       case SUCCESS:
         return isSetSuccess();
       case IRE:
         return isSetIre();
       case NFE:
         return isSetNfe();
       default:
         throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
       }
     }
 
     @Override
     public boolean equals(Object that) {
       if (that == null)
         return false;
       if (that instanceof get_result)
         return this.equals((get_result)that);
       return false;
     }
 
     public boolean equals(get_result that) {
       if (that == null)
         return false;
 
       boolean this_present_success = true && this.isSetSuccess();
       boolean that_present_success = true && that.isSetSuccess();
       if (this_present_success || that_present_success) {
         if (!(this_present_success && that_present_success))
           return false;
         if (!this.success.equals(that.success))
           return false;
       }
 
       boolean this_present_ire = true && this.isSetIre();
       boolean that_present_ire = true && that.isSetIre();
       if (this_present_ire || that_present_ire) {
         if (!(this_present_ire && that_present_ire))
           return false;
         if (!this.ire.equals(that.ire))
           return false;
       }
 
       boolean this_present_nfe = true && this.isSetNfe();
       boolean that_present_nfe = true && that.isSetNfe();
       if (this_present_nfe || that_present_nfe) {
         if (!(this_present_nfe && that_present_nfe))
           return false;
         if (!this.nfe.equals(that.nfe))
           return false;
       }
 
       return true;
     }
 
     @Override
     public int hashCode() {
       return 0;
     }
 
     public void read(TProtocol iprot) throws TException {
       TField field;
       iprot.readStructBegin();
       while (true)
       {
         field = iprot.readFieldBegin();
         if (field.type == TType.STOP) { 
           break;
         }
         switch (field.id)
         {
           case SUCCESS:
             if (field.type == TType.STRUCT) {
               this.success = new ColumnOrSuperColumn();
               this.success.read(iprot);
             } else { 
               TProtocolUtil.skip(iprot, field.type);
             }
             break;
           case IRE:
             if (field.type == TType.STRUCT) {
               this.ire = new InvalidRequestException();
               this.ire.read(iprot);
             } else { 
               TProtocolUtil.skip(iprot, field.type);
             }
             break;
           case NFE:
             if (field.type == TType.STRUCT) {
               this.nfe = new NotFoundException();
               this.nfe.read(iprot);
             } else { 
               TProtocolUtil.skip(iprot, field.type);
             }
             break;
           default:
             TProtocolUtil.skip(iprot, field.type);
             break;
         }
         iprot.readFieldEnd();
       }
       iprot.readStructEnd();
 
 
       // check for required fields of primitive type, which can't be checked in the validate method
       validate();
     }
 
     public void write(TProtocol oprot) throws TException {
       oprot.writeStructBegin(STRUCT_DESC);
 
       if (this.isSetSuccess()) {
         oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
         this.success.write(oprot);
         oprot.writeFieldEnd();
       } else if (this.isSetIre()) {
         oprot.writeFieldBegin(IRE_FIELD_DESC);
         this.ire.write(oprot);
         oprot.writeFieldEnd();
       } else if (this.isSetNfe()) {
         oprot.writeFieldBegin(NFE_FIELD_DESC);
         this.nfe.write(oprot);
         oprot.writeFieldEnd();
       }
       oprot.writeFieldStop();
       oprot.writeStructEnd();
     }
 
     @Override
     public String toString() {
       StringBuilder sb = new StringBuilder("get_result(");
       boolean first = true;
 
       sb.append("success:");
       if (this.success == null) {
         sb.append("null");
       } else {
         sb.append(this.success);
       }
       first = false;
       if (!first) sb.append(", ");
       sb.append("ire:");
       if (this.ire == null) {
         sb.append("null");
       } else {
         sb.append(this.ire);
       }
       first = false;
       if (!first) sb.append(", ");
       sb.append("nfe:");
       if (this.nfe == null) {
         sb.append("null");
       } else {
         sb.append(this.nfe);
       }
       first = false;
       sb.append(")");
       return sb.toString();
     }
 
     public void validate() throws TException {
       // check for required fields
       // check that fields of type enum have valid values
     }
 
   }
 
   public static class get_count_args implements TBase, java.io.Serializable, Cloneable   {
     private static final TStruct STRUCT_DESC = new TStruct("get_count_args");
     private static final TField KEYSPACE_FIELD_DESC = new TField("keyspace", TType.STRING, (short)1);
     private static final TField KEY_FIELD_DESC = new TField("key", TType.STRING, (short)2);
     private static final TField COLUMN_PARENT_FIELD_DESC = new TField("column_parent", TType.STRUCT, (short)3);
     private static final TField CONSISTENCY_LEVEL_FIELD_DESC = new TField("consistency_level", TType.I32, (short)5);
 
     public String keyspace;
     public static final int KEYSPACE = 1;
     public String key;
     public static final int KEY = 2;
     public ColumnParent column_parent;
     public static final int COLUMN_PARENT = 3;
    /**
     * 
     * @see ConsistencyLevel
     */
     public int consistency_level;
     public static final int CONSISTENCY_LEVEL = 5;
 
     private final Isset __isset = new Isset();
     private static final class Isset implements java.io.Serializable {
       public boolean consistency_level = false;
     }
 
     public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
       put(KEYSPACE, new FieldMetaData("keyspace", TFieldRequirementType.DEFAULT, 
           new FieldValueMetaData(TType.STRING)));
       put(KEY, new FieldMetaData("key", TFieldRequirementType.DEFAULT, 
           new FieldValueMetaData(TType.STRING)));
       put(COLUMN_PARENT, new FieldMetaData("column_parent", TFieldRequirementType.DEFAULT, 
           new StructMetaData(TType.STRUCT, ColumnParent.class)));
       put(CONSISTENCY_LEVEL, new FieldMetaData("consistency_level", TFieldRequirementType.DEFAULT, 
           new FieldValueMetaData(TType.I32)));
     }});
 
     static {
       FieldMetaData.addStructMetaDataMap(get_count_args.class, metaDataMap);
     }
 
     public get_count_args() {
       this.consistency_level = 1;
 
     }
 
     public get_count_args(
       String keyspace,
       String key,
       ColumnParent column_parent,
       int consistency_level)
     {
       this();
       this.keyspace = keyspace;
       this.key = key;
       this.column_parent = column_parent;
       this.consistency_level = consistency_level;
       this.__isset.consistency_level = true;
     }
 
     /**
      * Performs a deep copy on <i>other</i>.
      */
     public get_count_args(get_count_args other) {
       if (other.isSetKeyspace()) {
         this.keyspace = other.keyspace;
       }
       if (other.isSetKey()) {
         this.key = other.key;
       }
       if (other.isSetColumn_parent()) {
         this.column_parent = new ColumnParent(other.column_parent);
       }
       __isset.consistency_level = other.__isset.consistency_level;
       this.consistency_level = other.consistency_level;
     }
 
     @Override
     public get_count_args clone() {
       return new get_count_args(this);
     }
 
     public String getKeyspace() {
       return this.keyspace;
     }
 
    public get_count_args setKeyspace(String keyspace) {
       this.keyspace = keyspace;
      return this;
     }
 
     public void unsetKeyspace() {
       this.keyspace = null;
     }
 
     // Returns true if field keyspace is set (has been asigned a value) and false otherwise
     public boolean isSetKeyspace() {
       return this.keyspace != null;
     }
 
     public void setKeyspaceIsSet(boolean value) {
       if (!value) {
         this.keyspace = null;
       }
     }
 
     public String getKey() {
       return this.key;
     }
 
    public get_count_args setKey(String key) {
       this.key = key;
      return this;
     }
 
     public void unsetKey() {
       this.key = null;
     }
 
     // Returns true if field key is set (has been asigned a value) and false otherwise
     public boolean isSetKey() {
       return this.key != null;
     }
 
     public void setKeyIsSet(boolean value) {
       if (!value) {
         this.key = null;
       }
     }
 
     public ColumnParent getColumn_parent() {
       return this.column_parent;
     }
 
    public get_count_args setColumn_parent(ColumnParent column_parent) {
       this.column_parent = column_parent;
      return this;
     }
 
     public void unsetColumn_parent() {
       this.column_parent = null;
     }
 
     // Returns true if field column_parent is set (has been asigned a value) and false otherwise
     public boolean isSetColumn_parent() {
       return this.column_parent != null;
     }
 
     public void setColumn_parentIsSet(boolean value) {
       if (!value) {
         this.column_parent = null;
       }
     }
 
    /**
     * 
     * @see ConsistencyLevel
     */
     public int getConsistency_level() {
       return this.consistency_level;
     }
 
    /**
     * 
     * @see ConsistencyLevel
     */
    public get_count_args setConsistency_level(int consistency_level) {
       this.consistency_level = consistency_level;
       this.__isset.consistency_level = true;
      return this;
     }
 
     public void unsetConsistency_level() {
       this.__isset.consistency_level = false;
     }
 
     // Returns true if field consistency_level is set (has been asigned a value) and false otherwise
     public boolean isSetConsistency_level() {
       return this.__isset.consistency_level;
     }
 
     public void setConsistency_levelIsSet(boolean value) {
       this.__isset.consistency_level = value;
     }
 
     public void setFieldValue(int fieldID, Object value) {
       switch (fieldID) {
       case KEYSPACE:
         if (value == null) {
           unsetKeyspace();
         } else {
           setKeyspace((String)value);
         }
         break;
 
       case KEY:
         if (value == null) {
           unsetKey();
         } else {
           setKey((String)value);
         }
         break;
 
       case COLUMN_PARENT:
         if (value == null) {
           unsetColumn_parent();
         } else {
           setColumn_parent((ColumnParent)value);
         }
         break;
 
       case CONSISTENCY_LEVEL:
         if (value == null) {
           unsetConsistency_level();
         } else {
           setConsistency_level((Integer)value);
         }
         break;
 
       default:
         throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
       }
     }
 
     public Object getFieldValue(int fieldID) {
       switch (fieldID) {
       case KEYSPACE:
         return getKeyspace();
 
       case KEY:
         return getKey();
 
       case COLUMN_PARENT:
         return getColumn_parent();
 
       case CONSISTENCY_LEVEL:
         return getConsistency_level();
 
       default:
         throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
       }
     }
 
     // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
     public boolean isSet(int fieldID) {
       switch (fieldID) {
       case KEYSPACE:
         return isSetKeyspace();
       case KEY:
         return isSetKey();
       case COLUMN_PARENT:
         return isSetColumn_parent();
       case CONSISTENCY_LEVEL:
         return isSetConsistency_level();
       default:
         throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
       }
     }
 
     @Override
     public boolean equals(Object that) {
       if (that == null)
         return false;
       if (that instanceof get_count_args)
         return this.equals((get_count_args)that);
       return false;
     }
 
     public boolean equals(get_count_args that) {
       if (that == null)
         return false;
 
       boolean this_present_keyspace = true && this.isSetKeyspace();
       boolean that_present_keyspace = true && that.isSetKeyspace();
       if (this_present_keyspace || that_present_keyspace) {
         if (!(this_present_keyspace && that_present_keyspace))
           return false;
         if (!this.keyspace.equals(that.keyspace))
           return false;
       }
 
       boolean this_present_key = true && this.isSetKey();
       boolean that_present_key = true && that.isSetKey();
       if (this_present_key || that_present_key) {
         if (!(this_present_key && that_present_key))
           return false;
         if (!this.key.equals(that.key))
           return false;
       }
 
       boolean this_present_column_parent = true && this.isSetColumn_parent();
       boolean that_present_column_parent = true && that.isSetColumn_parent();
       if (this_present_column_parent || that_present_column_parent) {
         if (!(this_present_column_parent && that_present_column_parent))
           return false;
         if (!this.column_parent.equals(that.column_parent))
           return false;
       }
 
       boolean this_present_consistency_level = true;
       boolean that_present_consistency_level = true;
       if (this_present_consistency_level || that_present_consistency_level) {
         if (!(this_present_consistency_level && that_present_consistency_level))
           return false;
         if (this.consistency_level != that.consistency_level)
           return false;
       }
 
       return true;
     }
 
     @Override
     public int hashCode() {
       return 0;
     }
 
     public void read(TProtocol iprot) throws TException {
       TField field;
       iprot.readStructBegin();
       while (true)
       {
         field = iprot.readFieldBegin();
         if (field.type == TType.STOP) { 
           break;
         }
         switch (field.id)
         {
           case KEYSPACE:
             if (field.type == TType.STRING) {
               this.keyspace = iprot.readString();
             } else { 
               TProtocolUtil.skip(iprot, field.type);
             }
             break;
           case KEY:
             if (field.type == TType.STRING) {
               this.key = iprot.readString();
             } else { 
               TProtocolUtil.skip(iprot, field.type);
             }
             break;
           case COLUMN_PARENT:
             if (field.type == TType.STRUCT) {
               this.column_parent = new ColumnParent();
               this.column_parent.read(iprot);
             } else { 
               TProtocolUtil.skip(iprot, field.type);
             }
             break;
           case CONSISTENCY_LEVEL:
             if (field.type == TType.I32) {
               this.consistency_level = iprot.readI32();
               this.__isset.consistency_level = true;
             } else { 
               TProtocolUtil.skip(iprot, field.type);
             }
             break;
           default:
             TProtocolUtil.skip(iprot, field.type);
             break;
         }
         iprot.readFieldEnd();
       }
       iprot.readStructEnd();
 
 
       // check for required fields of primitive type, which can't be checked in the validate method
       validate();
     }
 
     public void write(TProtocol oprot) throws TException {
       validate();
 
       oprot.writeStructBegin(STRUCT_DESC);
       if (this.keyspace != null) {
         oprot.writeFieldBegin(KEYSPACE_FIELD_DESC);
         oprot.writeString(this.keyspace);
         oprot.writeFieldEnd();
       }
       if (this.key != null) {
         oprot.writeFieldBegin(KEY_FIELD_DESC);
         oprot.writeString(this.key);
         oprot.writeFieldEnd();
       }
       if (this.column_parent != null) {
         oprot.writeFieldBegin(COLUMN_PARENT_FIELD_DESC);
         this.column_parent.write(oprot);
         oprot.writeFieldEnd();
       }
       oprot.writeFieldBegin(CONSISTENCY_LEVEL_FIELD_DESC);
       oprot.writeI32(this.consistency_level);
       oprot.writeFieldEnd();
       oprot.writeFieldStop();
       oprot.writeStructEnd();
     }
 
     @Override
     public String toString() {
       StringBuilder sb = new StringBuilder("get_count_args(");
       boolean first = true;
 
       sb.append("keyspace:");
       if (this.keyspace == null) {
         sb.append("null");
       } else {
         sb.append(this.keyspace);
       }
       first = false;
       if (!first) sb.append(", ");
       sb.append("key:");
       if (this.key == null) {
         sb.append("null");
       } else {
         sb.append(this.key);
       }
       first = false;
       if (!first) sb.append(", ");
       sb.append("column_parent:");
       if (this.column_parent == null) {
         sb.append("null");
       } else {
         sb.append(this.column_parent);
       }
       first = false;
       if (!first) sb.append(", ");
       sb.append("consistency_level:");
       String consistency_level_name = ConsistencyLevel.VALUES_TO_NAMES.get(this.consistency_level);
       if (consistency_level_name != null) {
         sb.append(consistency_level_name);
         sb.append(" (");
       }
       sb.append(this.consistency_level);
       if (consistency_level_name != null) {
         sb.append(")");
       }
       first = false;
       sb.append(")");
       return sb.toString();
     }
 
     public void validate() throws TException {
       // check for required fields
       // check that fields of type enum have valid values
       if (isSetConsistency_level() && !ConsistencyLevel.VALID_VALUES.contains(consistency_level)){
         throw new TProtocolException("The field 'consistency_level' has been assigned the invalid value " + consistency_level);
       }
     }
 
   }
 
   public static class get_count_result implements TBase, java.io.Serializable, Cloneable   {
     private static final TStruct STRUCT_DESC = new TStruct("get_count_result");
     private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.I32, (short)0);
     private static final TField IRE_FIELD_DESC = new TField("ire", TType.STRUCT, (short)1);
 
     public int success;
     public static final int SUCCESS = 0;
     public InvalidRequestException ire;
     public static final int IRE = 1;
 
     private final Isset __isset = new Isset();
     private static final class Isset implements java.io.Serializable {
       public boolean success = false;
     }
 
     public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
       put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
           new FieldValueMetaData(TType.I32)));
       put(IRE, new FieldMetaData("ire", TFieldRequirementType.DEFAULT, 
           new FieldValueMetaData(TType.STRUCT)));
     }});
 
     static {
       FieldMetaData.addStructMetaDataMap(get_count_result.class, metaDataMap);
     }
 
     public get_count_result() {
     }
 
     public get_count_result(
       int success,
       InvalidRequestException ire)
     {
       this();
       this.success = success;
       this.__isset.success = true;
       this.ire = ire;
     }
 
     /**
      * Performs a deep copy on <i>other</i>.
      */
     public get_count_result(get_count_result other) {
       __isset.success = other.__isset.success;
       this.success = other.success;
       if (other.isSetIre()) {
         this.ire = new InvalidRequestException(other.ire);
       }
     }
 
     @Override
     public get_count_result clone() {
       return new get_count_result(this);
     }
 
     public int getSuccess() {
       return this.success;
     }
 
    public get_count_result setSuccess(int success) {
       this.success = success;
       this.__isset.success = true;
      return this;
     }
 
     public void unsetSuccess() {
       this.__isset.success = false;
     }
 
     // Returns true if field success is set (has been asigned a value) and false otherwise
     public boolean isSetSuccess() {
       return this.__isset.success;
     }
 
     public void setSuccessIsSet(boolean value) {
       this.__isset.success = value;
     }
 
     public InvalidRequestException getIre() {
       return this.ire;
     }
 
    public get_count_result setIre(InvalidRequestException ire) {
       this.ire = ire;
      return this;
     }
 
     public void unsetIre() {
       this.ire = null;
     }
 
     // Returns true if field ire is set (has been asigned a value) and false otherwise
     public boolean isSetIre() {
       return this.ire != null;
     }
 
     public void setIreIsSet(boolean value) {
       if (!value) {
         this.ire = null;
       }
     }
 
     public void setFieldValue(int fieldID, Object value) {
       switch (fieldID) {
       case SUCCESS:
         if (value == null) {
           unsetSuccess();
         } else {
           setSuccess((Integer)value);
         }
         break;
 
       case IRE:
         if (value == null) {
           unsetIre();
         } else {
           setIre((InvalidRequestException)value);
         }
         break;
 
       default:
         throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
       }
     }
 
     public Object getFieldValue(int fieldID) {
       switch (fieldID) {
       case SUCCESS:
         return new Integer(getSuccess());
 
       case IRE:
         return getIre();
 
       default:
         throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
       }
     }
 
     // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
     public boolean isSet(int fieldID) {
       switch (fieldID) {
       case SUCCESS:
         return isSetSuccess();
       case IRE:
         return isSetIre();
       default:
         throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
       }
     }
 
     @Override
     public boolean equals(Object that) {
       if (that == null)
         return false;
       if (that instanceof get_count_result)
         return this.equals((get_count_result)that);
       return false;
     }
 
     public boolean equals(get_count_result that) {
       if (that == null)
         return false;
 
       boolean this_present_success = true;
       boolean that_present_success = true;
       if (this_present_success || that_present_success) {
         if (!(this_present_success && that_present_success))
           return false;
         if (this.success != that.success)
           return false;
       }
 
       boolean this_present_ire = true && this.isSetIre();
       boolean that_present_ire = true && that.isSetIre();
       if (this_present_ire || that_present_ire) {
         if (!(this_present_ire && that_present_ire))
           return false;
         if (!this.ire.equals(that.ire))
           return false;
       }
 
       return true;
     }
 
     @Override
     public int hashCode() {
       return 0;
     }
 
     public void read(TProtocol iprot) throws TException {
       TField field;
       iprot.readStructBegin();
       while (true)
       {
         field = iprot.readFieldBegin();
         if (field.type == TType.STOP) { 
           break;
         }
         switch (field.id)
         {
           case SUCCESS:
             if (field.type == TType.I32) {
               this.success = iprot.readI32();
               this.__isset.success = true;
             } else { 
               TProtocolUtil.skip(iprot, field.type);
             }
             break;
           case IRE:
             if (field.type == TType.STRUCT) {
               this.ire = new InvalidRequestException();
               this.ire.read(iprot);
             } else { 
               TProtocolUtil.skip(iprot, field.type);
             }
             break;
           default:
             TProtocolUtil.skip(iprot, field.type);
             break;
         }
         iprot.readFieldEnd();
       }
       iprot.readStructEnd();
 
 
       // check for required fields of primitive type, which can't be checked in the validate method
       validate();
     }
 
     public void write(TProtocol oprot) throws TException {
       oprot.writeStructBegin(STRUCT_DESC);
 
       if (this.isSetSuccess()) {
         oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
         oprot.writeI32(this.success);
         oprot.writeFieldEnd();
       } else if (this.isSetIre()) {
         oprot.writeFieldBegin(IRE_FIELD_DESC);
         this.ire.write(oprot);
         oprot.writeFieldEnd();
       }
       oprot.writeFieldStop();
       oprot.writeStructEnd();
     }
 
     @Override
     public String toString() {
       StringBuilder sb = new StringBuilder("get_count_result(");
       boolean first = true;
 
       sb.append("success:");
       sb.append(this.success);
       first = false;
       if (!first) sb.append(", ");
       sb.append("ire:");
       if (this.ire == null) {
         sb.append("null");
       } else {
         sb.append(this.ire);
       }
       first = false;
       sb.append(")");
       return sb.toString();
     }
 
     public void validate() throws TException {
       // check for required fields
       // check that fields of type enum have valid values
     }
 
   }
 
   public static class insert_args implements TBase, java.io.Serializable, Cloneable   {
     private static final TStruct STRUCT_DESC = new TStruct("insert_args");
     private static final TField KEYSPACE_FIELD_DESC = new TField("keyspace", TType.STRING, (short)1);
     private static final TField KEY_FIELD_DESC = new TField("key", TType.STRING, (short)2);
     private static final TField COLUMN_PATH_FIELD_DESC = new TField("column_path", TType.STRUCT, (short)3);
     private static final TField VALUE_FIELD_DESC = new TField("value", TType.STRING, (short)4);
     private static final TField TIMESTAMP_FIELD_DESC = new TField("timestamp", TType.I64, (short)5);
     private static final TField CONSISTENCY_LEVEL_FIELD_DESC = new TField("consistency_level", TType.I32, (short)6);
 
     public String keyspace;
     public static final int KEYSPACE = 1;
     public String key;
     public static final int KEY = 2;
     public ColumnPath column_path;
     public static final int COLUMN_PATH = 3;
     public byte[] value;
     public static final int VALUE = 4;
     public long timestamp;
     public static final int TIMESTAMP = 5;
    /**
     * 
     * @see ConsistencyLevel
     */
     public int consistency_level;
     public static final int CONSISTENCY_LEVEL = 6;
 
     private final Isset __isset = new Isset();
     private static final class Isset implements java.io.Serializable {
       public boolean timestamp = false;
       public boolean consistency_level = false;
     }
 
     public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
       put(KEYSPACE, new FieldMetaData("keyspace", TFieldRequirementType.DEFAULT, 
           new FieldValueMetaData(TType.STRING)));
       put(KEY, new FieldMetaData("key", TFieldRequirementType.DEFAULT, 
           new FieldValueMetaData(TType.STRING)));
       put(COLUMN_PATH, new FieldMetaData("column_path", TFieldRequirementType.DEFAULT, 
           new StructMetaData(TType.STRUCT, ColumnPath.class)));
       put(VALUE, new FieldMetaData("value", TFieldRequirementType.DEFAULT, 
           new FieldValueMetaData(TType.STRING)));
       put(TIMESTAMP, new FieldMetaData("timestamp", TFieldRequirementType.DEFAULT, 
           new FieldValueMetaData(TType.I64)));
       put(CONSISTENCY_LEVEL, new FieldMetaData("consistency_level", TFieldRequirementType.DEFAULT, 
           new FieldValueMetaData(TType.I32)));
     }});
 
     static {
       FieldMetaData.addStructMetaDataMap(insert_args.class, metaDataMap);
     }
 
     public insert_args() {
       this.consistency_level = 0;
 
     }
 
     public insert_args(
       String keyspace,
       String key,
       ColumnPath column_path,
       byte[] value,
       long timestamp,
       int consistency_level)
     {
       this();
       this.keyspace = keyspace;
       this.key = key;
       this.column_path = column_path;
       this.value = value;
       this.timestamp = timestamp;
       this.__isset.timestamp = true;
       this.consistency_level = consistency_level;
       this.__isset.consistency_level = true;
     }
 
     /**
      * Performs a deep copy on <i>other</i>.
      */
     public insert_args(insert_args other) {
       if (other.isSetKeyspace()) {
         this.keyspace = other.keyspace;
       }
       if (other.isSetKey()) {
         this.key = other.key;
       }
       if (other.isSetColumn_path()) {
         this.column_path = new ColumnPath(other.column_path);
       }
       if (other.isSetValue()) {
         this.value = new byte[other.value.length];
         System.arraycopy(other.value, 0, value, 0, other.value.length);
       }
       __isset.timestamp = other.__isset.timestamp;
       this.timestamp = other.timestamp;
       __isset.consistency_level = other.__isset.consistency_level;
       this.consistency_level = other.consistency_level;
     }
 
     @Override
     public insert_args clone() {
       return new insert_args(this);
     }
 
     public String getKeyspace() {
       return this.keyspace;
     }
 
    public insert_args setKeyspace(String keyspace) {
       this.keyspace = keyspace;
      return this;
     }
 
     public void unsetKeyspace() {
       this.keyspace = null;
     }
 
     // Returns true if field keyspace is set (has been asigned a value) and false otherwise
     public boolean isSetKeyspace() {
       return this.keyspace != null;
     }
 
     public void setKeyspaceIsSet(boolean value) {
       if (!value) {
         this.keyspace = null;
       }
     }
 
     public String getKey() {
       return this.key;
     }
 
    public insert_args setKey(String key) {
       this.key = key;
      return this;
     }
 
     public void unsetKey() {
       this.key = null;
     }
 
     // Returns true if field key is set (has been asigned a value) and false otherwise
     public boolean isSetKey() {
       return this.key != null;
     }
 
     public void setKeyIsSet(boolean value) {
       if (!value) {
         this.key = null;
       }
     }
 
     public ColumnPath getColumn_path() {
       return this.column_path;
     }
 
    public insert_args setColumn_path(ColumnPath column_path) {
       this.column_path = column_path;
      return this;
     }
 
     public void unsetColumn_path() {
       this.column_path = null;
     }
 
     // Returns true if field column_path is set (has been asigned a value) and false otherwise
     public boolean isSetColumn_path() {
       return this.column_path != null;
     }
 
     public void setColumn_pathIsSet(boolean value) {
       if (!value) {
         this.column_path = null;
       }
     }
 
     public byte[] getValue() {
       return this.value;
     }
 
    public insert_args setValue(byte[] value) {
       this.value = value;
      return this;
     }
 
     public void unsetValue() {
       this.value = null;
     }
 
     // Returns true if field value is set (has been asigned a value) and false otherwise
     public boolean isSetValue() {
       return this.value != null;
     }
 
     public void setValueIsSet(boolean value) {
       if (!value) {
         this.value = null;
       }
     }
 
     public long getTimestamp() {
       return this.timestamp;
     }
 
    public insert_args setTimestamp(long timestamp) {
       this.timestamp = timestamp;
       this.__isset.timestamp = true;
      return this;
     }
 
     public void unsetTimestamp() {
       this.__isset.timestamp = false;
     }
 
     // Returns true if field timestamp is set (has been asigned a value) and false otherwise
     public boolean isSetTimestamp() {
       return this.__isset.timestamp;
     }
 
     public void setTimestampIsSet(boolean value) {
       this.__isset.timestamp = value;
     }
 
    /**
     * 
     * @see ConsistencyLevel
     */
     public int getConsistency_level() {
       return this.consistency_level;
     }
 
    /**
     * 
     * @see ConsistencyLevel
     */
    public insert_args setConsistency_level(int consistency_level) {
       this.consistency_level = consistency_level;
       this.__isset.consistency_level = true;
      return this;
     }
 
     public void unsetConsistency_level() {
       this.__isset.consistency_level = false;
     }
 
     // Returns true if field consistency_level is set (has been asigned a value) and false otherwise
     public boolean isSetConsistency_level() {
       return this.__isset.consistency_level;
     }
 
     public void setConsistency_levelIsSet(boolean value) {
       this.__isset.consistency_level = value;
     }
 
     public void setFieldValue(int fieldID, Object value) {
       switch (fieldID) {
       case KEYSPACE:
         if (value == null) {
           unsetKeyspace();
         } else {
           setKeyspace((String)value);
         }
         break;
 
       case KEY:
         if (value == null) {
           unsetKey();
         } else {
           setKey((String)value);
         }
         break;
 
       case COLUMN_PATH:
         if (value == null) {
           unsetColumn_path();
         } else {
           setColumn_path((ColumnPath)value);
         }
         break;
 
       case VALUE:
         if (value == null) {
           unsetValue();
         } else {
           setValue((byte[])value);
         }
         break;
 
       case TIMESTAMP:
         if (value == null) {
           unsetTimestamp();
         } else {
           setTimestamp((Long)value);
         }
         break;
 
       case CONSISTENCY_LEVEL:
         if (value == null) {
           unsetConsistency_level();
         } else {
           setConsistency_level((Integer)value);
         }
         break;
 
       default:
         throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
       }
     }
 
     public Object getFieldValue(int fieldID) {
       switch (fieldID) {
       case KEYSPACE:
         return getKeyspace();
 
       case KEY:
         return getKey();
 
       case COLUMN_PATH:
         return getColumn_path();
 
       case VALUE:
         return getValue();
 
       case TIMESTAMP:
         return new Long(getTimestamp());
 
       case CONSISTENCY_LEVEL:
         return getConsistency_level();
 
       default:
         throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
       }
     }
 
     // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
     public boolean isSet(int fieldID) {
       switch (fieldID) {
       case KEYSPACE:
         return isSetKeyspace();
       case KEY:
         return isSetKey();
       case COLUMN_PATH:
         return isSetColumn_path();
       case VALUE:
         return isSetValue();
       case TIMESTAMP:
         return isSetTimestamp();
       case CONSISTENCY_LEVEL:
         return isSetConsistency_level();
       default:
         throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
       }
     }
 
     @Override
     public boolean equals(Object that) {
       if (that == null)
         return false;
       if (that instanceof insert_args)
         return this.equals((insert_args)that);
       return false;
     }
 
     public boolean equals(insert_args that) {
       if (that == null)
         return false;
 
       boolean this_present_keyspace = true && this.isSetKeyspace();
       boolean that_present_keyspace = true && that.isSetKeyspace();
       if (this_present_keyspace || that_present_keyspace) {
         if (!(this_present_keyspace && that_present_keyspace))
           return false;
         if (!this.keyspace.equals(that.keyspace))
           return false;
       }
 
       boolean this_present_key = true && this.isSetKey();
       boolean that_present_key = true && that.isSetKey();
       if (this_present_key || that_present_key) {
         if (!(this_present_key && that_present_key))
           return false;
         if (!this.key.equals(that.key))
           return false;
       }
 
       boolean this_present_column_path = true && this.isSetColumn_path();
       boolean that_present_column_path = true && that.isSetColumn_path();
       if (this_present_column_path || that_present_column_path) {
         if (!(this_present_column_path && that_present_column_path))
           return false;
         if (!this.column_path.equals(that.column_path))
           return false;
       }
 
       boolean this_present_value = true && this.isSetValue();
       boolean that_present_value = true && that.isSetValue();
       if (this_present_value || that_present_value) {
         if (!(this_present_value && that_present_value))
           return false;
         if (!java.util.Arrays.equals(this.value, that.value))
           return false;
       }
 
       boolean this_present_timestamp = true;
       boolean that_present_timestamp = true;
       if (this_present_timestamp || that_present_timestamp) {
         if (!(this_present_timestamp && that_present_timestamp))
           return false;
         if (this.timestamp != that.timestamp)
           return false;
       }
 
       boolean this_present_consistency_level = true;
       boolean that_present_consistency_level = true;
       if (this_present_consistency_level || that_present_consistency_level) {
         if (!(this_present_consistency_level && that_present_consistency_level))
           return false;
         if (this.consistency_level != that.consistency_level)
           return false;
       }
 
       return true;
     }
 
     @Override
     public int hashCode() {
       return 0;
     }
 
     public void read(TProtocol iprot) throws TException {
       TField field;
       iprot.readStructBegin();
       while (true)
       {
         field = iprot.readFieldBegin();
         if (field.type == TType.STOP) { 
           break;
         }
         switch (field.id)
         {
           case KEYSPACE:
             if (field.type == TType.STRING) {
               this.keyspace = iprot.readString();
             } else { 
               TProtocolUtil.skip(iprot, field.type);
             }
             break;
           case KEY:
             if (field.type == TType.STRING) {
               this.key = iprot.readString();
             } else { 
               TProtocolUtil.skip(iprot, field.type);
             }
             break;
           case COLUMN_PATH:
             if (field.type == TType.STRUCT) {
               this.column_path = new ColumnPath();
               this.column_path.read(iprot);
             } else { 
               TProtocolUtil.skip(iprot, field.type);
             }
             break;
           case VALUE:
             if (field.type == TType.STRING) {
               this.value = iprot.readBinary();
             } else { 
               TProtocolUtil.skip(iprot, field.type);
             }
             break;
           case TIMESTAMP:
             if (field.type == TType.I64) {
               this.timestamp = iprot.readI64();
               this.__isset.timestamp = true;
             } else { 
               TProtocolUtil.skip(iprot, field.type);
             }
             break;
           case CONSISTENCY_LEVEL:
             if (field.type == TType.I32) {
               this.consistency_level = iprot.readI32();
               this.__isset.consistency_level = true;
             } else { 
               TProtocolUtil.skip(iprot, field.type);
             }
             break;
           default:
             TProtocolUtil.skip(iprot, field.type);
             break;
         }
         iprot.readFieldEnd();
       }
       iprot.readStructEnd();
 
 
       // check for required fields of primitive type, which can't be checked in the validate method
       validate();
     }
 
     public void write(TProtocol oprot) throws TException {
       validate();
 
       oprot.writeStructBegin(STRUCT_DESC);
       if (this.keyspace != null) {
         oprot.writeFieldBegin(KEYSPACE_FIELD_DESC);
         oprot.writeString(this.keyspace);
         oprot.writeFieldEnd();
       }
       if (this.key != null) {
         oprot.writeFieldBegin(KEY_FIELD_DESC);
         oprot.writeString(this.key);
         oprot.writeFieldEnd();
       }
       if (this.column_path != null) {
         oprot.writeFieldBegin(COLUMN_PATH_FIELD_DESC);
         this.column_path.write(oprot);
         oprot.writeFieldEnd();
       }
       if (this.value != null) {
         oprot.writeFieldBegin(VALUE_FIELD_DESC);
         oprot.writeBinary(this.value);
         oprot.writeFieldEnd();
       }
       oprot.writeFieldBegin(TIMESTAMP_FIELD_DESC);
       oprot.writeI64(this.timestamp);
       oprot.writeFieldEnd();
       oprot.writeFieldBegin(CONSISTENCY_LEVEL_FIELD_DESC);
       oprot.writeI32(this.consistency_level);
       oprot.writeFieldEnd();
       oprot.writeFieldStop();
       oprot.writeStructEnd();
     }
 
     @Override
     public String toString() {
       StringBuilder sb = new StringBuilder("insert_args(");
       boolean first = true;
 
       sb.append("keyspace:");
       if (this.keyspace == null) {
         sb.append("null");
       } else {
         sb.append(this.keyspace);
       }
       first = false;
       if (!first) sb.append(", ");
       sb.append("key:");
       if (this.key == null) {
         sb.append("null");
       } else {
         sb.append(this.key);
       }
       first = false;
       if (!first) sb.append(", ");
       sb.append("column_path:");
       if (this.column_path == null) {
         sb.append("null");
       } else {
         sb.append(this.column_path);
       }
       first = false;
       if (!first) sb.append(", ");
       sb.append("value:");
       if (this.value == null) {
         sb.append("null");
       } else {
           int __value_size = Math.min(this.value.length, 128);
           for (int i = 0; i < __value_size; i++) {
             if (i != 0) sb.append(" ");
             sb.append(Integer.toHexString(this.value[i]).length() > 1 ? Integer.toHexString(this.value[i]).substring(Integer.toHexString(this.value[i]).length() - 2).toUpperCase() : "0" + Integer.toHexString(this.value[i]).toUpperCase());
           }
           if (this.value.length > 128) sb.append(" ...");
       }
       first = false;
       if (!first) sb.append(", ");
       sb.append("timestamp:");
       sb.append(this.timestamp);
       first = false;
       if (!first) sb.append(", ");
       sb.append("consistency_level:");
       String consistency_level_name = ConsistencyLevel.VALUES_TO_NAMES.get(this.consistency_level);
       if (consistency_level_name != null) {
         sb.append(consistency_level_name);
         sb.append(" (");
       }
       sb.append(this.consistency_level);
       if (consistency_level_name != null) {
         sb.append(")");
       }
       first = false;
       sb.append(")");
       return sb.toString();
     }
 
     public void validate() throws TException {
       // check for required fields
       // check that fields of type enum have valid values
       if (isSetConsistency_level() && !ConsistencyLevel.VALID_VALUES.contains(consistency_level)){
         throw new TProtocolException("The field 'consistency_level' has been assigned the invalid value " + consistency_level);
       }
     }
 
   }
 
   public static class insert_result implements TBase, java.io.Serializable, Cloneable   {
     private static final TStruct STRUCT_DESC = new TStruct("insert_result");
     private static final TField IRE_FIELD_DESC = new TField("ire", TType.STRUCT, (short)1);
     private static final TField UE_FIELD_DESC = new TField("ue", TType.STRUCT, (short)2);
 
     public InvalidRequestException ire;
     public static final int IRE = 1;
     public UnavailableException ue;
     public static final int UE = 2;
 
     private final Isset __isset = new Isset();
     private static final class Isset implements java.io.Serializable {
     }
 
     public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
       put(IRE, new FieldMetaData("ire", TFieldRequirementType.DEFAULT, 
           new FieldValueMetaData(TType.STRUCT)));
       put(UE, new FieldMetaData("ue", TFieldRequirementType.DEFAULT, 
           new FieldValueMetaData(TType.STRUCT)));
     }});
 
     static {
       FieldMetaData.addStructMetaDataMap(insert_result.class, metaDataMap);
     }
 
     public insert_result() {
     }
 
     public insert_result(
       InvalidRequestException ire,
       UnavailableException ue)
     {
       this();
       this.ire = ire;
       this.ue = ue;
     }
 
     /**
      * Performs a deep copy on <i>other</i>.
      */
     public insert_result(insert_result other) {
       if (other.isSetIre()) {
         this.ire = new InvalidRequestException(other.ire);
       }
       if (other.isSetUe()) {
         this.ue = new UnavailableException(other.ue);
       }
     }
 
     @Override
     public insert_result clone() {
       return new insert_result(this);
     }
 
     public InvalidRequestException getIre() {
       return this.ire;
     }
 
    public insert_result setIre(InvalidRequestException ire) {
       this.ire = ire;
      return this;
     }
 
     public void unsetIre() {
       this.ire = null;
     }
 
     // Returns true if field ire is set (has been asigned a value) and false otherwise
     public boolean isSetIre() {
       return this.ire != null;
     }
 
     public void setIreIsSet(boolean value) {
       if (!value) {
         this.ire = null;
       }
     }
 
     public UnavailableException getUe() {
       return this.ue;
     }
 
    public insert_result setUe(UnavailableException ue) {
       this.ue = ue;
      return this;
     }
 
     public void unsetUe() {
       this.ue = null;
     }
 
     // Returns true if field ue is set (has been asigned a value) and false otherwise
     public boolean isSetUe() {
       return this.ue != null;
     }
 
     public void setUeIsSet(boolean value) {
       if (!value) {
         this.ue = null;
       }
     }
 
     public void setFieldValue(int fieldID, Object value) {
       switch (fieldID) {
       case IRE:
         if (value == null) {
           unsetIre();
         } else {
           setIre((InvalidRequestException)value);
         }
         break;
 
       case UE:
         if (value == null) {
           unsetUe();
         } else {
           setUe((UnavailableException)value);
         }
         break;
 
       default:
         throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
       }
     }
 
     public Object getFieldValue(int fieldID) {
       switch (fieldID) {
       case IRE:
         return getIre();
 
       case UE:
         return getUe();
 
       default:
         throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
       }
     }
 
     // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
     public boolean isSet(int fieldID) {
       switch (fieldID) {
       case IRE:
         return isSetIre();
       case UE:
         return isSetUe();
       default:
         throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
       }
     }
 
     @Override
     public boolean equals(Object that) {
       if (that == null)
         return false;
       if (that instanceof insert_result)
         return this.equals((insert_result)that);
       return false;
     }
 
     public boolean equals(insert_result that) {
       if (that == null)
         return false;
 
       boolean this_present_ire = true && this.isSetIre();
       boolean that_present_ire = true && that.isSetIre();
       if (this_present_ire || that_present_ire) {
         if (!(this_present_ire && that_present_ire))
           return false;
         if (!this.ire.equals(that.ire))
           return false;
       }
 
       boolean this_present_ue = true && this.isSetUe();
       boolean that_present_ue = true && that.isSetUe();
       if (this_present_ue || that_present_ue) {
         if (!(this_present_ue && that_present_ue))
           return false;
         if (!this.ue.equals(that.ue))
           return false;
       }
 
       return true;
     }
 
     @Override
     public int hashCode() {
       return 0;
     }
 
     public void read(TProtocol iprot) throws TException {
       TField field;
       iprot.readStructBegin();
       while (true)
       {
         field = iprot.readFieldBegin();
         if (field.type == TType.STOP) { 
           break;
         }
         switch (field.id)
         {
           case IRE:
             if (field.type == TType.STRUCT) {
               this.ire = new InvalidRequestException();
               this.ire.read(iprot);
             } else { 
               TProtocolUtil.skip(iprot, field.type);
             }
             break;
           case UE:
             if (field.type == TType.STRUCT) {
               this.ue = new UnavailableException();
               this.ue.read(iprot);
             } else { 
               TProtocolUtil.skip(iprot, field.type);
             }
             break;
           default:
             TProtocolUtil.skip(iprot, field.type);
             break;
         }
         iprot.readFieldEnd();
       }
       iprot.readStructEnd();
 
 
       // check for required fields of primitive type, which can't be checked in the validate method
       validate();
     }
 
     public void write(TProtocol oprot) throws TException {
       oprot.writeStructBegin(STRUCT_DESC);
 
       if (this.isSetIre()) {
         oprot.writeFieldBegin(IRE_FIELD_DESC);
         this.ire.write(oprot);
         oprot.writeFieldEnd();
       } else if (this.isSetUe()) {
         oprot.writeFieldBegin(UE_FIELD_DESC);
         this.ue.write(oprot);
         oprot.writeFieldEnd();
       }
       oprot.writeFieldStop();
       oprot.writeStructEnd();
     }
 
     @Override
     public String toString() {
       StringBuilder sb = new StringBuilder("insert_result(");
       boolean first = true;
 
       sb.append("ire:");
       if (this.ire == null) {
         sb.append("null");
       } else {
         sb.append(this.ire);
       }
       first = false;
       if (!first) sb.append(", ");
       sb.append("ue:");
       if (this.ue == null) {
         sb.append("null");
       } else {
         sb.append(this.ue);
       }
       first = false;
       sb.append(")");
       return sb.toString();
     }
 
     public void validate() throws TException {
       // check for required fields
       // check that fields of type enum have valid values
     }
 
   }
 
   public static class batch_insert_args implements TBase, java.io.Serializable, Cloneable   {
     private static final TStruct STRUCT_DESC = new TStruct("batch_insert_args");
     private static final TField KEYSPACE_FIELD_DESC = new TField("keyspace", TType.STRING, (short)1);
     private static final TField BATCH_MUTATION_FIELD_DESC = new TField("batch_mutation", TType.STRUCT, (short)2);
     private static final TField CONSISTENCY_LEVEL_FIELD_DESC = new TField("consistency_level", TType.I32, (short)3);
 
     public String keyspace;
     public static final int KEYSPACE = 1;
     public BatchMutation batch_mutation;
     public static final int BATCH_MUTATION = 2;
    /**
     * 
     * @see ConsistencyLevel
     */
     public int consistency_level;
     public static final int CONSISTENCY_LEVEL = 3;
 
     private final Isset __isset = new Isset();
     private static final class Isset implements java.io.Serializable {
       public boolean consistency_level = false;
     }
 
     public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
       put(KEYSPACE, new FieldMetaData("keyspace", TFieldRequirementType.DEFAULT, 
           new FieldValueMetaData(TType.STRING)));
       put(BATCH_MUTATION, new FieldMetaData("batch_mutation", TFieldRequirementType.DEFAULT, 
           new StructMetaData(TType.STRUCT, BatchMutation.class)));
       put(CONSISTENCY_LEVEL, new FieldMetaData("consistency_level", TFieldRequirementType.DEFAULT, 
           new FieldValueMetaData(TType.I32)));
     }});
 
     static {
       FieldMetaData.addStructMetaDataMap(batch_insert_args.class, metaDataMap);
     }
 
     public batch_insert_args() {
       this.consistency_level = 0;
 
     }
 
     public batch_insert_args(
       String keyspace,
       BatchMutation batch_mutation,
       int consistency_level)
     {
       this();
       this.keyspace = keyspace;
       this.batch_mutation = batch_mutation;
       this.consistency_level = consistency_level;
       this.__isset.consistency_level = true;
     }
 
     /**
      * Performs a deep copy on <i>other</i>.
      */
     public batch_insert_args(batch_insert_args other) {
       if (other.isSetKeyspace()) {
         this.keyspace = other.keyspace;
       }
       if (other.isSetBatch_mutation()) {
         this.batch_mutation = new BatchMutation(other.batch_mutation);
       }
       __isset.consistency_level = other.__isset.consistency_level;
       this.consistency_level = other.consistency_level;
     }
 
     @Override
     public batch_insert_args clone() {
       return new batch_insert_args(this);
     }
 
     public String getKeyspace() {
       return this.keyspace;
     }
 
    public batch_insert_args setKeyspace(String keyspace) {
       this.keyspace = keyspace;
      return this;
     }
 
     public void unsetKeyspace() {
       this.keyspace = null;
     }
 
     // Returns true if field keyspace is set (has been asigned a value) and false otherwise
     public boolean isSetKeyspace() {
       return this.keyspace != null;
     }
 
     public void setKeyspaceIsSet(boolean value) {
       if (!value) {
         this.keyspace = null;
       }
     }
 
     public BatchMutation getBatch_mutation() {
       return this.batch_mutation;
     }
 
    public batch_insert_args setBatch_mutation(BatchMutation batch_mutation) {
       this.batch_mutation = batch_mutation;
      return this;
     }
 
     public void unsetBatch_mutation() {
       this.batch_mutation = null;
     }
 
     // Returns true if field batch_mutation is set (has been asigned a value) and false otherwise
     public boolean isSetBatch_mutation() {
       return this.batch_mutation != null;
     }
 
     public void setBatch_mutationIsSet(boolean value) {
       if (!value) {
         this.batch_mutation = null;
       }
     }
 
    /**
     * 
     * @see ConsistencyLevel
     */
     public int getConsistency_level() {
       return this.consistency_level;
     }
 
    /**
     * 
     * @see ConsistencyLevel
     */
    public batch_insert_args setConsistency_level(int consistency_level) {
       this.consistency_level = consistency_level;
       this.__isset.consistency_level = true;
      return this;
     }
 
     public void unsetConsistency_level() {
       this.__isset.consistency_level = false;
     }
 
     // Returns true if field consistency_level is set (has been asigned a value) and false otherwise
     public boolean isSetConsistency_level() {
       return this.__isset.consistency_level;
     }
 
     public void setConsistency_levelIsSet(boolean value) {
       this.__isset.consistency_level = value;
     }
 
     public void setFieldValue(int fieldID, Object value) {
       switch (fieldID) {
       case KEYSPACE:
         if (value == null) {
           unsetKeyspace();
         } else {
           setKeyspace((String)value);
         }
         break;
 
       case BATCH_MUTATION:
         if (value == null) {
           unsetBatch_mutation();
         } else {
           setBatch_mutation((BatchMutation)value);
         }
         break;
 
       case CONSISTENCY_LEVEL:
         if (value == null) {
           unsetConsistency_level();
         } else {
           setConsistency_level((Integer)value);
         }
         break;
 
       default:
         throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
       }
     }
 
     public Object getFieldValue(int fieldID) {
       switch (fieldID) {
       case KEYSPACE:
         return getKeyspace();
 
       case BATCH_MUTATION:
         return getBatch_mutation();
 
       case CONSISTENCY_LEVEL:
         return getConsistency_level();
 
       default:
         throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
       }
     }
 
     // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
     public boolean isSet(int fieldID) {
       switch (fieldID) {
       case KEYSPACE:
         return isSetKeyspace();
       case BATCH_MUTATION:
         return isSetBatch_mutation();
       case CONSISTENCY_LEVEL:
         return isSetConsistency_level();
       default:
         throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
       }
     }
 
     @Override
     public boolean equals(Object that) {
       if (that == null)
         return false;
       if (that instanceof batch_insert_args)
         return this.equals((batch_insert_args)that);
       return false;
     }
 
     public boolean equals(batch_insert_args that) {
       if (that == null)
         return false;
 
       boolean this_present_keyspace = true && this.isSetKeyspace();
       boolean that_present_keyspace = true && that.isSetKeyspace();
       if (this_present_keyspace || that_present_keyspace) {
         if (!(this_present_keyspace && that_present_keyspace))
           return false;
         if (!this.keyspace.equals(that.keyspace))
           return false;
       }
 
       boolean this_present_batch_mutation = true && this.isSetBatch_mutation();
       boolean that_present_batch_mutation = true && that.isSetBatch_mutation();
       if (this_present_batch_mutation || that_present_batch_mutation) {
         if (!(this_present_batch_mutation && that_present_batch_mutation))
           return false;
         if (!this.batch_mutation.equals(that.batch_mutation))
           return false;
       }
 
       boolean this_present_consistency_level = true;
       boolean that_present_consistency_level = true;
       if (this_present_consistency_level || that_present_consistency_level) {
         if (!(this_present_consistency_level && that_present_consistency_level))
           return false;
         if (this.consistency_level != that.consistency_level)
           return false;
       }
 
       return true;
     }
 
     @Override
     public int hashCode() {
       return 0;
     }
 
     public void read(TProtocol iprot) throws TException {
       TField field;
       iprot.readStructBegin();
       while (true)
       {
         field = iprot.readFieldBegin();
         if (field.type == TType.STOP) { 
           break;
         }
         switch (field.id)
         {
           case KEYSPACE:
             if (field.type == TType.STRING) {
               this.keyspace = iprot.readString();
             } else { 
               TProtocolUtil.skip(iprot, field.type);
             }
             break;
           case BATCH_MUTATION:
             if (field.type == TType.STRUCT) {
               this.batch_mutation = new BatchMutation();
               this.batch_mutation.read(iprot);
             } else { 
               TProtocolUtil.skip(iprot, field.type);
             }
             break;
           case CONSISTENCY_LEVEL:
             if (field.type == TType.I32) {
               this.consistency_level = iprot.readI32();
               this.__isset.consistency_level = true;
             } else { 
               TProtocolUtil.skip(iprot, field.type);
             }
             break;
           default:
             TProtocolUtil.skip(iprot, field.type);
             break;
         }
         iprot.readFieldEnd();
       }
       iprot.readStructEnd();
 
 
       // check for required fields of primitive type, which can't be checked in the validate method
       validate();
     }
 
     public void write(TProtocol oprot) throws TException {
       validate();
 
       oprot.writeStructBegin(STRUCT_DESC);
       if (this.keyspace != null) {
         oprot.writeFieldBegin(KEYSPACE_FIELD_DESC);
         oprot.writeString(this.keyspace);
         oprot.writeFieldEnd();
       }
       if (this.batch_mutation != null) {
         oprot.writeFieldBegin(BATCH_MUTATION_FIELD_DESC);
         this.batch_mutation.write(oprot);
         oprot.writeFieldEnd();
       }
       oprot.writeFieldBegin(CONSISTENCY_LEVEL_FIELD_DESC);
       oprot.writeI32(this.consistency_level);
       oprot.writeFieldEnd();
       oprot.writeFieldStop();
       oprot.writeStructEnd();
     }
 
     @Override
     public String toString() {
       StringBuilder sb = new StringBuilder("batch_insert_args(");
       boolean first = true;
 
       sb.append("keyspace:");
       if (this.keyspace == null) {
         sb.append("null");
       } else {
         sb.append(this.keyspace);
       }
       first = false;
       if (!first) sb.append(", ");
       sb.append("batch_mutation:");
       if (this.batch_mutation == null) {
         sb.append("null");
       } else {
         sb.append(this.batch_mutation);
       }
       first = false;
       if (!first) sb.append(", ");
       sb.append("consistency_level:");
       String consistency_level_name = ConsistencyLevel.VALUES_TO_NAMES.get(this.consistency_level);
       if (consistency_level_name != null) {
         sb.append(consistency_level_name);
         sb.append(" (");
       }
       sb.append(this.consistency_level);
       if (consistency_level_name != null) {
         sb.append(")");
       }
       first = false;
       sb.append(")");
       return sb.toString();
     }
 
     public void validate() throws TException {
       // check for required fields
       // check that fields of type enum have valid values
       if (isSetConsistency_level() && !ConsistencyLevel.VALID_VALUES.contains(consistency_level)){
         throw new TProtocolException("The field 'consistency_level' has been assigned the invalid value " + consistency_level);
       }
     }
 
   }
 
   public static class batch_insert_result implements TBase, java.io.Serializable, Cloneable   {
     private static final TStruct STRUCT_DESC = new TStruct("batch_insert_result");
     private static final TField IRE_FIELD_DESC = new TField("ire", TType.STRUCT, (short)1);
     private static final TField UE_FIELD_DESC = new TField("ue", TType.STRUCT, (short)2);
 
     public InvalidRequestException ire;
     public static final int IRE = 1;
     public UnavailableException ue;
     public static final int UE = 2;
 
     private final Isset __isset = new Isset();
     private static final class Isset implements java.io.Serializable {
     }
 
     public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
       put(IRE, new FieldMetaData("ire", TFieldRequirementType.DEFAULT, 
           new FieldValueMetaData(TType.STRUCT)));
       put(UE, new FieldMetaData("ue", TFieldRequirementType.DEFAULT, 
           new FieldValueMetaData(TType.STRUCT)));
     }});
 
     static {
       FieldMetaData.addStructMetaDataMap(batch_insert_result.class, metaDataMap);
     }
 
     public batch_insert_result() {
     }
 
     public batch_insert_result(
       InvalidRequestException ire,
       UnavailableException ue)
     {
       this();
       this.ire = ire;
       this.ue = ue;
     }
 
     /**
      * Performs a deep copy on <i>other</i>.
      */
     public batch_insert_result(batch_insert_result other) {
       if (other.isSetIre()) {
         this.ire = new InvalidRequestException(other.ire);
       }
       if (other.isSetUe()) {
         this.ue = new UnavailableException(other.ue);
       }
     }
 
     @Override
     public batch_insert_result clone() {
       return new batch_insert_result(this);
     }
 
     public InvalidRequestException getIre() {
       return this.ire;
     }
 
    public batch_insert_result setIre(InvalidRequestException ire) {
       this.ire = ire;
      return this;
     }
 
     public void unsetIre() {
       this.ire = null;
     }
 
     // Returns true if field ire is set (has been asigned a value) and false otherwise
     public boolean isSetIre() {
       return this.ire != null;
     }
 
     public void setIreIsSet(boolean value) {
       if (!value) {
         this.ire = null;
       }
     }
 
     public UnavailableException getUe() {
       return this.ue;
     }
 
    public batch_insert_result setUe(UnavailableException ue) {
       this.ue = ue;
      return this;
     }
 
     public void unsetUe() {
       this.ue = null;
     }
 
     // Returns true if field ue is set (has been asigned a value) and false otherwise
     public boolean isSetUe() {
       return this.ue != null;
     }
 
     public void setUeIsSet(boolean value) {
       if (!value) {
         this.ue = null;
       }
     }
 
     public void setFieldValue(int fieldID, Object value) {
       switch (fieldID) {
       case IRE:
         if (value == null) {
           unsetIre();
         } else {
           setIre((InvalidRequestException)value);
         }
         break;
 
       case UE:
         if (value == null) {
           unsetUe();
         } else {
           setUe((UnavailableException)value);
         }
         break;
 
       default:
         throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
       }
     }
 
     public Object getFieldValue(int fieldID) {
       switch (fieldID) {
       case IRE:
         return getIre();
 
       case UE:
         return getUe();
 
       default:
         throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
       }
     }
 
     // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
     public boolean isSet(int fieldID) {
       switch (fieldID) {
       case IRE:
         return isSetIre();
       case UE:
         return isSetUe();
       default:
         throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
       }
     }
 
     @Override
     public boolean equals(Object that) {
       if (that == null)
         return false;
       if (that instanceof batch_insert_result)
         return this.equals((batch_insert_result)that);
       return false;
     }
 
     public boolean equals(batch_insert_result that) {
       if (that == null)
         return false;
 
       boolean this_present_ire = true && this.isSetIre();
       boolean that_present_ire = true && that.isSetIre();
       if (this_present_ire || that_present_ire) {
         if (!(this_present_ire && that_present_ire))
           return false;
         if (!this.ire.equals(that.ire))
           return false;
       }
 
       boolean this_present_ue = true && this.isSetUe();
       boolean that_present_ue = true && that.isSetUe();
       if (this_present_ue || that_present_ue) {
         if (!(this_present_ue && that_present_ue))
           return false;
         if (!this.ue.equals(that.ue))
           return false;
       }
 
       return true;
     }
 
     @Override
     public int hashCode() {
       return 0;
     }
 
     public void read(TProtocol iprot) throws TException {
       TField field;
       iprot.readStructBegin();
       while (true)
       {
         field = iprot.readFieldBegin();
         if (field.type == TType.STOP) { 
           break;
         }
         switch (field.id)
         {
           case IRE:
             if (field.type == TType.STRUCT) {
               this.ire = new InvalidRequestException();
               this.ire.read(iprot);
             } else { 
               TProtocolUtil.skip(iprot, field.type);
             }
             break;
           case UE:
             if (field.type == TType.STRUCT) {
               this.ue = new UnavailableException();
               this.ue.read(iprot);
             } else { 
               TProtocolUtil.skip(iprot, field.type);
             }
             break;
           default:
             TProtocolUtil.skip(iprot, field.type);
             break;
         }
         iprot.readFieldEnd();
       }
       iprot.readStructEnd();
 
 
       // check for required fields of primitive type, which can't be checked in the validate method
       validate();
     }
 
     public void write(TProtocol oprot) throws TException {
       oprot.writeStructBegin(STRUCT_DESC);
 
       if (this.isSetIre()) {
         oprot.writeFieldBegin(IRE_FIELD_DESC);
         this.ire.write(oprot);
         oprot.writeFieldEnd();
       } else if (this.isSetUe()) {
         oprot.writeFieldBegin(UE_FIELD_DESC);
         this.ue.write(oprot);
         oprot.writeFieldEnd();
       }
       oprot.writeFieldStop();
       oprot.writeStructEnd();
     }
 
     @Override
     public String toString() {
       StringBuilder sb = new StringBuilder("batch_insert_result(");
       boolean first = true;
 
       sb.append("ire:");
       if (this.ire == null) {
         sb.append("null");
       } else {
         sb.append(this.ire);
       }
       first = false;
       if (!first) sb.append(", ");
       sb.append("ue:");
       if (this.ue == null) {
         sb.append("null");
       } else {
         sb.append(this.ue);
       }
       first = false;
       sb.append(")");
       return sb.toString();
     }
 
     public void validate() throws TException {
       // check for required fields
       // check that fields of type enum have valid values
     }
 
   }
 
   public static class remove_args implements TBase, java.io.Serializable, Cloneable   {
     private static final TStruct STRUCT_DESC = new TStruct("remove_args");
     private static final TField KEYSPACE_FIELD_DESC = new TField("keyspace", TType.STRING, (short)1);
     private static final TField KEY_FIELD_DESC = new TField("key", TType.STRING, (short)2);
    private static final TField COLUMN_PATH_FIELD_DESC = new TField("column_path", TType.STRUCT, (short)3);
     private static final TField TIMESTAMP_FIELD_DESC = new TField("timestamp", TType.I64, (short)4);
     private static final TField CONSISTENCY_LEVEL_FIELD_DESC = new TField("consistency_level", TType.I32, (short)5);
 
     public String keyspace;
     public static final int KEYSPACE = 1;
     public String key;
     public static final int KEY = 2;
    public ColumnPath column_path;
    public static final int COLUMN_PATH = 3;
     public long timestamp;
     public static final int TIMESTAMP = 4;
    /**
     * 
     * @see ConsistencyLevel
     */
     public int consistency_level;
     public static final int CONSISTENCY_LEVEL = 5;
 
     private final Isset __isset = new Isset();
     private static final class Isset implements java.io.Serializable {
       public boolean timestamp = false;
       public boolean consistency_level = false;
     }
 
     public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
       put(KEYSPACE, new FieldMetaData("keyspace", TFieldRequirementType.DEFAULT, 
           new FieldValueMetaData(TType.STRING)));
       put(KEY, new FieldMetaData("key", TFieldRequirementType.DEFAULT, 
           new FieldValueMetaData(TType.STRING)));
      put(COLUMN_PATH, new FieldMetaData("column_path", TFieldRequirementType.DEFAULT, 
           new StructMetaData(TType.STRUCT, ColumnPath.class)));
       put(TIMESTAMP, new FieldMetaData("timestamp", TFieldRequirementType.DEFAULT, 
           new FieldValueMetaData(TType.I64)));
       put(CONSISTENCY_LEVEL, new FieldMetaData("consistency_level", TFieldRequirementType.DEFAULT, 
           new FieldValueMetaData(TType.I32)));
     }});
 
     static {
       FieldMetaData.addStructMetaDataMap(remove_args.class, metaDataMap);
     }
 
     public remove_args() {
       this.consistency_level = 0;
 
     }
 
     public remove_args(
       String keyspace,
       String key,
      ColumnPath column_path,
       long timestamp,
       int consistency_level)
     {
       this();
       this.keyspace = keyspace;
       this.key = key;
      this.column_path = column_path;
       this.timestamp = timestamp;
       this.__isset.timestamp = true;
       this.consistency_level = consistency_level;
       this.__isset.consistency_level = true;
     }
 
     /**
      * Performs a deep copy on <i>other</i>.
      */
     public remove_args(remove_args other) {
       if (other.isSetKeyspace()) {
         this.keyspace = other.keyspace;
       }
       if (other.isSetKey()) {
         this.key = other.key;
       }
      if (other.isSetColumn_path()) {
        this.column_path = new ColumnPath(other.column_path);
       }
       __isset.timestamp = other.__isset.timestamp;
       this.timestamp = other.timestamp;
       __isset.consistency_level = other.__isset.consistency_level;
       this.consistency_level = other.consistency_level;
     }
 
     @Override
     public remove_args clone() {
       return new remove_args(this);
     }
 
     public String getKeyspace() {
       return this.keyspace;
     }
 
    public remove_args setKeyspace(String keyspace) {
       this.keyspace = keyspace;
      return this;
     }
 
     public void unsetKeyspace() {
       this.keyspace = null;
     }
 
     // Returns true if field keyspace is set (has been asigned a value) and false otherwise
     public boolean isSetKeyspace() {
       return this.keyspace != null;
     }
 
     public void setKeyspaceIsSet(boolean value) {
       if (!value) {
         this.keyspace = null;
       }
     }
 
     public String getKey() {
       return this.key;
     }
 
    public remove_args setKey(String key) {
       this.key = key;
      return this;
     }
 
     public void unsetKey() {
       this.key = null;
     }
 
     // Returns true if field key is set (has been asigned a value) and false otherwise
     public boolean isSetKey() {
       return this.key != null;
     }
 
     public void setKeyIsSet(boolean value) {
       if (!value) {
         this.key = null;
       }
     }
 
    public ColumnPath getColumn_path() {
      return this.column_path;
     }
 
    public remove_args setColumn_path(ColumnPath column_path) {
      this.column_path = column_path;
      return this;
     }
 
    public void unsetColumn_path() {
      this.column_path = null;
     }
 
    // Returns true if field column_path is set (has been asigned a value) and false otherwise
    public boolean isSetColumn_path() {
      return this.column_path != null;
     }
 
    public void setColumn_pathIsSet(boolean value) {
       if (!value) {
        this.column_path = null;
       }
     }
 
     public long getTimestamp() {
       return this.timestamp;
     }
 
    public remove_args setTimestamp(long timestamp) {
       this.timestamp = timestamp;
       this.__isset.timestamp = true;
      return this;
     }
 
     public void unsetTimestamp() {
       this.__isset.timestamp = false;
     }
 
     // Returns true if field timestamp is set (has been asigned a value) and false otherwise
     public boolean isSetTimestamp() {
       return this.__isset.timestamp;
     }
 
     public void setTimestampIsSet(boolean value) {
       this.__isset.timestamp = value;
     }
 
    /**
     * 
     * @see ConsistencyLevel
     */
     public int getConsistency_level() {
       return this.consistency_level;
     }
 
    /**
     * 
     * @see ConsistencyLevel
     */
    public remove_args setConsistency_level(int consistency_level) {
       this.consistency_level = consistency_level;
       this.__isset.consistency_level = true;
      return this;
     }
 
     public void unsetConsistency_level() {
       this.__isset.consistency_level = false;
     }
 
     // Returns true if field consistency_level is set (has been asigned a value) and false otherwise
     public boolean isSetConsistency_level() {
       return this.__isset.consistency_level;
     }
 
     public void setConsistency_levelIsSet(boolean value) {
       this.__isset.consistency_level = value;
     }
 
     public void setFieldValue(int fieldID, Object value) {
       switch (fieldID) {
       case KEYSPACE:
         if (value == null) {
           unsetKeyspace();
         } else {
           setKeyspace((String)value);
         }
         break;
 
       case KEY:
         if (value == null) {
           unsetKey();
         } else {
           setKey((String)value);
         }
         break;
 
      case COLUMN_PATH:
         if (value == null) {
          unsetColumn_path();
         } else {
          setColumn_path((ColumnPath)value);
         }
         break;
 
       case TIMESTAMP:
         if (value == null) {
           unsetTimestamp();
         } else {
           setTimestamp((Long)value);
         }
         break;
 
       case CONSISTENCY_LEVEL:
         if (value == null) {
           unsetConsistency_level();
         } else {
           setConsistency_level((Integer)value);
         }
         break;
 
       default:
         throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
       }
     }
 
     public Object getFieldValue(int fieldID) {
       switch (fieldID) {
       case KEYSPACE:
         return getKeyspace();
 
       case KEY:
         return getKey();
 
      case COLUMN_PATH:
        return getColumn_path();
 
       case TIMESTAMP:
         return new Long(getTimestamp());
 
       case CONSISTENCY_LEVEL:
         return getConsistency_level();
 
       default:
         throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
       }
     }
 
     // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
     public boolean isSet(int fieldID) {
       switch (fieldID) {
       case KEYSPACE:
         return isSetKeyspace();
       case KEY:
         return isSetKey();
      case COLUMN_PATH:
        return isSetColumn_path();
       case TIMESTAMP:
         return isSetTimestamp();
       case CONSISTENCY_LEVEL:
         return isSetConsistency_level();
       default:
         throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
       }
     }
 
     @Override
     public boolean equals(Object that) {
       if (that == null)
         return false;
       if (that instanceof remove_args)
         return this.equals((remove_args)that);
       return false;
     }
 
     public boolean equals(remove_args that) {
       if (that == null)
         return false;
 
       boolean this_present_keyspace = true && this.isSetKeyspace();
       boolean that_present_keyspace = true && that.isSetKeyspace();
       if (this_present_keyspace || that_present_keyspace) {
         if (!(this_present_keyspace && that_present_keyspace))
           return false;
         if (!this.keyspace.equals(that.keyspace))
           return false;
       }
 
       boolean this_present_key = true && this.isSetKey();
       boolean that_present_key = true && that.isSetKey();
       if (this_present_key || that_present_key) {
         if (!(this_present_key && that_present_key))
           return false;
         if (!this.key.equals(that.key))
           return false;
       }
 
      boolean this_present_column_path = true && this.isSetColumn_path();
      boolean that_present_column_path = true && that.isSetColumn_path();
      if (this_present_column_path || that_present_column_path) {
        if (!(this_present_column_path && that_present_column_path))
           return false;
        if (!this.column_path.equals(that.column_path))
           return false;
       }
 
       boolean this_present_timestamp = true;
       boolean that_present_timestamp = true;
       if (this_present_timestamp || that_present_timestamp) {
         if (!(this_present_timestamp && that_present_timestamp))
           return false;
         if (this.timestamp != that.timestamp)
           return false;
       }
 
       boolean this_present_consistency_level = true;
       boolean that_present_consistency_level = true;
       if (this_present_consistency_level || that_present_consistency_level) {
         if (!(this_present_consistency_level && that_present_consistency_level))
           return false;
         if (this.consistency_level != that.consistency_level)
           return false;
       }
 
       return true;
     }
 
     @Override
     public int hashCode() {
       return 0;
     }
 
     public void read(TProtocol iprot) throws TException {
       TField field;
       iprot.readStructBegin();
       while (true)
       {
         field = iprot.readFieldBegin();
         if (field.type == TType.STOP) { 
           break;
         }
         switch (field.id)
         {
           case KEYSPACE:
             if (field.type == TType.STRING) {
               this.keyspace = iprot.readString();
             } else { 
               TProtocolUtil.skip(iprot, field.type);
             }
             break;
           case KEY:
             if (field.type == TType.STRING) {
               this.key = iprot.readString();
             } else { 
               TProtocolUtil.skip(iprot, field.type);
             }
             break;
          case COLUMN_PATH:
             if (field.type == TType.STRUCT) {
              this.column_path = new ColumnPath();
              this.column_path.read(iprot);
             } else { 
               TProtocolUtil.skip(iprot, field.type);
             }
             break;
           case TIMESTAMP:
             if (field.type == TType.I64) {
               this.timestamp = iprot.readI64();
               this.__isset.timestamp = true;
             } else { 
               TProtocolUtil.skip(iprot, field.type);
             }
             break;
           case CONSISTENCY_LEVEL:
             if (field.type == TType.I32) {
               this.consistency_level = iprot.readI32();
               this.__isset.consistency_level = true;
             } else { 
               TProtocolUtil.skip(iprot, field.type);
             }
             break;
           default:
             TProtocolUtil.skip(iprot, field.type);
             break;
         }
         iprot.readFieldEnd();
       }
       iprot.readStructEnd();
 
 
       // check for required fields of primitive type, which can't be checked in the validate method
       validate();
     }
 
     public void write(TProtocol oprot) throws TException {
       validate();
 
       oprot.writeStructBegin(STRUCT_DESC);
       if (this.keyspace != null) {
         oprot.writeFieldBegin(KEYSPACE_FIELD_DESC);
         oprot.writeString(this.keyspace);
         oprot.writeFieldEnd();
       }
       if (this.key != null) {
         oprot.writeFieldBegin(KEY_FIELD_DESC);
         oprot.writeString(this.key);
         oprot.writeFieldEnd();
       }
      if (this.column_path != null) {
        oprot.writeFieldBegin(COLUMN_PATH_FIELD_DESC);
        this.column_path.write(oprot);
         oprot.writeFieldEnd();
       }
       oprot.writeFieldBegin(TIMESTAMP_FIELD_DESC);
       oprot.writeI64(this.timestamp);
       oprot.writeFieldEnd();
       oprot.writeFieldBegin(CONSISTENCY_LEVEL_FIELD_DESC);
       oprot.writeI32(this.consistency_level);
       oprot.writeFieldEnd();
       oprot.writeFieldStop();
       oprot.writeStructEnd();
     }
 
     @Override
     public String toString() {
       StringBuilder sb = new StringBuilder("remove_args(");
       boolean first = true;
 
       sb.append("keyspace:");
       if (this.keyspace == null) {
         sb.append("null");
       } else {
         sb.append(this.keyspace);
       }
       first = false;
       if (!first) sb.append(", ");
       sb.append("key:");
       if (this.key == null) {
         sb.append("null");
       } else {
         sb.append(this.key);
       }
       first = false;
       if (!first) sb.append(", ");
      sb.append("column_path:");
      if (this.column_path == null) {
         sb.append("null");
       } else {
        sb.append(this.column_path);
       }
       first = false;
       if (!first) sb.append(", ");
       sb.append("timestamp:");
       sb.append(this.timestamp);
       first = false;
       if (!first) sb.append(", ");
       sb.append("consistency_level:");
       String consistency_level_name = ConsistencyLevel.VALUES_TO_NAMES.get(this.consistency_level);
       if (consistency_level_name != null) {
         sb.append(consistency_level_name);
         sb.append(" (");
       }
       sb.append(this.consistency_level);
       if (consistency_level_name != null) {
         sb.append(")");
       }
       first = false;
       sb.append(")");
       return sb.toString();
     }
 
     public void validate() throws TException {
       // check for required fields
       // check that fields of type enum have valid values
       if (isSetConsistency_level() && !ConsistencyLevel.VALID_VALUES.contains(consistency_level)){
         throw new TProtocolException("The field 'consistency_level' has been assigned the invalid value " + consistency_level);
       }
     }
 
   }
 
   public static class remove_result implements TBase, java.io.Serializable, Cloneable   {
     private static final TStruct STRUCT_DESC = new TStruct("remove_result");
     private static final TField IRE_FIELD_DESC = new TField("ire", TType.STRUCT, (short)1);
     private static final TField UE_FIELD_DESC = new TField("ue", TType.STRUCT, (short)2);
 
     public InvalidRequestException ire;
     public static final int IRE = 1;
     public UnavailableException ue;
     public static final int UE = 2;
 
     private final Isset __isset = new Isset();
     private static final class Isset implements java.io.Serializable {
     }
 
     public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
       put(IRE, new FieldMetaData("ire", TFieldRequirementType.DEFAULT, 
           new FieldValueMetaData(TType.STRUCT)));
       put(UE, new FieldMetaData("ue", TFieldRequirementType.DEFAULT, 
           new FieldValueMetaData(TType.STRUCT)));
     }});
 
     static {
       FieldMetaData.addStructMetaDataMap(remove_result.class, metaDataMap);
     }
 
     public remove_result() {
     }
 
     public remove_result(
       InvalidRequestException ire,
       UnavailableException ue)
     {
       this();
       this.ire = ire;
       this.ue = ue;
     }
 
     /**
      * Performs a deep copy on <i>other</i>.
      */
     public remove_result(remove_result other) {
       if (other.isSetIre()) {
         this.ire = new InvalidRequestException(other.ire);
       }
       if (other.isSetUe()) {
         this.ue = new UnavailableException(other.ue);
       }
     }
 
     @Override
     public remove_result clone() {
       return new remove_result(this);
     }
 
     public InvalidRequestException getIre() {
       return this.ire;
     }
 
    public remove_result setIre(InvalidRequestException ire) {
       this.ire = ire;
      return this;
     }
 
     public void unsetIre() {
       this.ire = null;
     }
 
     // Returns true if field ire is set (has been asigned a value) and false otherwise
     public boolean isSetIre() {
       return this.ire != null;
     }
 
     public void setIreIsSet(boolean value) {
       if (!value) {
         this.ire = null;
       }
     }
 
     public UnavailableException getUe() {
       return this.ue;
     }
 
    public remove_result setUe(UnavailableException ue) {
       this.ue = ue;
      return this;
     }
 
     public void unsetUe() {
       this.ue = null;
     }
 
     // Returns true if field ue is set (has been asigned a value) and false otherwise
     public boolean isSetUe() {
       return this.ue != null;
     }
 
     public void setUeIsSet(boolean value) {
       if (!value) {
         this.ue = null;
       }
     }
 
     public void setFieldValue(int fieldID, Object value) {
       switch (fieldID) {
       case IRE:
         if (value == null) {
           unsetIre();
         } else {
           setIre((InvalidRequestException)value);
         }
         break;
 
       case UE:
         if (value == null) {
           unsetUe();
         } else {
           setUe((UnavailableException)value);
         }
         break;
 
       default:
         throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
       }
     }
 
     public Object getFieldValue(int fieldID) {
       switch (fieldID) {
       case IRE:
         return getIre();
 
       case UE:
         return getUe();
 
       default:
         throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
       }
     }
 
     // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
     public boolean isSet(int fieldID) {
       switch (fieldID) {
       case IRE:
         return isSetIre();
       case UE:
         return isSetUe();
       default:
         throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
       }
     }
 
     @Override
     public boolean equals(Object that) {
       if (that == null)
         return false;
       if (that instanceof remove_result)
         return this.equals((remove_result)that);
       return false;
     }
 
     public boolean equals(remove_result that) {
       if (that == null)
         return false;
 
       boolean this_present_ire = true && this.isSetIre();
       boolean that_present_ire = true && that.isSetIre();
       if (this_present_ire || that_present_ire) {
         if (!(this_present_ire && that_present_ire))
           return false;
         if (!this.ire.equals(that.ire))
           return false;
       }
 
       boolean this_present_ue = true && this.isSetUe();
       boolean that_present_ue = true && that.isSetUe();
       if (this_present_ue || that_present_ue) {
         if (!(this_present_ue && that_present_ue))
           return false;
         if (!this.ue.equals(that.ue))
           return false;
       }
 
       return true;
     }
 
     @Override
     public int hashCode() {
       return 0;
     }
 
     public void read(TProtocol iprot) throws TException {
       TField field;
       iprot.readStructBegin();
       while (true)
       {
         field = iprot.readFieldBegin();
         if (field.type == TType.STOP) { 
           break;
         }
         switch (field.id)
         {
           case IRE:
             if (field.type == TType.STRUCT) {
               this.ire = new InvalidRequestException();
               this.ire.read(iprot);
             } else { 
               TProtocolUtil.skip(iprot, field.type);
             }
             break;
           case UE:
             if (field.type == TType.STRUCT) {
               this.ue = new UnavailableException();
               this.ue.read(iprot);
             } else { 
               TProtocolUtil.skip(iprot, field.type);
             }
             break;
           default:
             TProtocolUtil.skip(iprot, field.type);
             break;
         }
         iprot.readFieldEnd();
       }
       iprot.readStructEnd();
 
 
       // check for required fields of primitive type, which can't be checked in the validate method
       validate();
     }
 
     public void write(TProtocol oprot) throws TException {
       oprot.writeStructBegin(STRUCT_DESC);
 
       if (this.isSetIre()) {
         oprot.writeFieldBegin(IRE_FIELD_DESC);
         this.ire.write(oprot);
         oprot.writeFieldEnd();
       } else if (this.isSetUe()) {
         oprot.writeFieldBegin(UE_FIELD_DESC);
         this.ue.write(oprot);
         oprot.writeFieldEnd();
       }
       oprot.writeFieldStop();
       oprot.writeStructEnd();
     }
 
     @Override
     public String toString() {
       StringBuilder sb = new StringBuilder("remove_result(");
       boolean first = true;
 
       sb.append("ire:");
       if (this.ire == null) {
         sb.append("null");
       } else {
         sb.append(this.ire);
       }
       first = false;
       if (!first) sb.append(", ");
       sb.append("ue:");
       if (this.ue == null) {
         sb.append("null");
       } else {
         sb.append(this.ue);
       }
       first = false;
       sb.append(")");
       return sb.toString();
     }
 
     public void validate() throws TException {
       // check for required fields
       // check that fields of type enum have valid values
     }
 
   }
 
   public static class batch_insert_super_column_args implements TBase, java.io.Serializable, Cloneable   {
     private static final TStruct STRUCT_DESC = new TStruct("batch_insert_super_column_args");
     private static final TField KEYSPACE_FIELD_DESC = new TField("keyspace", TType.STRING, (short)1);
     private static final TField BATCH_MUTATION_SUPER_FIELD_DESC = new TField("batch_mutation_super", TType.STRUCT, (short)2);
     private static final TField CONSISTENCY_LEVEL_FIELD_DESC = new TField("consistency_level", TType.I32, (short)3);
 
     public String keyspace;
     public static final int KEYSPACE = 1;
     public BatchMutationSuper batch_mutation_super;
     public static final int BATCH_MUTATION_SUPER = 2;
    /**
     * 
     * @see ConsistencyLevel
     */
     public int consistency_level;
     public static final int CONSISTENCY_LEVEL = 3;
 
     private final Isset __isset = new Isset();
     private static final class Isset implements java.io.Serializable {
       public boolean consistency_level = false;
     }
 
     public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
       put(KEYSPACE, new FieldMetaData("keyspace", TFieldRequirementType.DEFAULT, 
           new FieldValueMetaData(TType.STRING)));
       put(BATCH_MUTATION_SUPER, new FieldMetaData("batch_mutation_super", TFieldRequirementType.DEFAULT, 
           new StructMetaData(TType.STRUCT, BatchMutationSuper.class)));
       put(CONSISTENCY_LEVEL, new FieldMetaData("consistency_level", TFieldRequirementType.DEFAULT, 
           new FieldValueMetaData(TType.I32)));
     }});
 
     static {
       FieldMetaData.addStructMetaDataMap(batch_insert_super_column_args.class, metaDataMap);
     }
 
     public batch_insert_super_column_args() {
       this.consistency_level = 0;
 
     }
 
     public batch_insert_super_column_args(
       String keyspace,
       BatchMutationSuper batch_mutation_super,
       int consistency_level)
     {
       this();
       this.keyspace = keyspace;
       this.batch_mutation_super = batch_mutation_super;
       this.consistency_level = consistency_level;
       this.__isset.consistency_level = true;
     }
 
     /**
      * Performs a deep copy on <i>other</i>.
      */
     public batch_insert_super_column_args(batch_insert_super_column_args other) {
       if (other.isSetKeyspace()) {
         this.keyspace = other.keyspace;
       }
       if (other.isSetBatch_mutation_super()) {
         this.batch_mutation_super = new BatchMutationSuper(other.batch_mutation_super);
       }
       __isset.consistency_level = other.__isset.consistency_level;
       this.consistency_level = other.consistency_level;
     }
 
     @Override
     public batch_insert_super_column_args clone() {
       return new batch_insert_super_column_args(this);
     }
 
     public String getKeyspace() {
       return this.keyspace;
     }
 
    public batch_insert_super_column_args setKeyspace(String keyspace) {
       this.keyspace = keyspace;
      return this;
     }
 
     public void unsetKeyspace() {
       this.keyspace = null;
     }
 
     // Returns true if field keyspace is set (has been asigned a value) and false otherwise
     public boolean isSetKeyspace() {
       return this.keyspace != null;
     }
 
     public void setKeyspaceIsSet(boolean value) {
       if (!value) {
         this.keyspace = null;
       }
     }
 
     public BatchMutationSuper getBatch_mutation_super() {
       return this.batch_mutation_super;
     }
 
    public batch_insert_super_column_args setBatch_mutation_super(BatchMutationSuper batch_mutation_super) {
       this.batch_mutation_super = batch_mutation_super;
      return this;
     }
 
     public void unsetBatch_mutation_super() {
       this.batch_mutation_super = null;
     }
 
     // Returns true if field batch_mutation_super is set (has been asigned a value) and false otherwise
     public boolean isSetBatch_mutation_super() {
       return this.batch_mutation_super != null;
     }
 
     public void setBatch_mutation_superIsSet(boolean value) {
       if (!value) {
         this.batch_mutation_super = null;
       }
     }
 
    /**
     * 
     * @see ConsistencyLevel
     */
     public int getConsistency_level() {
       return this.consistency_level;
     }
 
    /**
     * 
     * @see ConsistencyLevel
     */
    public batch_insert_super_column_args setConsistency_level(int consistency_level) {
       this.consistency_level = consistency_level;
       this.__isset.consistency_level = true;
      return this;
     }
 
     public void unsetConsistency_level() {
       this.__isset.consistency_level = false;
     }
 
     // Returns true if field consistency_level is set (has been asigned a value) and false otherwise
     public boolean isSetConsistency_level() {
       return this.__isset.consistency_level;
     }
 
     public void setConsistency_levelIsSet(boolean value) {
       this.__isset.consistency_level = value;
     }
 
     public void setFieldValue(int fieldID, Object value) {
       switch (fieldID) {
       case KEYSPACE:
         if (value == null) {
           unsetKeyspace();
         } else {
           setKeyspace((String)value);
         }
         break;
 
       case BATCH_MUTATION_SUPER:
         if (value == null) {
           unsetBatch_mutation_super();
         } else {
           setBatch_mutation_super((BatchMutationSuper)value);
         }
         break;
 
       case CONSISTENCY_LEVEL:
         if (value == null) {
           unsetConsistency_level();
         } else {
           setConsistency_level((Integer)value);
         }
         break;
 
       default:
         throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
       }
     }
 
     public Object getFieldValue(int fieldID) {
       switch (fieldID) {
       case KEYSPACE:
         return getKeyspace();
 
       case BATCH_MUTATION_SUPER:
         return getBatch_mutation_super();
 
       case CONSISTENCY_LEVEL:
         return getConsistency_level();
 
       default:
         throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
       }
     }
 
     // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
     public boolean isSet(int fieldID) {
       switch (fieldID) {
       case KEYSPACE:
         return isSetKeyspace();
       case BATCH_MUTATION_SUPER:
         return isSetBatch_mutation_super();
       case CONSISTENCY_LEVEL:
         return isSetConsistency_level();
       default:
         throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
       }
     }
 
     @Override
     public boolean equals(Object that) {
       if (that == null)
         return false;
       if (that instanceof batch_insert_super_column_args)
         return this.equals((batch_insert_super_column_args)that);
       return false;
     }
 
     public boolean equals(batch_insert_super_column_args that) {
       if (that == null)
         return false;
 
       boolean this_present_keyspace = true && this.isSetKeyspace();
       boolean that_present_keyspace = true && that.isSetKeyspace();
       if (this_present_keyspace || that_present_keyspace) {
         if (!(this_present_keyspace && that_present_keyspace))
           return false;
         if (!this.keyspace.equals(that.keyspace))
           return false;
       }
 
       boolean this_present_batch_mutation_super = true && this.isSetBatch_mutation_super();
       boolean that_present_batch_mutation_super = true && that.isSetBatch_mutation_super();
       if (this_present_batch_mutation_super || that_present_batch_mutation_super) {
         if (!(this_present_batch_mutation_super && that_present_batch_mutation_super))
           return false;
         if (!this.batch_mutation_super.equals(that.batch_mutation_super))
           return false;
       }
 
       boolean this_present_consistency_level = true;
       boolean that_present_consistency_level = true;
       if (this_present_consistency_level || that_present_consistency_level) {
         if (!(this_present_consistency_level && that_present_consistency_level))
           return false;
         if (this.consistency_level != that.consistency_level)
           return false;
       }
 
       return true;
     }
 
     @Override
     public int hashCode() {
       return 0;
     }
 
     public void read(TProtocol iprot) throws TException {
       TField field;
       iprot.readStructBegin();
       while (true)
       {
         field = iprot.readFieldBegin();
         if (field.type == TType.STOP) { 
           break;
         }
         switch (field.id)
         {
           case KEYSPACE:
             if (field.type == TType.STRING) {
               this.keyspace = iprot.readString();
             } else { 
               TProtocolUtil.skip(iprot, field.type);
             }
             break;
           case BATCH_MUTATION_SUPER:
             if (field.type == TType.STRUCT) {
               this.batch_mutation_super = new BatchMutationSuper();
               this.batch_mutation_super.read(iprot);
             } else { 
               TProtocolUtil.skip(iprot, field.type);
             }
             break;
           case CONSISTENCY_LEVEL:
             if (field.type == TType.I32) {
               this.consistency_level = iprot.readI32();
               this.__isset.consistency_level = true;
             } else { 
               TProtocolUtil.skip(iprot, field.type);
             }
             break;
           default:
             TProtocolUtil.skip(iprot, field.type);
             break;
         }
         iprot.readFieldEnd();
       }
       iprot.readStructEnd();
 
 
       // check for required fields of primitive type, which can't be checked in the validate method
       validate();
     }
 
     public void write(TProtocol oprot) throws TException {
       validate();
 
       oprot.writeStructBegin(STRUCT_DESC);
       if (this.keyspace != null) {
         oprot.writeFieldBegin(KEYSPACE_FIELD_DESC);
         oprot.writeString(this.keyspace);
         oprot.writeFieldEnd();
       }
       if (this.batch_mutation_super != null) {
         oprot.writeFieldBegin(BATCH_MUTATION_SUPER_FIELD_DESC);
         this.batch_mutation_super.write(oprot);
         oprot.writeFieldEnd();
       }
       oprot.writeFieldBegin(CONSISTENCY_LEVEL_FIELD_DESC);
       oprot.writeI32(this.consistency_level);
       oprot.writeFieldEnd();
       oprot.writeFieldStop();
       oprot.writeStructEnd();
     }
 
     @Override
     public String toString() {
       StringBuilder sb = new StringBuilder("batch_insert_super_column_args(");
       boolean first = true;
 
       sb.append("keyspace:");
       if (this.keyspace == null) {
         sb.append("null");
       } else {
         sb.append(this.keyspace);
       }
       first = false;
       if (!first) sb.append(", ");
       sb.append("batch_mutation_super:");
       if (this.batch_mutation_super == null) {
         sb.append("null");
       } else {
         sb.append(this.batch_mutation_super);
       }
       first = false;
       if (!first) sb.append(", ");
       sb.append("consistency_level:");
       String consistency_level_name = ConsistencyLevel.VALUES_TO_NAMES.get(this.consistency_level);
       if (consistency_level_name != null) {
         sb.append(consistency_level_name);
         sb.append(" (");
       }
       sb.append(this.consistency_level);
       if (consistency_level_name != null) {
         sb.append(")");
       }
       first = false;
       sb.append(")");
       return sb.toString();
     }
 
     public void validate() throws TException {
       // check for required fields
       // check that fields of type enum have valid values
       if (isSetConsistency_level() && !ConsistencyLevel.VALID_VALUES.contains(consistency_level)){
         throw new TProtocolException("The field 'consistency_level' has been assigned the invalid value " + consistency_level);
       }
     }
 
   }
 
   public static class batch_insert_super_column_result implements TBase, java.io.Serializable, Cloneable   {
     private static final TStruct STRUCT_DESC = new TStruct("batch_insert_super_column_result");
     private static final TField IRE_FIELD_DESC = new TField("ire", TType.STRUCT, (short)1);
     private static final TField UE_FIELD_DESC = new TField("ue", TType.STRUCT, (short)2);
 
     public InvalidRequestException ire;
     public static final int IRE = 1;
     public UnavailableException ue;
     public static final int UE = 2;
 
     private final Isset __isset = new Isset();
     private static final class Isset implements java.io.Serializable {
     }
 
     public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
       put(IRE, new FieldMetaData("ire", TFieldRequirementType.DEFAULT, 
           new FieldValueMetaData(TType.STRUCT)));
       put(UE, new FieldMetaData("ue", TFieldRequirementType.DEFAULT, 
           new FieldValueMetaData(TType.STRUCT)));
     }});
 
     static {
       FieldMetaData.addStructMetaDataMap(batch_insert_super_column_result.class, metaDataMap);
     }
 
     public batch_insert_super_column_result() {
     }
 
     public batch_insert_super_column_result(
       InvalidRequestException ire,
       UnavailableException ue)
     {
       this();
       this.ire = ire;
       this.ue = ue;
     }
 
     /**
      * Performs a deep copy on <i>other</i>.
      */
     public batch_insert_super_column_result(batch_insert_super_column_result other) {
       if (other.isSetIre()) {
         this.ire = new InvalidRequestException(other.ire);
       }
       if (other.isSetUe()) {
         this.ue = new UnavailableException(other.ue);
       }
     }
 
     @Override
     public batch_insert_super_column_result clone() {
       return new batch_insert_super_column_result(this);
     }
 
     public InvalidRequestException getIre() {
       return this.ire;
     }
 
    public batch_insert_super_column_result setIre(InvalidRequestException ire) {
       this.ire = ire;
      return this;
     }
 
     public void unsetIre() {
       this.ire = null;
     }
 
     // Returns true if field ire is set (has been asigned a value) and false otherwise
     public boolean isSetIre() {
       return this.ire != null;
     }
 
     public void setIreIsSet(boolean value) {
       if (!value) {
         this.ire = null;
       }
     }
 
     public UnavailableException getUe() {
       return this.ue;
     }
 
    public batch_insert_super_column_result setUe(UnavailableException ue) {
       this.ue = ue;
      return this;
     }
 
     public void unsetUe() {
       this.ue = null;
     }
 
     // Returns true if field ue is set (has been asigned a value) and false otherwise
     public boolean isSetUe() {
       return this.ue != null;
     }
 
     public void setUeIsSet(boolean value) {
       if (!value) {
         this.ue = null;
       }
     }
 
     public void setFieldValue(int fieldID, Object value) {
       switch (fieldID) {
       case IRE:
         if (value == null) {
           unsetIre();
         } else {
           setIre((InvalidRequestException)value);
         }
         break;
 
       case UE:
         if (value == null) {
           unsetUe();
         } else {
           setUe((UnavailableException)value);
         }
         break;
 
       default:
         throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
       }
     }
 
     public Object getFieldValue(int fieldID) {
       switch (fieldID) {
       case IRE:
         return getIre();
 
       case UE:
         return getUe();
 
       default:
         throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
       }
     }
 
     // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
     public boolean isSet(int fieldID) {
       switch (fieldID) {
       case IRE:
         return isSetIre();
       case UE:
         return isSetUe();
       default:
         throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
       }
     }
 
     @Override
     public boolean equals(Object that) {
       if (that == null)
         return false;
       if (that instanceof batch_insert_super_column_result)
         return this.equals((batch_insert_super_column_result)that);
       return false;
     }
 
     public boolean equals(batch_insert_super_column_result that) {
       if (that == null)
         return false;
 
       boolean this_present_ire = true && this.isSetIre();
       boolean that_present_ire = true && that.isSetIre();
       if (this_present_ire || that_present_ire) {
         if (!(this_present_ire && that_present_ire))
           return false;
         if (!this.ire.equals(that.ire))
           return false;
       }
 
       boolean this_present_ue = true && this.isSetUe();
       boolean that_present_ue = true && that.isSetUe();
       if (this_present_ue || that_present_ue) {
         if (!(this_present_ue && that_present_ue))
           return false;
         if (!this.ue.equals(that.ue))
           return false;
       }
 
       return true;
     }
 
     @Override
     public int hashCode() {
       return 0;
     }
 
     public void read(TProtocol iprot) throws TException {
       TField field;
       iprot.readStructBegin();
       while (true)
       {
         field = iprot.readFieldBegin();
         if (field.type == TType.STOP) { 
           break;
         }
         switch (field.id)
         {
           case IRE:
             if (field.type == TType.STRUCT) {
               this.ire = new InvalidRequestException();
               this.ire.read(iprot);
             } else { 
               TProtocolUtil.skip(iprot, field.type);
             }
             break;
           case UE:
             if (field.type == TType.STRUCT) {
               this.ue = new UnavailableException();
               this.ue.read(iprot);
             } else { 
               TProtocolUtil.skip(iprot, field.type);
             }
             break;
           default:
             TProtocolUtil.skip(iprot, field.type);
             break;
         }
         iprot.readFieldEnd();
       }
       iprot.readStructEnd();
 
 
       // check for required fields of primitive type, which can't be checked in the validate method
       validate();
     }
 
     public void write(TProtocol oprot) throws TException {
       oprot.writeStructBegin(STRUCT_DESC);
 
       if (this.isSetIre()) {
         oprot.writeFieldBegin(IRE_FIELD_DESC);
         this.ire.write(oprot);
         oprot.writeFieldEnd();
       } else if (this.isSetUe()) {
         oprot.writeFieldBegin(UE_FIELD_DESC);
         this.ue.write(oprot);
         oprot.writeFieldEnd();
       }
       oprot.writeFieldStop();
       oprot.writeStructEnd();
     }
 
     @Override
     public String toString() {
       StringBuilder sb = new StringBuilder("batch_insert_super_column_result(");
       boolean first = true;
 
       sb.append("ire:");
       if (this.ire == null) {
         sb.append("null");
       } else {
         sb.append(this.ire);
       }
       first = false;
       if (!first) sb.append(", ");
       sb.append("ue:");
       if (this.ue == null) {
         sb.append("null");
       } else {
         sb.append(this.ue);
       }
       first = false;
       sb.append(")");
       return sb.toString();
     }
 
     public void validate() throws TException {
       // check for required fields
       // check that fields of type enum have valid values
     }
 
   }
 
   public static class get_key_range_args implements TBase, java.io.Serializable, Cloneable   {
     private static final TStruct STRUCT_DESC = new TStruct("get_key_range_args");
     private static final TField KEYSPACE_FIELD_DESC = new TField("keyspace", TType.STRING, (short)1);
     private static final TField COLUMN_FAMILY_FIELD_DESC = new TField("column_family", TType.STRING, (short)2);
     private static final TField START_FIELD_DESC = new TField("start", TType.STRING, (short)3);
     private static final TField FINISH_FIELD_DESC = new TField("finish", TType.STRING, (short)4);
     private static final TField COUNT_FIELD_DESC = new TField("count", TType.I32, (short)5);
 
     public String keyspace;
     public static final int KEYSPACE = 1;
     public String column_family;
     public static final int COLUMN_FAMILY = 2;
     public String start;
     public static final int START = 3;
     public String finish;
     public static final int FINISH = 4;
     public int count;
     public static final int COUNT = 5;
 
     private final Isset __isset = new Isset();
     private static final class Isset implements java.io.Serializable {
       public boolean count = false;
     }
 
     public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
       put(KEYSPACE, new FieldMetaData("keyspace", TFieldRequirementType.DEFAULT, 
           new FieldValueMetaData(TType.STRING)));
       put(COLUMN_FAMILY, new FieldMetaData("column_family", TFieldRequirementType.DEFAULT, 
           new FieldValueMetaData(TType.STRING)));
       put(START, new FieldMetaData("start", TFieldRequirementType.DEFAULT, 
           new FieldValueMetaData(TType.STRING)));
       put(FINISH, new FieldMetaData("finish", TFieldRequirementType.DEFAULT, 
           new FieldValueMetaData(TType.STRING)));
       put(COUNT, new FieldMetaData("count", TFieldRequirementType.DEFAULT, 
           new FieldValueMetaData(TType.I32)));
     }});
 
     static {
       FieldMetaData.addStructMetaDataMap(get_key_range_args.class, metaDataMap);
     }
 
     public get_key_range_args() {
       this.start = "";
 
       this.finish = "";
 
       this.count = 100;
 
     }
 
     public get_key_range_args(
       String keyspace,
       String column_family,
       String start,
       String finish,
       int count)
     {
       this();
       this.keyspace = keyspace;
       this.column_family = column_family;
       this.start = start;
       this.finish = finish;
       this.count = count;
       this.__isset.count = true;
     }
 
     /**
      * Performs a deep copy on <i>other</i>.
      */
     public get_key_range_args(get_key_range_args other) {
       if (other.isSetKeyspace()) {
         this.keyspace = other.keyspace;
       }
       if (other.isSetColumn_family()) {
         this.column_family = other.column_family;
       }
       if (other.isSetStart()) {
         this.start = other.start;
       }
       if (other.isSetFinish()) {
         this.finish = other.finish;
       }
       __isset.count = other.__isset.count;
       this.count = other.count;
     }
 
     @Override
     public get_key_range_args clone() {
       return new get_key_range_args(this);
     }
 
     public String getKeyspace() {
       return this.keyspace;
     }
 
    public get_key_range_args setKeyspace(String keyspace) {
       this.keyspace = keyspace;
      return this;
     }
 
     public void unsetKeyspace() {
       this.keyspace = null;
     }
 
     // Returns true if field keyspace is set (has been asigned a value) and false otherwise
     public boolean isSetKeyspace() {
       return this.keyspace != null;
     }
 
     public void setKeyspaceIsSet(boolean value) {
       if (!value) {
         this.keyspace = null;
       }
     }
 
     public String getColumn_family() {
       return this.column_family;
     }
 
    public get_key_range_args setColumn_family(String column_family) {
       this.column_family = column_family;
      return this;
     }
 
     public void unsetColumn_family() {
       this.column_family = null;
     }
 
     // Returns true if field column_family is set (has been asigned a value) and false otherwise
     public boolean isSetColumn_family() {
       return this.column_family != null;
     }
 
     public void setColumn_familyIsSet(boolean value) {
       if (!value) {
         this.column_family = null;
       }
     }
 
     public String getStart() {
       return this.start;
     }
 
    public get_key_range_args setStart(String start) {
       this.start = start;
      return this;
     }
 
     public void unsetStart() {
       this.start = null;
     }
 
     // Returns true if field start is set (has been asigned a value) and false otherwise
     public boolean isSetStart() {
       return this.start != null;
     }
 
     public void setStartIsSet(boolean value) {
       if (!value) {
         this.start = null;
       }
     }
 
     public String getFinish() {
       return this.finish;
     }
 
    public get_key_range_args setFinish(String finish) {
       this.finish = finish;
      return this;
     }
 
     public void unsetFinish() {
       this.finish = null;
     }
 
     // Returns true if field finish is set (has been asigned a value) and false otherwise
     public boolean isSetFinish() {
       return this.finish != null;
     }
 
     public void setFinishIsSet(boolean value) {
       if (!value) {
         this.finish = null;
       }
     }
 
     public int getCount() {
       return this.count;
     }
 
    public get_key_range_args setCount(int count) {
       this.count = count;
       this.__isset.count = true;
      return this;
     }
 
     public void unsetCount() {
       this.__isset.count = false;
     }
 
     // Returns true if field count is set (has been asigned a value) and false otherwise
     public boolean isSetCount() {
       return this.__isset.count;
     }
 
     public void setCountIsSet(boolean value) {
       this.__isset.count = value;
     }
 
     public void setFieldValue(int fieldID, Object value) {
       switch (fieldID) {
       case KEYSPACE:
         if (value == null) {
           unsetKeyspace();
         } else {
           setKeyspace((String)value);
         }
         break;
 
       case COLUMN_FAMILY:
         if (value == null) {
           unsetColumn_family();
         } else {
           setColumn_family((String)value);
         }
         break;
 
       case START:
         if (value == null) {
           unsetStart();
         } else {
           setStart((String)value);
         }
         break;
 
       case FINISH:
         if (value == null) {
           unsetFinish();
         } else {
           setFinish((String)value);
         }
         break;
 
       case COUNT:
         if (value == null) {
           unsetCount();
         } else {
           setCount((Integer)value);
         }
         break;
 
       default:
         throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
       }
     }
 
     public Object getFieldValue(int fieldID) {
       switch (fieldID) {
       case KEYSPACE:
         return getKeyspace();
 
       case COLUMN_FAMILY:
         return getColumn_family();
 
       case START:
         return getStart();
 
       case FINISH:
         return getFinish();
 
       case COUNT:
         return new Integer(getCount());
 
       default:
         throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
       }
     }
 
     // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
     public boolean isSet(int fieldID) {
       switch (fieldID) {
       case KEYSPACE:
         return isSetKeyspace();
       case COLUMN_FAMILY:
         return isSetColumn_family();
       case START:
         return isSetStart();
       case FINISH:
         return isSetFinish();
       case COUNT:
         return isSetCount();
       default:
         throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
       }
     }
 
     @Override
     public boolean equals(Object that) {
       if (that == null)
         return false;
       if (that instanceof get_key_range_args)
         return this.equals((get_key_range_args)that);
       return false;
     }
 
     public boolean equals(get_key_range_args that) {
       if (that == null)
         return false;
 
       boolean this_present_keyspace = true && this.isSetKeyspace();
       boolean that_present_keyspace = true && that.isSetKeyspace();
       if (this_present_keyspace || that_present_keyspace) {
         if (!(this_present_keyspace && that_present_keyspace))
           return false;
         if (!this.keyspace.equals(that.keyspace))
           return false;
       }
 
       boolean this_present_column_family = true && this.isSetColumn_family();
       boolean that_present_column_family = true && that.isSetColumn_family();
       if (this_present_column_family || that_present_column_family) {
         if (!(this_present_column_family && that_present_column_family))
           return false;
         if (!this.column_family.equals(that.column_family))
           return false;
       }
 
       boolean this_present_start = true && this.isSetStart();
       boolean that_present_start = true && that.isSetStart();
       if (this_present_start || that_present_start) {
         if (!(this_present_start && that_present_start))
           return false;
         if (!this.start.equals(that.start))
           return false;
       }
 
       boolean this_present_finish = true && this.isSetFinish();
       boolean that_present_finish = true && that.isSetFinish();
       if (this_present_finish || that_present_finish) {
         if (!(this_present_finish && that_present_finish))
           return false;
         if (!this.finish.equals(that.finish))
           return false;
       }
 
       boolean this_present_count = true;
       boolean that_present_count = true;
       if (this_present_count || that_present_count) {
         if (!(this_present_count && that_present_count))
           return false;
         if (this.count != that.count)
           return false;
       }
 
       return true;
     }
 
     @Override
     public int hashCode() {
       return 0;
     }
 
     public void read(TProtocol iprot) throws TException {
       TField field;
       iprot.readStructBegin();
       while (true)
       {
         field = iprot.readFieldBegin();
         if (field.type == TType.STOP) { 
           break;
         }
         switch (field.id)
         {
           case KEYSPACE:
             if (field.type == TType.STRING) {
               this.keyspace = iprot.readString();
             } else { 
               TProtocolUtil.skip(iprot, field.type);
             }
             break;
           case COLUMN_FAMILY:
             if (field.type == TType.STRING) {
               this.column_family = iprot.readString();
             } else { 
               TProtocolUtil.skip(iprot, field.type);
             }
             break;
           case START:
             if (field.type == TType.STRING) {
               this.start = iprot.readString();
             } else { 
               TProtocolUtil.skip(iprot, field.type);
             }
             break;
           case FINISH:
             if (field.type == TType.STRING) {
               this.finish = iprot.readString();
             } else { 
               TProtocolUtil.skip(iprot, field.type);
             }
             break;
           case COUNT:
             if (field.type == TType.I32) {
               this.count = iprot.readI32();
               this.__isset.count = true;
             } else { 
               TProtocolUtil.skip(iprot, field.type);
             }
             break;
           default:
             TProtocolUtil.skip(iprot, field.type);
             break;
         }
         iprot.readFieldEnd();
       }
       iprot.readStructEnd();
 
 
       // check for required fields of primitive type, which can't be checked in the validate method
       validate();
     }
 
     public void write(TProtocol oprot) throws TException {
       validate();
 
       oprot.writeStructBegin(STRUCT_DESC);
       if (this.keyspace != null) {
         oprot.writeFieldBegin(KEYSPACE_FIELD_DESC);
         oprot.writeString(this.keyspace);
         oprot.writeFieldEnd();
       }
       if (this.column_family != null) {
         oprot.writeFieldBegin(COLUMN_FAMILY_FIELD_DESC);
         oprot.writeString(this.column_family);
         oprot.writeFieldEnd();
       }
       if (this.start != null) {
         oprot.writeFieldBegin(START_FIELD_DESC);
         oprot.writeString(this.start);
         oprot.writeFieldEnd();
       }
       if (this.finish != null) {
         oprot.writeFieldBegin(FINISH_FIELD_DESC);
         oprot.writeString(this.finish);
         oprot.writeFieldEnd();
       }
       oprot.writeFieldBegin(COUNT_FIELD_DESC);
       oprot.writeI32(this.count);
       oprot.writeFieldEnd();
       oprot.writeFieldStop();
       oprot.writeStructEnd();
     }
 
     @Override
     public String toString() {
       StringBuilder sb = new StringBuilder("get_key_range_args(");
       boolean first = true;
 
       sb.append("keyspace:");
       if (this.keyspace == null) {
         sb.append("null");
       } else {
         sb.append(this.keyspace);
       }
       first = false;
       if (!first) sb.append(", ");
       sb.append("column_family:");
       if (this.column_family == null) {
         sb.append("null");
       } else {
         sb.append(this.column_family);
       }
       first = false;
       if (!first) sb.append(", ");
       sb.append("start:");
       if (this.start == null) {
         sb.append("null");
       } else {
         sb.append(this.start);
       }
       first = false;
       if (!first) sb.append(", ");
       sb.append("finish:");
       if (this.finish == null) {
         sb.append("null");
       } else {
         sb.append(this.finish);
       }
       first = false;
       if (!first) sb.append(", ");
       sb.append("count:");
       sb.append(this.count);
       first = false;
       sb.append(")");
       return sb.toString();
     }
 
     public void validate() throws TException {
       // check for required fields
       // check that fields of type enum have valid values
     }
 
   }
 
   public static class get_key_range_result implements TBase, java.io.Serializable, Cloneable   {
     private static final TStruct STRUCT_DESC = new TStruct("get_key_range_result");
     private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.LIST, (short)0);
     private static final TField IRE_FIELD_DESC = new TField("ire", TType.STRUCT, (short)1);
 
     public List<String> success;
     public static final int SUCCESS = 0;
     public InvalidRequestException ire;
     public static final int IRE = 1;
 
     private final Isset __isset = new Isset();
     private static final class Isset implements java.io.Serializable {
     }
 
     public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
       put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
           new ListMetaData(TType.LIST, 
               new FieldValueMetaData(TType.STRING))));
       put(IRE, new FieldMetaData("ire", TFieldRequirementType.DEFAULT, 
           new FieldValueMetaData(TType.STRUCT)));
     }});
 
     static {
       FieldMetaData.addStructMetaDataMap(get_key_range_result.class, metaDataMap);
     }
 
     public get_key_range_result() {
     }
 
     public get_key_range_result(
       List<String> success,
       InvalidRequestException ire)
     {
       this();
       this.success = success;
       this.ire = ire;
     }
 
     /**
      * Performs a deep copy on <i>other</i>.
      */
     public get_key_range_result(get_key_range_result other) {
       if (other.isSetSuccess()) {
         List<String> __this__success = new ArrayList<String>();
         for (String other_element : other.success) {
           __this__success.add(other_element);
         }
         this.success = __this__success;
       }
       if (other.isSetIre()) {
         this.ire = new InvalidRequestException(other.ire);
       }
     }
 
     @Override
     public get_key_range_result clone() {
       return new get_key_range_result(this);
     }
 
     public List<String> getSuccess() {
       return this.success;
     }
 
    public get_key_range_result setSuccess(List<String> success) {
       this.success = success;
      return this;
     }
 
     public void unsetSuccess() {
       this.success = null;
     }
 
     // Returns true if field success is set (has been asigned a value) and false otherwise
     public boolean isSetSuccess() {
       return this.success != null;
     }
 
     public void setSuccessIsSet(boolean value) {
       if (!value) {
         this.success = null;
       }
     }
 
     public InvalidRequestException getIre() {
       return this.ire;
     }
 
    public get_key_range_result setIre(InvalidRequestException ire) {
       this.ire = ire;
      return this;
     }
 
     public void unsetIre() {
       this.ire = null;
     }
 
     // Returns true if field ire is set (has been asigned a value) and false otherwise
     public boolean isSetIre() {
       return this.ire != null;
     }
 
     public void setIreIsSet(boolean value) {
       if (!value) {
         this.ire = null;
       }
     }
 
     public void setFieldValue(int fieldID, Object value) {
       switch (fieldID) {
       case SUCCESS:
         if (value == null) {
           unsetSuccess();
         } else {
           setSuccess((List<String>)value);
         }
         break;
 
       case IRE:
         if (value == null) {
           unsetIre();
         } else {
           setIre((InvalidRequestException)value);
         }
         break;
 
       default:
         throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
       }
     }
 
     public Object getFieldValue(int fieldID) {
       switch (fieldID) {
       case SUCCESS:
         return getSuccess();
 
       case IRE:
         return getIre();
 
       default:
         throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
       }
     }
 
     // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
     public boolean isSet(int fieldID) {
       switch (fieldID) {
       case SUCCESS:
         return isSetSuccess();
       case IRE:
         return isSetIre();
       default:
         throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
       }
     }
 
     @Override
     public boolean equals(Object that) {
       if (that == null)
         return false;
       if (that instanceof get_key_range_result)
         return this.equals((get_key_range_result)that);
       return false;
     }
 
     public boolean equals(get_key_range_result that) {
       if (that == null)
         return false;
 
       boolean this_present_success = true && this.isSetSuccess();
       boolean that_present_success = true && that.isSetSuccess();
       if (this_present_success || that_present_success) {
         if (!(this_present_success && that_present_success))
           return false;
         if (!this.success.equals(that.success))
           return false;
       }
 
       boolean this_present_ire = true && this.isSetIre();
       boolean that_present_ire = true && that.isSetIre();
       if (this_present_ire || that_present_ire) {
         if (!(this_present_ire && that_present_ire))
           return false;
         if (!this.ire.equals(that.ire))
           return false;
       }
 
       return true;
     }
 
     @Override
     public int hashCode() {
       return 0;
     }
 
     public void read(TProtocol iprot) throws TException {
       TField field;
       iprot.readStructBegin();
       while (true)
       {
         field = iprot.readFieldBegin();
         if (field.type == TType.STOP) { 
           break;
         }
         switch (field.id)
         {
           case SUCCESS:
             if (field.type == TType.LIST) {
               {
                 TList _list39 = iprot.readListBegin();
                 this.success = new ArrayList<String>(_list39.size);
                 for (int _i40 = 0; _i40 < _list39.size; ++_i40)
                 {
                   String _elem41;
                   _elem41 = iprot.readString();
                   this.success.add(_elem41);
                 }
                 iprot.readListEnd();
               }
             } else { 
               TProtocolUtil.skip(iprot, field.type);
             }
             break;
           case IRE:
             if (field.type == TType.STRUCT) {
               this.ire = new InvalidRequestException();
               this.ire.read(iprot);
             } else { 
               TProtocolUtil.skip(iprot, field.type);
             }
             break;
           default:
             TProtocolUtil.skip(iprot, field.type);
             break;
         }
         iprot.readFieldEnd();
       }
       iprot.readStructEnd();
 
 
       // check for required fields of primitive type, which can't be checked in the validate method
       validate();
     }
 
     public void write(TProtocol oprot) throws TException {
       oprot.writeStructBegin(STRUCT_DESC);
 
       if (this.isSetSuccess()) {
         oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
         {
           oprot.writeListBegin(new TList(TType.STRING, this.success.size()));
           for (String _iter42 : this.success)          {
             oprot.writeString(_iter42);
           }
           oprot.writeListEnd();
         }
         oprot.writeFieldEnd();
       } else if (this.isSetIre()) {
         oprot.writeFieldBegin(IRE_FIELD_DESC);
         this.ire.write(oprot);
         oprot.writeFieldEnd();
       }
       oprot.writeFieldStop();
       oprot.writeStructEnd();
     }
 
     @Override
     public String toString() {
       StringBuilder sb = new StringBuilder("get_key_range_result(");
       boolean first = true;
 
       sb.append("success:");
       if (this.success == null) {
         sb.append("null");
       } else {
         sb.append(this.success);
       }
       first = false;
       if (!first) sb.append(", ");
       sb.append("ire:");
       if (this.ire == null) {
         sb.append("null");
       } else {
         sb.append(this.ire);
       }
       first = false;
       sb.append(")");
       return sb.toString();
     }
 
     public void validate() throws TException {
       // check for required fields
       // check that fields of type enum have valid values
     }
 
   }
 
   public static class get_string_property_args implements TBase, java.io.Serializable, Cloneable   {
     private static final TStruct STRUCT_DESC = new TStruct("get_string_property_args");
     private static final TField PROPERTY_FIELD_DESC = new TField("property", TType.STRING, (short)1);
 
     public String property;
     public static final int PROPERTY = 1;
 
     private final Isset __isset = new Isset();
     private static final class Isset implements java.io.Serializable {
     }
 
     public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
       put(PROPERTY, new FieldMetaData("property", TFieldRequirementType.DEFAULT, 
           new FieldValueMetaData(TType.STRING)));
     }});
 
     static {
       FieldMetaData.addStructMetaDataMap(get_string_property_args.class, metaDataMap);
     }
 
     public get_string_property_args() {
     }
 
     public get_string_property_args(
       String property)
     {
       this();
       this.property = property;
     }
 
     /**
      * Performs a deep copy on <i>other</i>.
      */
     public get_string_property_args(get_string_property_args other) {
       if (other.isSetProperty()) {
         this.property = other.property;
       }
     }
 
     @Override
     public get_string_property_args clone() {
       return new get_string_property_args(this);
     }
 
     public String getProperty() {
       return this.property;
     }
 
    public get_string_property_args setProperty(String property) {
       this.property = property;
      return this;
     }
 
     public void unsetProperty() {
       this.property = null;
     }
 
     // Returns true if field property is set (has been asigned a value) and false otherwise
     public boolean isSetProperty() {
       return this.property != null;
     }
 
     public void setPropertyIsSet(boolean value) {
       if (!value) {
         this.property = null;
       }
     }
 
     public void setFieldValue(int fieldID, Object value) {
       switch (fieldID) {
       case PROPERTY:
         if (value == null) {
           unsetProperty();
         } else {
           setProperty((String)value);
         }
         break;
 
       default:
         throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
       }
     }
 
     public Object getFieldValue(int fieldID) {
       switch (fieldID) {
       case PROPERTY:
         return getProperty();
 
       default:
         throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
       }
     }
 
     // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
     public boolean isSet(int fieldID) {
       switch (fieldID) {
       case PROPERTY:
         return isSetProperty();
       default:
         throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
       }
     }
 
     @Override
     public boolean equals(Object that) {
       if (that == null)
         return false;
       if (that instanceof get_string_property_args)
         return this.equals((get_string_property_args)that);
       return false;
     }
 
     public boolean equals(get_string_property_args that) {
       if (that == null)
         return false;
 
       boolean this_present_property = true && this.isSetProperty();
       boolean that_present_property = true && that.isSetProperty();
       if (this_present_property || that_present_property) {
         if (!(this_present_property && that_present_property))
           return false;
         if (!this.property.equals(that.property))
           return false;
       }
 
       return true;
     }
 
     @Override
     public int hashCode() {
       return 0;
     }
 
     public void read(TProtocol iprot) throws TException {
       TField field;
       iprot.readStructBegin();
       while (true)
       {
         field = iprot.readFieldBegin();
         if (field.type == TType.STOP) { 
           break;
         }
         switch (field.id)
         {
           case PROPERTY:
             if (field.type == TType.STRING) {
               this.property = iprot.readString();
             } else { 
               TProtocolUtil.skip(iprot, field.type);
             }
             break;
           default:
             TProtocolUtil.skip(iprot, field.type);
             break;
         }
         iprot.readFieldEnd();
       }
       iprot.readStructEnd();
 
 
       // check for required fields of primitive type, which can't be checked in the validate method
       validate();
     }
 
     public void write(TProtocol oprot) throws TException {
       validate();
 
       oprot.writeStructBegin(STRUCT_DESC);
       if (this.property != null) {
         oprot.writeFieldBegin(PROPERTY_FIELD_DESC);
         oprot.writeString(this.property);
         oprot.writeFieldEnd();
       }
       oprot.writeFieldStop();
       oprot.writeStructEnd();
     }
 
     @Override
     public String toString() {
       StringBuilder sb = new StringBuilder("get_string_property_args(");
       boolean first = true;
 
       sb.append("property:");
       if (this.property == null) {
         sb.append("null");
       } else {
         sb.append(this.property);
       }
       first = false;
       sb.append(")");
       return sb.toString();
     }
 
     public void validate() throws TException {
       // check for required fields
       // check that fields of type enum have valid values
     }
 
   }
 
   public static class get_string_property_result implements TBase, java.io.Serializable, Cloneable   {
     private static final TStruct STRUCT_DESC = new TStruct("get_string_property_result");
     private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRING, (short)0);
 
     public String success;
     public static final int SUCCESS = 0;
 
     private final Isset __isset = new Isset();
     private static final class Isset implements java.io.Serializable {
     }
 
     public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
       put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
           new FieldValueMetaData(TType.STRING)));
     }});
 
     static {
       FieldMetaData.addStructMetaDataMap(get_string_property_result.class, metaDataMap);
     }
 
     public get_string_property_result() {
     }
 
     public get_string_property_result(
       String success)
     {
       this();
       this.success = success;
     }
 
     /**
      * Performs a deep copy on <i>other</i>.
      */
     public get_string_property_result(get_string_property_result other) {
       if (other.isSetSuccess()) {
         this.success = other.success;
       }
     }
 
     @Override
     public get_string_property_result clone() {
       return new get_string_property_result(this);
     }
 
     public String getSuccess() {
       return this.success;
     }
 
    public get_string_property_result setSuccess(String success) {
       this.success = success;
      return this;
     }
 
     public void unsetSuccess() {
       this.success = null;
     }
 
     // Returns true if field success is set (has been asigned a value) and false otherwise
     public boolean isSetSuccess() {
       return this.success != null;
     }
 
     public void setSuccessIsSet(boolean value) {
       if (!value) {
         this.success = null;
       }
     }
 
     public void setFieldValue(int fieldID, Object value) {
       switch (fieldID) {
       case SUCCESS:
         if (value == null) {
           unsetSuccess();
         } else {
           setSuccess((String)value);
         }
         break;
 
       default:
         throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
       }
     }
 
     public Object getFieldValue(int fieldID) {
       switch (fieldID) {
       case SUCCESS:
         return getSuccess();
 
       default:
         throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
       }
     }
 
     // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
     public boolean isSet(int fieldID) {
       switch (fieldID) {
       case SUCCESS:
         return isSetSuccess();
       default:
         throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
       }
     }
 
     @Override
     public boolean equals(Object that) {
       if (that == null)
         return false;
       if (that instanceof get_string_property_result)
         return this.equals((get_string_property_result)that);
       return false;
     }
 
     public boolean equals(get_string_property_result that) {
       if (that == null)
         return false;
 
       boolean this_present_success = true && this.isSetSuccess();
       boolean that_present_success = true && that.isSetSuccess();
       if (this_present_success || that_present_success) {
         if (!(this_present_success && that_present_success))
           return false;
         if (!this.success.equals(that.success))
           return false;
       }
 
       return true;
     }
 
     @Override
     public int hashCode() {
       return 0;
     }
 
     public void read(TProtocol iprot) throws TException {
       TField field;
       iprot.readStructBegin();
       while (true)
       {
         field = iprot.readFieldBegin();
         if (field.type == TType.STOP) { 
           break;
         }
         switch (field.id)
         {
           case SUCCESS:
             if (field.type == TType.STRING) {
               this.success = iprot.readString();
             } else { 
               TProtocolUtil.skip(iprot, field.type);
             }
             break;
           default:
             TProtocolUtil.skip(iprot, field.type);
             break;
         }
         iprot.readFieldEnd();
       }
       iprot.readStructEnd();
 
 
       // check for required fields of primitive type, which can't be checked in the validate method
       validate();
     }
 
     public void write(TProtocol oprot) throws TException {
       oprot.writeStructBegin(STRUCT_DESC);
 
       if (this.isSetSuccess()) {
         oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
         oprot.writeString(this.success);
         oprot.writeFieldEnd();
       }
       oprot.writeFieldStop();
       oprot.writeStructEnd();
     }
 
     @Override
     public String toString() {
       StringBuilder sb = new StringBuilder("get_string_property_result(");
       boolean first = true;
 
       sb.append("success:");
       if (this.success == null) {
         sb.append("null");
       } else {
         sb.append(this.success);
       }
       first = false;
       sb.append(")");
       return sb.toString();
     }
 
     public void validate() throws TException {
       // check for required fields
       // check that fields of type enum have valid values
     }
 
   }
 
   public static class get_string_list_property_args implements TBase, java.io.Serializable, Cloneable   {
     private static final TStruct STRUCT_DESC = new TStruct("get_string_list_property_args");
     private static final TField PROPERTY_FIELD_DESC = new TField("property", TType.STRING, (short)1);
 
     public String property;
     public static final int PROPERTY = 1;
 
     private final Isset __isset = new Isset();
     private static final class Isset implements java.io.Serializable {
     }
 
     public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
       put(PROPERTY, new FieldMetaData("property", TFieldRequirementType.DEFAULT, 
           new FieldValueMetaData(TType.STRING)));
     }});
 
     static {
       FieldMetaData.addStructMetaDataMap(get_string_list_property_args.class, metaDataMap);
     }
 
     public get_string_list_property_args() {
     }
 
     public get_string_list_property_args(
       String property)
     {
       this();
       this.property = property;
     }
 
     /**
      * Performs a deep copy on <i>other</i>.
      */
     public get_string_list_property_args(get_string_list_property_args other) {
       if (other.isSetProperty()) {
         this.property = other.property;
       }
     }
 
     @Override
     public get_string_list_property_args clone() {
       return new get_string_list_property_args(this);
     }
 
     public String getProperty() {
       return this.property;
     }
 
    public get_string_list_property_args setProperty(String property) {
       this.property = property;
      return this;
     }
 
     public void unsetProperty() {
       this.property = null;
     }
 
     // Returns true if field property is set (has been asigned a value) and false otherwise
     public boolean isSetProperty() {
       return this.property != null;
     }
 
     public void setPropertyIsSet(boolean value) {
       if (!value) {
         this.property = null;
       }
     }
 
     public void setFieldValue(int fieldID, Object value) {
       switch (fieldID) {
       case PROPERTY:
         if (value == null) {
           unsetProperty();
         } else {
           setProperty((String)value);
         }
         break;
 
       default:
         throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
       }
     }
 
     public Object getFieldValue(int fieldID) {
       switch (fieldID) {
       case PROPERTY:
         return getProperty();
 
       default:
         throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
       }
     }
 
     // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
     public boolean isSet(int fieldID) {
       switch (fieldID) {
       case PROPERTY:
         return isSetProperty();
       default:
         throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
       }
     }
 
     @Override
     public boolean equals(Object that) {
       if (that == null)
         return false;
       if (that instanceof get_string_list_property_args)
         return this.equals((get_string_list_property_args)that);
       return false;
     }
 
     public boolean equals(get_string_list_property_args that) {
       if (that == null)
         return false;
 
       boolean this_present_property = true && this.isSetProperty();
       boolean that_present_property = true && that.isSetProperty();
       if (this_present_property || that_present_property) {
         if (!(this_present_property && that_present_property))
           return false;
         if (!this.property.equals(that.property))
           return false;
       }
 
       return true;
     }
 
     @Override
     public int hashCode() {
       return 0;
     }
 
     public void read(TProtocol iprot) throws TException {
       TField field;
       iprot.readStructBegin();
       while (true)
       {
         field = iprot.readFieldBegin();
         if (field.type == TType.STOP) { 
           break;
         }
         switch (field.id)
         {
           case PROPERTY:
             if (field.type == TType.STRING) {
               this.property = iprot.readString();
             } else { 
               TProtocolUtil.skip(iprot, field.type);
             }
             break;
           default:
             TProtocolUtil.skip(iprot, field.type);
             break;
         }
         iprot.readFieldEnd();
       }
       iprot.readStructEnd();
 
 
       // check for required fields of primitive type, which can't be checked in the validate method
       validate();
     }
 
     public void write(TProtocol oprot) throws TException {
       validate();
 
       oprot.writeStructBegin(STRUCT_DESC);
       if (this.property != null) {
         oprot.writeFieldBegin(PROPERTY_FIELD_DESC);
         oprot.writeString(this.property);
         oprot.writeFieldEnd();
       }
       oprot.writeFieldStop();
       oprot.writeStructEnd();
     }
 
     @Override
     public String toString() {
       StringBuilder sb = new StringBuilder("get_string_list_property_args(");
       boolean first = true;
 
       sb.append("property:");
       if (this.property == null) {
         sb.append("null");
       } else {
         sb.append(this.property);
       }
       first = false;
       sb.append(")");
       return sb.toString();
     }
 
     public void validate() throws TException {
       // check for required fields
       // check that fields of type enum have valid values
     }
 
   }
 
   public static class get_string_list_property_result implements TBase, java.io.Serializable, Cloneable   {
     private static final TStruct STRUCT_DESC = new TStruct("get_string_list_property_result");
     private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.LIST, (short)0);
 
     public List<String> success;
     public static final int SUCCESS = 0;
 
     private final Isset __isset = new Isset();
     private static final class Isset implements java.io.Serializable {
     }
 
     public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
       put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
           new ListMetaData(TType.LIST, 
               new FieldValueMetaData(TType.STRING))));
     }});
 
     static {
       FieldMetaData.addStructMetaDataMap(get_string_list_property_result.class, metaDataMap);
     }
 
     public get_string_list_property_result() {
     }
 
     public get_string_list_property_result(
       List<String> success)
     {
       this();
       this.success = success;
     }
 
     /**
      * Performs a deep copy on <i>other</i>.
      */
     public get_string_list_property_result(get_string_list_property_result other) {
       if (other.isSetSuccess()) {
         List<String> __this__success = new ArrayList<String>();
         for (String other_element : other.success) {
           __this__success.add(other_element);
         }
         this.success = __this__success;
       }
     }
 
     @Override
     public get_string_list_property_result clone() {
       return new get_string_list_property_result(this);
     }
 
     public List<String> getSuccess() {
       return this.success;
     }
 
    public get_string_list_property_result setSuccess(List<String> success) {
       this.success = success;
      return this;
     }
 
     public void unsetSuccess() {
       this.success = null;
     }
 
     // Returns true if field success is set (has been asigned a value) and false otherwise
     public boolean isSetSuccess() {
       return this.success != null;
     }
 
     public void setSuccessIsSet(boolean value) {
       if (!value) {
         this.success = null;
       }
     }
 
     public void setFieldValue(int fieldID, Object value) {
       switch (fieldID) {
       case SUCCESS:
         if (value == null) {
           unsetSuccess();
         } else {
           setSuccess((List<String>)value);
         }
         break;
 
       default:
         throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
       }
     }
 
     public Object getFieldValue(int fieldID) {
       switch (fieldID) {
       case SUCCESS:
         return getSuccess();
 
       default:
         throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
       }
     }
 
     // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
     public boolean isSet(int fieldID) {
       switch (fieldID) {
       case SUCCESS:
         return isSetSuccess();
       default:
         throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
       }
     }
 
     @Override
     public boolean equals(Object that) {
       if (that == null)
         return false;
       if (that instanceof get_string_list_property_result)
         return this.equals((get_string_list_property_result)that);
       return false;
     }
 
     public boolean equals(get_string_list_property_result that) {
       if (that == null)
         return false;
 
       boolean this_present_success = true && this.isSetSuccess();
       boolean that_present_success = true && that.isSetSuccess();
       if (this_present_success || that_present_success) {
         if (!(this_present_success && that_present_success))
           return false;
         if (!this.success.equals(that.success))
           return false;
       }
 
       return true;
     }
 
     @Override
     public int hashCode() {
       return 0;
     }
 
     public void read(TProtocol iprot) throws TException {
       TField field;
       iprot.readStructBegin();
       while (true)
       {
         field = iprot.readFieldBegin();
         if (field.type == TType.STOP) { 
           break;
         }
         switch (field.id)
         {
           case SUCCESS:
             if (field.type == TType.LIST) {
               {
                 TList _list43 = iprot.readListBegin();
                 this.success = new ArrayList<String>(_list43.size);
                 for (int _i44 = 0; _i44 < _list43.size; ++_i44)
                 {
                   String _elem45;
                   _elem45 = iprot.readString();
                   this.success.add(_elem45);
                 }
                 iprot.readListEnd();
               }
             } else { 
               TProtocolUtil.skip(iprot, field.type);
             }
             break;
           default:
             TProtocolUtil.skip(iprot, field.type);
             break;
         }
         iprot.readFieldEnd();
       }
       iprot.readStructEnd();
 
 
       // check for required fields of primitive type, which can't be checked in the validate method
       validate();
     }
 
     public void write(TProtocol oprot) throws TException {
       oprot.writeStructBegin(STRUCT_DESC);
 
       if (this.isSetSuccess()) {
         oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
         {
           oprot.writeListBegin(new TList(TType.STRING, this.success.size()));
           for (String _iter46 : this.success)          {
             oprot.writeString(_iter46);
           }
           oprot.writeListEnd();
         }
         oprot.writeFieldEnd();
       }
       oprot.writeFieldStop();
       oprot.writeStructEnd();
     }
 
     @Override
     public String toString() {
       StringBuilder sb = new StringBuilder("get_string_list_property_result(");
       boolean first = true;
 
       sb.append("success:");
       if (this.success == null) {
         sb.append("null");
       } else {
         sb.append(this.success);
       }
       first = false;
       sb.append(")");
       return sb.toString();
     }
 
     public void validate() throws TException {
       // check for required fields
       // check that fields of type enum have valid values
     }
 
   }
 
   public static class describe_keyspace_args implements TBase, java.io.Serializable, Cloneable   {
     private static final TStruct STRUCT_DESC = new TStruct("describe_keyspace_args");
     private static final TField KEYSPACE_FIELD_DESC = new TField("keyspace", TType.STRING, (short)1);
 
     public String keyspace;
     public static final int KEYSPACE = 1;
 
     private final Isset __isset = new Isset();
     private static final class Isset implements java.io.Serializable {
     }
 
     public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
       put(KEYSPACE, new FieldMetaData("keyspace", TFieldRequirementType.DEFAULT, 
           new FieldValueMetaData(TType.STRING)));
     }});
 
     static {
       FieldMetaData.addStructMetaDataMap(describe_keyspace_args.class, metaDataMap);
     }
 
     public describe_keyspace_args() {
     }
 
     public describe_keyspace_args(
       String keyspace)
     {
       this();
       this.keyspace = keyspace;
     }
 
     /**
      * Performs a deep copy on <i>other</i>.
      */
     public describe_keyspace_args(describe_keyspace_args other) {
       if (other.isSetKeyspace()) {
         this.keyspace = other.keyspace;
       }
     }
 
     @Override
     public describe_keyspace_args clone() {
       return new describe_keyspace_args(this);
     }
 
     public String getKeyspace() {
       return this.keyspace;
     }
 
    public describe_keyspace_args setKeyspace(String keyspace) {
       this.keyspace = keyspace;
      return this;
     }
 
     public void unsetKeyspace() {
       this.keyspace = null;
     }
 
     // Returns true if field keyspace is set (has been asigned a value) and false otherwise
     public boolean isSetKeyspace() {
       return this.keyspace != null;
     }
 
     public void setKeyspaceIsSet(boolean value) {
       if (!value) {
         this.keyspace = null;
       }
     }
 
     public void setFieldValue(int fieldID, Object value) {
       switch (fieldID) {
       case KEYSPACE:
         if (value == null) {
           unsetKeyspace();
         } else {
           setKeyspace((String)value);
         }
         break;
 
       default:
         throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
       }
     }
 
     public Object getFieldValue(int fieldID) {
       switch (fieldID) {
       case KEYSPACE:
         return getKeyspace();
 
       default:
         throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
       }
     }
 
     // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
     public boolean isSet(int fieldID) {
       switch (fieldID) {
       case KEYSPACE:
         return isSetKeyspace();
       default:
         throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
       }
     }
 
     @Override
     public boolean equals(Object that) {
       if (that == null)
         return false;
       if (that instanceof describe_keyspace_args)
         return this.equals((describe_keyspace_args)that);
       return false;
     }
 
     public boolean equals(describe_keyspace_args that) {
       if (that == null)
         return false;
 
       boolean this_present_keyspace = true && this.isSetKeyspace();
       boolean that_present_keyspace = true && that.isSetKeyspace();
       if (this_present_keyspace || that_present_keyspace) {
         if (!(this_present_keyspace && that_present_keyspace))
           return false;
         if (!this.keyspace.equals(that.keyspace))
           return false;
       }
 
       return true;
     }
 
     @Override
     public int hashCode() {
       return 0;
     }
 
     public void read(TProtocol iprot) throws TException {
       TField field;
       iprot.readStructBegin();
       while (true)
       {
         field = iprot.readFieldBegin();
         if (field.type == TType.STOP) { 
           break;
         }
         switch (field.id)
         {
           case KEYSPACE:
             if (field.type == TType.STRING) {
               this.keyspace = iprot.readString();
             } else { 
               TProtocolUtil.skip(iprot, field.type);
             }
             break;
           default:
             TProtocolUtil.skip(iprot, field.type);
             break;
         }
         iprot.readFieldEnd();
       }
       iprot.readStructEnd();
 
 
       // check for required fields of primitive type, which can't be checked in the validate method
       validate();
     }
 
     public void write(TProtocol oprot) throws TException {
       validate();
 
       oprot.writeStructBegin(STRUCT_DESC);
       if (this.keyspace != null) {
         oprot.writeFieldBegin(KEYSPACE_FIELD_DESC);
         oprot.writeString(this.keyspace);
         oprot.writeFieldEnd();
       }
       oprot.writeFieldStop();
       oprot.writeStructEnd();
     }
 
     @Override
     public String toString() {
       StringBuilder sb = new StringBuilder("describe_keyspace_args(");
       boolean first = true;
 
       sb.append("keyspace:");
       if (this.keyspace == null) {
         sb.append("null");
       } else {
         sb.append(this.keyspace);
       }
       first = false;
       sb.append(")");
       return sb.toString();
     }
 
     public void validate() throws TException {
       // check for required fields
       // check that fields of type enum have valid values
     }
 
   }
 
   public static class describe_keyspace_result implements TBase, java.io.Serializable, Cloneable   {
     private static final TStruct STRUCT_DESC = new TStruct("describe_keyspace_result");
     private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.MAP, (short)0);
     private static final TField NFE_FIELD_DESC = new TField("nfe", TType.STRUCT, (short)1);
 
     public Map<String,Map<String,String>> success;
     public static final int SUCCESS = 0;
     public NotFoundException nfe;
     public static final int NFE = 1;
 
     private final Isset __isset = new Isset();
     private static final class Isset implements java.io.Serializable {
     }
 
     public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
       put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
           new MapMetaData(TType.MAP, 
               new FieldValueMetaData(TType.STRING), 
               new MapMetaData(TType.MAP, 
                   new FieldValueMetaData(TType.STRING), 
                   new FieldValueMetaData(TType.STRING)))));
       put(NFE, new FieldMetaData("nfe", TFieldRequirementType.DEFAULT, 
           new FieldValueMetaData(TType.STRUCT)));
     }});
 
     static {
       FieldMetaData.addStructMetaDataMap(describe_keyspace_result.class, metaDataMap);
     }
 
     public describe_keyspace_result() {
     }
 
     public describe_keyspace_result(
       Map<String,Map<String,String>> success,
       NotFoundException nfe)
     {
       this();
       this.success = success;
       this.nfe = nfe;
     }
 
     /**
      * Performs a deep copy on <i>other</i>.
      */
     public describe_keyspace_result(describe_keyspace_result other) {
       if (other.isSetSuccess()) {
         Map<String,Map<String,String>> __this__success = new HashMap<String,Map<String,String>>();
         for (Map.Entry<String, Map<String,String>> other_element : other.success.entrySet()) {
 
           String other_element_key = other_element.getKey();
           Map<String,String> other_element_value = other_element.getValue();
 
           String __this__success_copy_key = other_element_key;
 
           Map<String,String> __this__success_copy_value = new HashMap<String,String>();
           for (Map.Entry<String, String> other_element_value_element : other_element_value.entrySet()) {
 
             String other_element_value_element_key = other_element_value_element.getKey();
             String other_element_value_element_value = other_element_value_element.getValue();
 
             String __this__success_copy_value_copy_key = other_element_value_element_key;
 
             String __this__success_copy_value_copy_value = other_element_value_element_value;
 
             __this__success_copy_value.put(__this__success_copy_value_copy_key, __this__success_copy_value_copy_value);
           }
 
           __this__success.put(__this__success_copy_key, __this__success_copy_value);
         }
         this.success = __this__success;
       }
       if (other.isSetNfe()) {
         this.nfe = new NotFoundException(other.nfe);
       }
     }
 
     @Override
     public describe_keyspace_result clone() {
       return new describe_keyspace_result(this);
     }
 
     public Map<String,Map<String,String>> getSuccess() {
       return this.success;
     }
 
    public describe_keyspace_result setSuccess(Map<String,Map<String,String>> success) {
       this.success = success;
      return this;
     }
 
     public void unsetSuccess() {
       this.success = null;
     }
 
     // Returns true if field success is set (has been asigned a value) and false otherwise
     public boolean isSetSuccess() {
       return this.success != null;
     }
 
     public void setSuccessIsSet(boolean value) {
       if (!value) {
         this.success = null;
       }
     }
 
     public NotFoundException getNfe() {
       return this.nfe;
     }
 
    public describe_keyspace_result setNfe(NotFoundException nfe) {
       this.nfe = nfe;
      return this;
     }
 
     public void unsetNfe() {
       this.nfe = null;
     }
 
     // Returns true if field nfe is set (has been asigned a value) and false otherwise
     public boolean isSetNfe() {
       return this.nfe != null;
     }
 
     public void setNfeIsSet(boolean value) {
       if (!value) {
         this.nfe = null;
       }
     }
 
     public void setFieldValue(int fieldID, Object value) {
       switch (fieldID) {
       case SUCCESS:
         if (value == null) {
           unsetSuccess();
         } else {
           setSuccess((Map<String,Map<String,String>>)value);
         }
         break;
 
       case NFE:
         if (value == null) {
           unsetNfe();
         } else {
           setNfe((NotFoundException)value);
         }
         break;
 
       default:
         throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
       }
     }
 
     public Object getFieldValue(int fieldID) {
       switch (fieldID) {
       case SUCCESS:
         return getSuccess();
 
       case NFE:
         return getNfe();
 
       default:
         throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
       }
     }
 
     // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
     public boolean isSet(int fieldID) {
       switch (fieldID) {
       case SUCCESS:
         return isSetSuccess();
       case NFE:
         return isSetNfe();
       default:
         throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
       }
     }
 
     @Override
     public boolean equals(Object that) {
       if (that == null)
         return false;
       if (that instanceof describe_keyspace_result)
         return this.equals((describe_keyspace_result)that);
       return false;
     }
 
     public boolean equals(describe_keyspace_result that) {
       if (that == null)
         return false;
 
       boolean this_present_success = true && this.isSetSuccess();
       boolean that_present_success = true && that.isSetSuccess();
       if (this_present_success || that_present_success) {
         if (!(this_present_success && that_present_success))
           return false;
         if (!this.success.equals(that.success))
           return false;
       }
 
       boolean this_present_nfe = true && this.isSetNfe();
       boolean that_present_nfe = true && that.isSetNfe();
       if (this_present_nfe || that_present_nfe) {
         if (!(this_present_nfe && that_present_nfe))
           return false;
         if (!this.nfe.equals(that.nfe))
           return false;
       }
 
       return true;
     }
 
     @Override
     public int hashCode() {
       return 0;
     }
 
     public void read(TProtocol iprot) throws TException {
       TField field;
       iprot.readStructBegin();
       while (true)
       {
         field = iprot.readFieldBegin();
         if (field.type == TType.STOP) { 
           break;
         }
         switch (field.id)
         {
           case SUCCESS:
             if (field.type == TType.MAP) {
               {
                 TMap _map47 = iprot.readMapBegin();
                 this.success = new HashMap<String,Map<String,String>>(2*_map47.size);
                 for (int _i48 = 0; _i48 < _map47.size; ++_i48)
                 {
                   String _key49;
                   Map<String,String> _val50;
                   _key49 = iprot.readString();
                   {
                     TMap _map51 = iprot.readMapBegin();
                     _val50 = new HashMap<String,String>(2*_map51.size);
                     for (int _i52 = 0; _i52 < _map51.size; ++_i52)
                     {
                       String _key53;
                       String _val54;
                       _key53 = iprot.readString();
                       _val54 = iprot.readString();
                       _val50.put(_key53, _val54);
                     }
                     iprot.readMapEnd();
                   }
                   this.success.put(_key49, _val50);
                 }
                 iprot.readMapEnd();
               }
             } else { 
               TProtocolUtil.skip(iprot, field.type);
             }
             break;
           case NFE:
             if (field.type == TType.STRUCT) {
               this.nfe = new NotFoundException();
               this.nfe.read(iprot);
             } else { 
               TProtocolUtil.skip(iprot, field.type);
             }
             break;
           default:
             TProtocolUtil.skip(iprot, field.type);
             break;
         }
         iprot.readFieldEnd();
       }
       iprot.readStructEnd();
 
 
       // check for required fields of primitive type, which can't be checked in the validate method
       validate();
     }
 
     public void write(TProtocol oprot) throws TException {
       oprot.writeStructBegin(STRUCT_DESC);
 
       if (this.isSetSuccess()) {
         oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
         {
           oprot.writeMapBegin(new TMap(TType.STRING, TType.MAP, this.success.size()));
           for (Map.Entry<String, Map<String,String>> _iter55 : this.success.entrySet())          {
             oprot.writeString(_iter55.getKey());
             {
               oprot.writeMapBegin(new TMap(TType.STRING, TType.STRING, _iter55.getValue().size()));
               for (Map.Entry<String, String> _iter56 : _iter55.getValue().entrySet())              {
                 oprot.writeString(_iter56.getKey());
                 oprot.writeString(_iter56.getValue());
               }
               oprot.writeMapEnd();
             }
           }
           oprot.writeMapEnd();
         }
         oprot.writeFieldEnd();
       } else if (this.isSetNfe()) {
         oprot.writeFieldBegin(NFE_FIELD_DESC);
         this.nfe.write(oprot);
         oprot.writeFieldEnd();
       }
       oprot.writeFieldStop();
       oprot.writeStructEnd();
     }
 
     @Override
     public String toString() {
       StringBuilder sb = new StringBuilder("describe_keyspace_result(");
       boolean first = true;
 
       sb.append("success:");
       if (this.success == null) {
         sb.append("null");
       } else {
         sb.append(this.success);
       }
       first = false;
       if (!first) sb.append(", ");
       sb.append("nfe:");
       if (this.nfe == null) {
         sb.append("null");
       } else {
         sb.append(this.nfe);
       }
       first = false;
       sb.append(")");
       return sb.toString();
     }
 
     public void validate() throws TException {
       // check for required fields
       // check that fields of type enum have valid values
     }
 
   }
 
 }
