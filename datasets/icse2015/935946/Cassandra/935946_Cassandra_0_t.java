 /**
  * Autogenerated by Thrift
  *
  * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
  */
 package org.apache.cassandra.thrift;
 /*
  * 
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  * 
  *   http://www.apache.org/licenses/LICENSE-2.0
  * 
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  * 
  */
 
 
 import java.util.List;
 import java.util.ArrayList;
 import java.util.Map;
 import java.util.HashMap;
 import java.util.EnumMap;
 import java.util.Set;
 import java.util.HashSet;
 import java.util.EnumSet;
 import java.util.Collections;
 import java.util.BitSet;
 import java.util.Arrays;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
 import org.apache.thrift.*;
 import org.apache.thrift.meta_data.*;
 import org.apache.thrift.protocol.*;
 
 public class Cassandra {
 
   public interface Iface {
 
     public AccessLevel login(String keyspace, AuthenticationRequest auth_request) throws AuthenticationException, AuthorizationException, TException;
 
     /**
      * Get the Column or SuperColumn at the given column_path. If no value is present, NotFoundException is thrown. (This is
      * the only method that can throw an exception under non-failure conditions.)
      * 
      * @param keyspace
      * @param key
      * @param column_path
      * @param consistency_level
      */
     public ColumnOrSuperColumn get(String keyspace, byte[] key, ColumnPath column_path, ConsistencyLevel consistency_level) throws InvalidRequestException, NotFoundException, UnavailableException, TimedOutException, TException;
 
     /**
      * Get the group of columns contained by column_parent (either a ColumnFamily name or a ColumnFamily/SuperColumn name
      * pair) specified by the given SlicePredicate. If no matching values are found, an empty list is returned.
      * 
      * @param keyspace
      * @param key
      * @param column_parent
      * @param predicate
      * @param consistency_level
      */
     public List<ColumnOrSuperColumn> get_slice(String keyspace, byte[] key, ColumnParent column_parent, SlicePredicate predicate, ConsistencyLevel consistency_level) throws InvalidRequestException, UnavailableException, TimedOutException, TException;
 
     /**
      * Perform a get for column_path in parallel on the given list<binary> keys. The return value maps keys to the
      * ColumnOrSuperColumn found. If no value corresponding to a key is present, the key will still be in the map, but both
      * the column and super_column references of the ColumnOrSuperColumn object it maps to will be null.
      * @deprecated; use multiget_slice
      * 
      * @param keyspace
      * @param keys
      * @param column_path
      * @param consistency_level
      */
     public Map<byte[],ColumnOrSuperColumn> multiget(String keyspace, List<byte[]> keys, ColumnPath column_path, ConsistencyLevel consistency_level) throws InvalidRequestException, UnavailableException, TimedOutException, TException;
 
     /**
      * Performs a get_slice for column_parent and predicate for the given keys in parallel.
      * 
      * @param keyspace
      * @param keys
      * @param column_parent
      * @param predicate
      * @param consistency_level
      */
     public Map<byte[],List<ColumnOrSuperColumn>> multiget_slice(String keyspace, List<byte[]> keys, ColumnParent column_parent, SlicePredicate predicate, ConsistencyLevel consistency_level) throws InvalidRequestException, UnavailableException, TimedOutException, TException;
 
     /**
     * returns the number of columns matching <code>predicate</code> for a particular <code>key</code>,
     * <code>ColumnFamily</code> and optionally <code>SuperColumn</code>.
      * 
      * @param keyspace
      * @param key
      * @param column_parent
     * @param predicate
     * @param consistency_level
     */
    public int get_count(String keyspace, byte[] key, ColumnParent column_parent, SlicePredicate predicate, ConsistencyLevel consistency_level) throws InvalidRequestException, UnavailableException, TimedOutException, TException;

    /**
     * Perform a get_count in parallel on the given list<binary> keys. The return value maps keys to the count found.
     * 
     * @param keyspace
     * @param keys
     * @param column_parent
     * @param predicate
      * @param consistency_level
      */
    public Map<byte[],Integer> multiget_count(String keyspace, List<byte[]> keys, ColumnParent column_parent, SlicePredicate predicate, ConsistencyLevel consistency_level) throws InvalidRequestException, UnavailableException, TimedOutException, TException;
 
     /**
      * returns a subset of columns for a range of keys.
      * @Deprecated.  Use get_range_slices instead
      * 
      * @param keyspace
      * @param column_parent
      * @param predicate
      * @param start_key
      * @param finish_key
      * @param row_count
      * @param consistency_level
      */
     public List<KeySlice> get_range_slice(String keyspace, ColumnParent column_parent, SlicePredicate predicate, byte[] start_key, byte[] finish_key, int row_count, ConsistencyLevel consistency_level) throws InvalidRequestException, UnavailableException, TimedOutException, TException;
 
     /**
      * returns a subset of columns for a range of keys.
      * 
      * @param keyspace
      * @param column_parent
      * @param predicate
      * @param range
      * @param consistency_level
      */
     public List<KeySlice> get_range_slices(String keyspace, ColumnParent column_parent, SlicePredicate predicate, KeyRange range, ConsistencyLevel consistency_level) throws InvalidRequestException, UnavailableException, TimedOutException, TException;
 
     /**
      * Insert a Column at the given column_parent.column_family and optional column_parent.super_column.
      * 
      * @param keyspace
      * @param key
      * @param column_parent
      * @param column
      * @param consistency_level
      */
     public void insert(String keyspace, byte[] key, ColumnParent column_parent, Column column, ConsistencyLevel consistency_level) throws InvalidRequestException, UnavailableException, TimedOutException, TException;
 
     /**
      * Insert Columns or SuperColumns across different Column Families for the same row key. batch_mutation is a
      * map<string, list<ColumnOrSuperColumn>> -- a map which pairs column family names with the relevant ColumnOrSuperColumn
      * objects to insert.
      * @deprecated; use batch_mutate instead
      * 
      * @param keyspace
      * @param key
      * @param cfmap
      * @param consistency_level
      */
     public void batch_insert(String keyspace, byte[] key, Map<String,List<ColumnOrSuperColumn>> cfmap, ConsistencyLevel consistency_level) throws InvalidRequestException, UnavailableException, TimedOutException, TException;
 
     /**
      * Remove data from the row specified by key at the granularity specified by column_path, and the given timestamp. Note
      * that all the values in column_path besides column_path.column_family are truly optional: you can remove the entire
      * row by just specifying the ColumnFamily, or you can remove a SuperColumn or a single Column by specifying those levels too.
      * 
      * @param keyspace
      * @param key
      * @param column_path
      * @param timestamp
      * @param consistency_level
      */
     public void remove(String keyspace, byte[] key, ColumnPath column_path, long timestamp, ConsistencyLevel consistency_level) throws InvalidRequestException, UnavailableException, TimedOutException, TException;
 
     /**
      *   Mutate many columns or super columns for many row keys. See also: Mutation.
      * 
      *   mutation_map maps key to column family to a list of Mutation objects to take place at that scope.
      * *
      * 
      * @param keyspace
      * @param mutation_map
      * @param consistency_level
      */
     public void batch_mutate(String keyspace, Map<byte[],Map<String,List<Mutation>>> mutation_map, ConsistencyLevel consistency_level) throws InvalidRequestException, UnavailableException, TimedOutException, TException;
 
     /**
      * list the defined keyspaces in this cluster
      */
     public Set<String> describe_keyspaces() throws TException;
 
     /**
      * get the cluster name
      */
     public String describe_cluster_name() throws TException;
 
     /**
      * get the thrift api version
      */
     public String describe_version() throws TException;
 
     /**
      * get the token ring: a map of ranges to host addresses,
      * represented as a set of TokenRange instead of a map from range
      * to list of endpoints, because you can't use Thrift structs as
      * map keys:
      * https://issues.apache.org/jira/browse/THRIFT-162
      * 
      * for the same reason, we can't return a set here, even though
      * order is neither important nor predictable.
      * 
      * @param keyspace
      */
     public List<TokenRange> describe_ring(String keyspace) throws TException;
 
     /**
      * describe specified keyspace
      * 
      * @param keyspace
      */
     public Map<String,Map<String,String>> describe_keyspace(String keyspace) throws NotFoundException, TException;
 
     /**
      * experimental API for hadoop/parallel query support.
      * may change violently and without warning.
      * 
      * returns list of token strings such that first subrange is (list[0], list[1]],
      * next is (list[1], list[2]], etc.
      * 
      * @param start_token
      * @param end_token
      * @param keys_per_split
      */
     public List<String> describe_splits(String start_token, String end_token, int keys_per_split) throws TException;
 
     public void system_add_column_family(CfDef cf_def) throws InvalidRequestException, TException;
 
     public void system_drop_column_family(String keyspace, String column_family) throws InvalidRequestException, TException;
 
     public void system_rename_column_family(String keyspace, String old_name, String new_name) throws InvalidRequestException, TException;
 
     public void system_add_keyspace(KsDef ks_def) throws InvalidRequestException, TException;
 
     public void system_drop_keyspace(String keyspace) throws InvalidRequestException, TException;
 
     public void system_rename_keyspace(String old_name, String new_name) throws InvalidRequestException, TException;
 
   }
 
   public static class Client implements Iface {
     public Client(TProtocol prot)
     {
       this(prot, prot);
     }
 
     public Client(TProtocol iprot, TProtocol oprot)
     {
       iprot_ = iprot;
       oprot_ = oprot;
     }
 
     protected TProtocol iprot_;
     protected TProtocol oprot_;
 
     protected int seqid_;
 
     public TProtocol getInputProtocol()
     {
       return this.iprot_;
     }
 
     public TProtocol getOutputProtocol()
     {
       return this.oprot_;
     }
 
     public AccessLevel login(String keyspace, AuthenticationRequest auth_request) throws AuthenticationException, AuthorizationException, TException
     {
       send_login(keyspace, auth_request);
       return recv_login();
     }
 
     public void send_login(String keyspace, AuthenticationRequest auth_request) throws TException
     {
       oprot_.writeMessageBegin(new TMessage("login", TMessageType.CALL, seqid_));
       login_args args = new login_args();
       args.keyspace = keyspace;
       args.auth_request = auth_request;
       args.write(oprot_);
       oprot_.writeMessageEnd();
       oprot_.getTransport().flush();
     }
 
     public AccessLevel recv_login() throws AuthenticationException, AuthorizationException, TException
     {
       TMessage msg = iprot_.readMessageBegin();
       if (msg.type == TMessageType.EXCEPTION) {
         TApplicationException x = TApplicationException.read(iprot_);
         iprot_.readMessageEnd();
         throw x;
       }
       login_result result = new login_result();
       result.read(iprot_);
       iprot_.readMessageEnd();
       if (result.isSetSuccess()) {
         return result.success;
       }
       if (result.authnx != null) {
         throw result.authnx;
       }
       if (result.authzx != null) {
         throw result.authzx;
       }
       throw new TApplicationException(TApplicationException.MISSING_RESULT, "login failed: unknown result");
     }
 
     public ColumnOrSuperColumn get(String keyspace, byte[] key, ColumnPath column_path, ConsistencyLevel consistency_level) throws InvalidRequestException, NotFoundException, UnavailableException, TimedOutException, TException
     {
       send_get(keyspace, key, column_path, consistency_level);
       return recv_get();
     }
 
     public void send_get(String keyspace, byte[] key, ColumnPath column_path, ConsistencyLevel consistency_level) throws TException
     {
       oprot_.writeMessageBegin(new TMessage("get", TMessageType.CALL, seqid_));
       get_args args = new get_args();
       args.keyspace = keyspace;
       args.key = key;
       args.column_path = column_path;
       args.consistency_level = consistency_level;
       args.write(oprot_);
       oprot_.writeMessageEnd();
       oprot_.getTransport().flush();
     }
 
     public ColumnOrSuperColumn recv_get() throws InvalidRequestException, NotFoundException, UnavailableException, TimedOutException, TException
     {
       TMessage msg = iprot_.readMessageBegin();
       if (msg.type == TMessageType.EXCEPTION) {
         TApplicationException x = TApplicationException.read(iprot_);
         iprot_.readMessageEnd();
         throw x;
       }
       get_result result = new get_result();
       result.read(iprot_);
       iprot_.readMessageEnd();
       if (result.isSetSuccess()) {
         return result.success;
       }
       if (result.ire != null) {
         throw result.ire;
       }
       if (result.nfe != null) {
         throw result.nfe;
       }
       if (result.ue != null) {
         throw result.ue;
       }
       if (result.te != null) {
         throw result.te;
       }
       throw new TApplicationException(TApplicationException.MISSING_RESULT, "get failed: unknown result");
     }
 
     public List<ColumnOrSuperColumn> get_slice(String keyspace, byte[] key, ColumnParent column_parent, SlicePredicate predicate, ConsistencyLevel consistency_level) throws InvalidRequestException, UnavailableException, TimedOutException, TException
     {
       send_get_slice(keyspace, key, column_parent, predicate, consistency_level);
       return recv_get_slice();
     }
 
     public void send_get_slice(String keyspace, byte[] key, ColumnParent column_parent, SlicePredicate predicate, ConsistencyLevel consistency_level) throws TException
     {
       oprot_.writeMessageBegin(new TMessage("get_slice", TMessageType.CALL, seqid_));
       get_slice_args args = new get_slice_args();
       args.keyspace = keyspace;
       args.key = key;
       args.column_parent = column_parent;
       args.predicate = predicate;
       args.consistency_level = consistency_level;
       args.write(oprot_);
       oprot_.writeMessageEnd();
       oprot_.getTransport().flush();
     }
 
     public List<ColumnOrSuperColumn> recv_get_slice() throws InvalidRequestException, UnavailableException, TimedOutException, TException
     {
       TMessage msg = iprot_.readMessageBegin();
       if (msg.type == TMessageType.EXCEPTION) {
         TApplicationException x = TApplicationException.read(iprot_);
         iprot_.readMessageEnd();
         throw x;
       }
       get_slice_result result = new get_slice_result();
       result.read(iprot_);
       iprot_.readMessageEnd();
       if (result.isSetSuccess()) {
         return result.success;
       }
       if (result.ire != null) {
         throw result.ire;
       }
       if (result.ue != null) {
         throw result.ue;
       }
       if (result.te != null) {
         throw result.te;
       }
       throw new TApplicationException(TApplicationException.MISSING_RESULT, "get_slice failed: unknown result");
     }
 
     public Map<byte[],ColumnOrSuperColumn> multiget(String keyspace, List<byte[]> keys, ColumnPath column_path, ConsistencyLevel consistency_level) throws InvalidRequestException, UnavailableException, TimedOutException, TException
     {
       send_multiget(keyspace, keys, column_path, consistency_level);
       return recv_multiget();
     }
 
     public void send_multiget(String keyspace, List<byte[]> keys, ColumnPath column_path, ConsistencyLevel consistency_level) throws TException
     {
       oprot_.writeMessageBegin(new TMessage("multiget", TMessageType.CALL, seqid_));
       multiget_args args = new multiget_args();
       args.keyspace = keyspace;
       args.keys = keys;
       args.column_path = column_path;
       args.consistency_level = consistency_level;
       args.write(oprot_);
       oprot_.writeMessageEnd();
       oprot_.getTransport().flush();
     }
 
     public Map<byte[],ColumnOrSuperColumn> recv_multiget() throws InvalidRequestException, UnavailableException, TimedOutException, TException
     {
       TMessage msg = iprot_.readMessageBegin();
       if (msg.type == TMessageType.EXCEPTION) {
         TApplicationException x = TApplicationException.read(iprot_);
         iprot_.readMessageEnd();
         throw x;
       }
       multiget_result result = new multiget_result();
       result.read(iprot_);
       iprot_.readMessageEnd();
       if (result.isSetSuccess()) {
         return result.success;
       }
       if (result.ire != null) {
         throw result.ire;
       }
       if (result.ue != null) {
         throw result.ue;
       }
       if (result.te != null) {
         throw result.te;
       }
       throw new TApplicationException(TApplicationException.MISSING_RESULT, "multiget failed: unknown result");
     }
 
     public Map<byte[],List<ColumnOrSuperColumn>> multiget_slice(String keyspace, List<byte[]> keys, ColumnParent column_parent, SlicePredicate predicate, ConsistencyLevel consistency_level) throws InvalidRequestException, UnavailableException, TimedOutException, TException
     {
       send_multiget_slice(keyspace, keys, column_parent, predicate, consistency_level);
       return recv_multiget_slice();
     }
 
     public void send_multiget_slice(String keyspace, List<byte[]> keys, ColumnParent column_parent, SlicePredicate predicate, ConsistencyLevel consistency_level) throws TException
     {
       oprot_.writeMessageBegin(new TMessage("multiget_slice", TMessageType.CALL, seqid_));
       multiget_slice_args args = new multiget_slice_args();
       args.keyspace = keyspace;
       args.keys = keys;
       args.column_parent = column_parent;
       args.predicate = predicate;
       args.consistency_level = consistency_level;
       args.write(oprot_);
       oprot_.writeMessageEnd();
       oprot_.getTransport().flush();
     }
 
     public Map<byte[],List<ColumnOrSuperColumn>> recv_multiget_slice() throws InvalidRequestException, UnavailableException, TimedOutException, TException
     {
       TMessage msg = iprot_.readMessageBegin();
       if (msg.type == TMessageType.EXCEPTION) {
         TApplicationException x = TApplicationException.read(iprot_);
         iprot_.readMessageEnd();
         throw x;
       }
       multiget_slice_result result = new multiget_slice_result();
       result.read(iprot_);
       iprot_.readMessageEnd();
       if (result.isSetSuccess()) {
         return result.success;
       }
       if (result.ire != null) {
         throw result.ire;
       }
       if (result.ue != null) {
         throw result.ue;
       }
       if (result.te != null) {
         throw result.te;
       }
       throw new TApplicationException(TApplicationException.MISSING_RESULT, "multiget_slice failed: unknown result");
     }
 
    public int get_count(String keyspace, byte[] key, ColumnParent column_parent, SlicePredicate predicate, ConsistencyLevel consistency_level) throws InvalidRequestException, UnavailableException, TimedOutException, TException
     {
      send_get_count(keyspace, key, column_parent, predicate, consistency_level);
       return recv_get_count();
     }
 
    public void send_get_count(String keyspace, byte[] key, ColumnParent column_parent, SlicePredicate predicate, ConsistencyLevel consistency_level) throws TException
     {
       oprot_.writeMessageBegin(new TMessage("get_count", TMessageType.CALL, seqid_));
       get_count_args args = new get_count_args();
       args.keyspace = keyspace;
       args.key = key;
       args.column_parent = column_parent;
      args.predicate = predicate;
       args.consistency_level = consistency_level;
       args.write(oprot_);
       oprot_.writeMessageEnd();
       oprot_.getTransport().flush();
     }
 
     public int recv_get_count() throws InvalidRequestException, UnavailableException, TimedOutException, TException
     {
       TMessage msg = iprot_.readMessageBegin();
       if (msg.type == TMessageType.EXCEPTION) {
         TApplicationException x = TApplicationException.read(iprot_);
         iprot_.readMessageEnd();
         throw x;
       }
       get_count_result result = new get_count_result();
       result.read(iprot_);
       iprot_.readMessageEnd();
       if (result.isSetSuccess()) {
         return result.success;
       }
       if (result.ire != null) {
         throw result.ire;
       }
       if (result.ue != null) {
         throw result.ue;
       }
       if (result.te != null) {
         throw result.te;
       }
       throw new TApplicationException(TApplicationException.MISSING_RESULT, "get_count failed: unknown result");
     }
 
    public Map<byte[],Integer> multiget_count(String keyspace, List<byte[]> keys, ColumnParent column_parent, SlicePredicate predicate, ConsistencyLevel consistency_level) throws InvalidRequestException, UnavailableException, TimedOutException, TException
    {
      send_multiget_count(keyspace, keys, column_parent, predicate, consistency_level);
      return recv_multiget_count();
    }

    public void send_multiget_count(String keyspace, List<byte[]> keys, ColumnParent column_parent, SlicePredicate predicate, ConsistencyLevel consistency_level) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("multiget_count", TMessageType.CALL, seqid_));
      multiget_count_args args = new multiget_count_args();
      args.keyspace = keyspace;
      args.keys = keys;
      args.column_parent = column_parent;
      args.predicate = predicate;
      args.consistency_level = consistency_level;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public Map<byte[],Integer> recv_multiget_count() throws InvalidRequestException, UnavailableException, TimedOutException, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      multiget_count_result result = new multiget_count_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.isSetSuccess()) {
        return result.success;
      }
      if (result.ire != null) {
        throw result.ire;
      }
      if (result.ue != null) {
        throw result.ue;
      }
      if (result.te != null) {
        throw result.te;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "multiget_count failed: unknown result");
    }

     public List<KeySlice> get_range_slice(String keyspace, ColumnParent column_parent, SlicePredicate predicate, byte[] start_key, byte[] finish_key, int row_count, ConsistencyLevel consistency_level) throws InvalidRequestException, UnavailableException, TimedOutException, TException
     {
       send_get_range_slice(keyspace, column_parent, predicate, start_key, finish_key, row_count, consistency_level);
       return recv_get_range_slice();
     }
 
     public void send_get_range_slice(String keyspace, ColumnParent column_parent, SlicePredicate predicate, byte[] start_key, byte[] finish_key, int row_count, ConsistencyLevel consistency_level) throws TException
     {
       oprot_.writeMessageBegin(new TMessage("get_range_slice", TMessageType.CALL, seqid_));
       get_range_slice_args args = new get_range_slice_args();
       args.keyspace = keyspace;
       args.column_parent = column_parent;
       args.predicate = predicate;
       args.start_key = start_key;
       args.finish_key = finish_key;
       args.row_count = row_count;
       args.consistency_level = consistency_level;
       args.write(oprot_);
       oprot_.writeMessageEnd();
       oprot_.getTransport().flush();
     }
 
     public List<KeySlice> recv_get_range_slice() throws InvalidRequestException, UnavailableException, TimedOutException, TException
     {
       TMessage msg = iprot_.readMessageBegin();
       if (msg.type == TMessageType.EXCEPTION) {
         TApplicationException x = TApplicationException.read(iprot_);
         iprot_.readMessageEnd();
         throw x;
       }
       get_range_slice_result result = new get_range_slice_result();
       result.read(iprot_);
       iprot_.readMessageEnd();
       if (result.isSetSuccess()) {
         return result.success;
       }
       if (result.ire != null) {
         throw result.ire;
       }
       if (result.ue != null) {
         throw result.ue;
       }
       if (result.te != null) {
         throw result.te;
       }
       throw new TApplicationException(TApplicationException.MISSING_RESULT, "get_range_slice failed: unknown result");
     }
 
     public List<KeySlice> get_range_slices(String keyspace, ColumnParent column_parent, SlicePredicate predicate, KeyRange range, ConsistencyLevel consistency_level) throws InvalidRequestException, UnavailableException, TimedOutException, TException
     {
       send_get_range_slices(keyspace, column_parent, predicate, range, consistency_level);
       return recv_get_range_slices();
     }
 
     public void send_get_range_slices(String keyspace, ColumnParent column_parent, SlicePredicate predicate, KeyRange range, ConsistencyLevel consistency_level) throws TException
     {
       oprot_.writeMessageBegin(new TMessage("get_range_slices", TMessageType.CALL, seqid_));
       get_range_slices_args args = new get_range_slices_args();
       args.keyspace = keyspace;
       args.column_parent = column_parent;
       args.predicate = predicate;
       args.range = range;
       args.consistency_level = consistency_level;
       args.write(oprot_);
       oprot_.writeMessageEnd();
       oprot_.getTransport().flush();
     }
 
     public List<KeySlice> recv_get_range_slices() throws InvalidRequestException, UnavailableException, TimedOutException, TException
     {
       TMessage msg = iprot_.readMessageBegin();
       if (msg.type == TMessageType.EXCEPTION) {
         TApplicationException x = TApplicationException.read(iprot_);
         iprot_.readMessageEnd();
         throw x;
       }
       get_range_slices_result result = new get_range_slices_result();
       result.read(iprot_);
       iprot_.readMessageEnd();
       if (result.isSetSuccess()) {
         return result.success;
       }
       if (result.ire != null) {
         throw result.ire;
       }
       if (result.ue != null) {
         throw result.ue;
       }
       if (result.te != null) {
         throw result.te;
       }
       throw new TApplicationException(TApplicationException.MISSING_RESULT, "get_range_slices failed: unknown result");
     }
 
     public void insert(String keyspace, byte[] key, ColumnParent column_parent, Column column, ConsistencyLevel consistency_level) throws InvalidRequestException, UnavailableException, TimedOutException, TException
     {
       send_insert(keyspace, key, column_parent, column, consistency_level);
       recv_insert();
     }
 
     public void send_insert(String keyspace, byte[] key, ColumnParent column_parent, Column column, ConsistencyLevel consistency_level) throws TException
     {
       oprot_.writeMessageBegin(new TMessage("insert", TMessageType.CALL, seqid_));
       insert_args args = new insert_args();
       args.keyspace = keyspace;
       args.key = key;
       args.column_parent = column_parent;
       args.column = column;
       args.consistency_level = consistency_level;
       args.write(oprot_);
       oprot_.writeMessageEnd();
       oprot_.getTransport().flush();
     }
 
     public void recv_insert() throws InvalidRequestException, UnavailableException, TimedOutException, TException
     {
       TMessage msg = iprot_.readMessageBegin();
       if (msg.type == TMessageType.EXCEPTION) {
         TApplicationException x = TApplicationException.read(iprot_);
         iprot_.readMessageEnd();
         throw x;
       }
       insert_result result = new insert_result();
       result.read(iprot_);
       iprot_.readMessageEnd();
       if (result.ire != null) {
         throw result.ire;
       }
       if (result.ue != null) {
         throw result.ue;
       }
       if (result.te != null) {
         throw result.te;
       }
       return;
     }
 
     public void batch_insert(String keyspace, byte[] key, Map<String,List<ColumnOrSuperColumn>> cfmap, ConsistencyLevel consistency_level) throws InvalidRequestException, UnavailableException, TimedOutException, TException
     {
       send_batch_insert(keyspace, key, cfmap, consistency_level);
       recv_batch_insert();
     }
 
     public void send_batch_insert(String keyspace, byte[] key, Map<String,List<ColumnOrSuperColumn>> cfmap, ConsistencyLevel consistency_level) throws TException
     {
       oprot_.writeMessageBegin(new TMessage("batch_insert", TMessageType.CALL, seqid_));
       batch_insert_args args = new batch_insert_args();
       args.keyspace = keyspace;
       args.key = key;
       args.cfmap = cfmap;
       args.consistency_level = consistency_level;
       args.write(oprot_);
       oprot_.writeMessageEnd();
       oprot_.getTransport().flush();
     }
 
     public void recv_batch_insert() throws InvalidRequestException, UnavailableException, TimedOutException, TException
     {
       TMessage msg = iprot_.readMessageBegin();
       if (msg.type == TMessageType.EXCEPTION) {
         TApplicationException x = TApplicationException.read(iprot_);
         iprot_.readMessageEnd();
         throw x;
       }
       batch_insert_result result = new batch_insert_result();
       result.read(iprot_);
       iprot_.readMessageEnd();
       if (result.ire != null) {
         throw result.ire;
       }
       if (result.ue != null) {
         throw result.ue;
       }
       if (result.te != null) {
         throw result.te;
       }
       return;
     }
 
     public void remove(String keyspace, byte[] key, ColumnPath column_path, long timestamp, ConsistencyLevel consistency_level) throws InvalidRequestException, UnavailableException, TimedOutException, TException
     {
       send_remove(keyspace, key, column_path, timestamp, consistency_level);
       recv_remove();
     }
 
     public void send_remove(String keyspace, byte[] key, ColumnPath column_path, long timestamp, ConsistencyLevel consistency_level) throws TException
     {
       oprot_.writeMessageBegin(new TMessage("remove", TMessageType.CALL, seqid_));
       remove_args args = new remove_args();
       args.keyspace = keyspace;
       args.key = key;
       args.column_path = column_path;
       args.timestamp = timestamp;
       args.consistency_level = consistency_level;
       args.write(oprot_);
       oprot_.writeMessageEnd();
       oprot_.getTransport().flush();
     }
 
     public void recv_remove() throws InvalidRequestException, UnavailableException, TimedOutException, TException
     {
       TMessage msg = iprot_.readMessageBegin();
       if (msg.type == TMessageType.EXCEPTION) {
         TApplicationException x = TApplicationException.read(iprot_);
         iprot_.readMessageEnd();
         throw x;
       }
       remove_result result = new remove_result();
       result.read(iprot_);
       iprot_.readMessageEnd();
       if (result.ire != null) {
         throw result.ire;
       }
       if (result.ue != null) {
         throw result.ue;
       }
       if (result.te != null) {
         throw result.te;
       }
       return;
     }
 
     public void batch_mutate(String keyspace, Map<byte[],Map<String,List<Mutation>>> mutation_map, ConsistencyLevel consistency_level) throws InvalidRequestException, UnavailableException, TimedOutException, TException
     {
       send_batch_mutate(keyspace, mutation_map, consistency_level);
       recv_batch_mutate();
     }
 
     public void send_batch_mutate(String keyspace, Map<byte[],Map<String,List<Mutation>>> mutation_map, ConsistencyLevel consistency_level) throws TException
     {
       oprot_.writeMessageBegin(new TMessage("batch_mutate", TMessageType.CALL, seqid_));
       batch_mutate_args args = new batch_mutate_args();
       args.keyspace = keyspace;
       args.mutation_map = mutation_map;
       args.consistency_level = consistency_level;
       args.write(oprot_);
       oprot_.writeMessageEnd();
       oprot_.getTransport().flush();
     }
 
     public void recv_batch_mutate() throws InvalidRequestException, UnavailableException, TimedOutException, TException
     {
       TMessage msg = iprot_.readMessageBegin();
       if (msg.type == TMessageType.EXCEPTION) {
         TApplicationException x = TApplicationException.read(iprot_);
         iprot_.readMessageEnd();
         throw x;
       }
       batch_mutate_result result = new batch_mutate_result();
       result.read(iprot_);
       iprot_.readMessageEnd();
       if (result.ire != null) {
         throw result.ire;
       }
       if (result.ue != null) {
         throw result.ue;
       }
       if (result.te != null) {
         throw result.te;
       }
       return;
     }
 
     public Set<String> describe_keyspaces() throws TException
     {
       send_describe_keyspaces();
       return recv_describe_keyspaces();
     }
 
     public void send_describe_keyspaces() throws TException
     {
       oprot_.writeMessageBegin(new TMessage("describe_keyspaces", TMessageType.CALL, seqid_));
       describe_keyspaces_args args = new describe_keyspaces_args();
       args.write(oprot_);
       oprot_.writeMessageEnd();
       oprot_.getTransport().flush();
     }
 
     public Set<String> recv_describe_keyspaces() throws TException
     {
       TMessage msg = iprot_.readMessageBegin();
       if (msg.type == TMessageType.EXCEPTION) {
         TApplicationException x = TApplicationException.read(iprot_);
         iprot_.readMessageEnd();
         throw x;
       }
       describe_keyspaces_result result = new describe_keyspaces_result();
       result.read(iprot_);
       iprot_.readMessageEnd();
       if (result.isSetSuccess()) {
         return result.success;
       }
       throw new TApplicationException(TApplicationException.MISSING_RESULT, "describe_keyspaces failed: unknown result");
     }
 
     public String describe_cluster_name() throws TException
     {
       send_describe_cluster_name();
       return recv_describe_cluster_name();
     }
 
     public void send_describe_cluster_name() throws TException
     {
       oprot_.writeMessageBegin(new TMessage("describe_cluster_name", TMessageType.CALL, seqid_));
       describe_cluster_name_args args = new describe_cluster_name_args();
       args.write(oprot_);
       oprot_.writeMessageEnd();
       oprot_.getTransport().flush();
     }
 
     public String recv_describe_cluster_name() throws TException
     {
       TMessage msg = iprot_.readMessageBegin();
       if (msg.type == TMessageType.EXCEPTION) {
         TApplicationException x = TApplicationException.read(iprot_);
         iprot_.readMessageEnd();
         throw x;
       }
       describe_cluster_name_result result = new describe_cluster_name_result();
       result.read(iprot_);
       iprot_.readMessageEnd();
       if (result.isSetSuccess()) {
         return result.success;
       }
       throw new TApplicationException(TApplicationException.MISSING_RESULT, "describe_cluster_name failed: unknown result");
     }
 
     public String describe_version() throws TException
     {
       send_describe_version();
       return recv_describe_version();
     }
 
     public void send_describe_version() throws TException
     {
       oprot_.writeMessageBegin(new TMessage("describe_version", TMessageType.CALL, seqid_));
       describe_version_args args = new describe_version_args();
       args.write(oprot_);
       oprot_.writeMessageEnd();
       oprot_.getTransport().flush();
     }
 
     public String recv_describe_version() throws TException
     {
       TMessage msg = iprot_.readMessageBegin();
       if (msg.type == TMessageType.EXCEPTION) {
         TApplicationException x = TApplicationException.read(iprot_);
         iprot_.readMessageEnd();
         throw x;
       }
       describe_version_result result = new describe_version_result();
       result.read(iprot_);
       iprot_.readMessageEnd();
       if (result.isSetSuccess()) {
         return result.success;
       }
       throw new TApplicationException(TApplicationException.MISSING_RESULT, "describe_version failed: unknown result");
     }
 
     public List<TokenRange> describe_ring(String keyspace) throws TException
     {
       send_describe_ring(keyspace);
       return recv_describe_ring();
     }
 
     public void send_describe_ring(String keyspace) throws TException
     {
       oprot_.writeMessageBegin(new TMessage("describe_ring", TMessageType.CALL, seqid_));
       describe_ring_args args = new describe_ring_args();
       args.keyspace = keyspace;
       args.write(oprot_);
       oprot_.writeMessageEnd();
       oprot_.getTransport().flush();
     }
 
     public List<TokenRange> recv_describe_ring() throws TException
     {
       TMessage msg = iprot_.readMessageBegin();
       if (msg.type == TMessageType.EXCEPTION) {
         TApplicationException x = TApplicationException.read(iprot_);
         iprot_.readMessageEnd();
         throw x;
       }
       describe_ring_result result = new describe_ring_result();
       result.read(iprot_);
       iprot_.readMessageEnd();
       if (result.isSetSuccess()) {
         return result.success;
       }
       throw new TApplicationException(TApplicationException.MISSING_RESULT, "describe_ring failed: unknown result");
     }
 
     public Map<String,Map<String,String>> describe_keyspace(String keyspace) throws NotFoundException, TException
     {
       send_describe_keyspace(keyspace);
       return recv_describe_keyspace();
     }
 
     public void send_describe_keyspace(String keyspace) throws TException
     {
       oprot_.writeMessageBegin(new TMessage("describe_keyspace", TMessageType.CALL, seqid_));
       describe_keyspace_args args = new describe_keyspace_args();
       args.keyspace = keyspace;
       args.write(oprot_);
       oprot_.writeMessageEnd();
       oprot_.getTransport().flush();
     }
 
     public Map<String,Map<String,String>> recv_describe_keyspace() throws NotFoundException, TException
     {
       TMessage msg = iprot_.readMessageBegin();
       if (msg.type == TMessageType.EXCEPTION) {
         TApplicationException x = TApplicationException.read(iprot_);
         iprot_.readMessageEnd();
         throw x;
       }
       describe_keyspace_result result = new describe_keyspace_result();
       result.read(iprot_);
       iprot_.readMessageEnd();
       if (result.isSetSuccess()) {
         return result.success;
       }
       if (result.nfe != null) {
         throw result.nfe;
       }
       throw new TApplicationException(TApplicationException.MISSING_RESULT, "describe_keyspace failed: unknown result");
     }
 
     public List<String> describe_splits(String start_token, String end_token, int keys_per_split) throws TException
     {
       send_describe_splits(start_token, end_token, keys_per_split);
       return recv_describe_splits();
     }
 
     public void send_describe_splits(String start_token, String end_token, int keys_per_split) throws TException
     {
       oprot_.writeMessageBegin(new TMessage("describe_splits", TMessageType.CALL, seqid_));
       describe_splits_args args = new describe_splits_args();
       args.start_token = start_token;
       args.end_token = end_token;
       args.keys_per_split = keys_per_split;
       args.write(oprot_);
       oprot_.writeMessageEnd();
       oprot_.getTransport().flush();
     }
 
     public List<String> recv_describe_splits() throws TException
     {
       TMessage msg = iprot_.readMessageBegin();
       if (msg.type == TMessageType.EXCEPTION) {
         TApplicationException x = TApplicationException.read(iprot_);
         iprot_.readMessageEnd();
         throw x;
       }
       describe_splits_result result = new describe_splits_result();
       result.read(iprot_);
       iprot_.readMessageEnd();
       if (result.isSetSuccess()) {
         return result.success;
       }
       throw new TApplicationException(TApplicationException.MISSING_RESULT, "describe_splits failed: unknown result");
     }
 
     public void system_add_column_family(CfDef cf_def) throws InvalidRequestException, TException
     {
       send_system_add_column_family(cf_def);
       recv_system_add_column_family();
     }
 
     public void send_system_add_column_family(CfDef cf_def) throws TException
     {
       oprot_.writeMessageBegin(new TMessage("system_add_column_family", TMessageType.CALL, seqid_));
       system_add_column_family_args args = new system_add_column_family_args();
       args.cf_def = cf_def;
       args.write(oprot_);
       oprot_.writeMessageEnd();
       oprot_.getTransport().flush();
     }
 
     public void recv_system_add_column_family() throws InvalidRequestException, TException
     {
       TMessage msg = iprot_.readMessageBegin();
       if (msg.type == TMessageType.EXCEPTION) {
         TApplicationException x = TApplicationException.read(iprot_);
         iprot_.readMessageEnd();
         throw x;
       }
       system_add_column_family_result result = new system_add_column_family_result();
       result.read(iprot_);
       iprot_.readMessageEnd();
       if (result.ire != null) {
         throw result.ire;
       }
       return;
     }
 
     public void system_drop_column_family(String keyspace, String column_family) throws InvalidRequestException, TException
     {
       send_system_drop_column_family(keyspace, column_family);
       recv_system_drop_column_family();
     }
 
     public void send_system_drop_column_family(String keyspace, String column_family) throws TException
     {
       oprot_.writeMessageBegin(new TMessage("system_drop_column_family", TMessageType.CALL, seqid_));
       system_drop_column_family_args args = new system_drop_column_family_args();
       args.keyspace = keyspace;
       args.column_family = column_family;
       args.write(oprot_);
       oprot_.writeMessageEnd();
       oprot_.getTransport().flush();
     }
 
     public void recv_system_drop_column_family() throws InvalidRequestException, TException
     {
       TMessage msg = iprot_.readMessageBegin();
       if (msg.type == TMessageType.EXCEPTION) {
         TApplicationException x = TApplicationException.read(iprot_);
         iprot_.readMessageEnd();
         throw x;
       }
       system_drop_column_family_result result = new system_drop_column_family_result();
       result.read(iprot_);
       iprot_.readMessageEnd();
       if (result.ire != null) {
         throw result.ire;
       }
       return;
     }
 
     public void system_rename_column_family(String keyspace, String old_name, String new_name) throws InvalidRequestException, TException
     {
       send_system_rename_column_family(keyspace, old_name, new_name);
       recv_system_rename_column_family();
     }
 
     public void send_system_rename_column_family(String keyspace, String old_name, String new_name) throws TException
     {
       oprot_.writeMessageBegin(new TMessage("system_rename_column_family", TMessageType.CALL, seqid_));
       system_rename_column_family_args args = new system_rename_column_family_args();
       args.keyspace = keyspace;
       args.old_name = old_name;
       args.new_name = new_name;
       args.write(oprot_);
       oprot_.writeMessageEnd();
       oprot_.getTransport().flush();
     }
 
     public void recv_system_rename_column_family() throws InvalidRequestException, TException
     {
       TMessage msg = iprot_.readMessageBegin();
       if (msg.type == TMessageType.EXCEPTION) {
         TApplicationException x = TApplicationException.read(iprot_);
         iprot_.readMessageEnd();
         throw x;
       }
       system_rename_column_family_result result = new system_rename_column_family_result();
       result.read(iprot_);
       iprot_.readMessageEnd();
       if (result.ire != null) {
         throw result.ire;
       }
       return;
     }
 
     public void system_add_keyspace(KsDef ks_def) throws InvalidRequestException, TException
     {
       send_system_add_keyspace(ks_def);
       recv_system_add_keyspace();
     }
 
     public void send_system_add_keyspace(KsDef ks_def) throws TException
     {
       oprot_.writeMessageBegin(new TMessage("system_add_keyspace", TMessageType.CALL, seqid_));
       system_add_keyspace_args args = new system_add_keyspace_args();
       args.ks_def = ks_def;
       args.write(oprot_);
       oprot_.writeMessageEnd();
       oprot_.getTransport().flush();
     }
 
     public void recv_system_add_keyspace() throws InvalidRequestException, TException
     {
       TMessage msg = iprot_.readMessageBegin();
       if (msg.type == TMessageType.EXCEPTION) {
         TApplicationException x = TApplicationException.read(iprot_);
         iprot_.readMessageEnd();
         throw x;
       }
       system_add_keyspace_result result = new system_add_keyspace_result();
       result.read(iprot_);
       iprot_.readMessageEnd();
       if (result.ire != null) {
         throw result.ire;
       }
       return;
     }
 
     public void system_drop_keyspace(String keyspace) throws InvalidRequestException, TException
     {
       send_system_drop_keyspace(keyspace);
       recv_system_drop_keyspace();
     }
 
     public void send_system_drop_keyspace(String keyspace) throws TException
     {
       oprot_.writeMessageBegin(new TMessage("system_drop_keyspace", TMessageType.CALL, seqid_));
       system_drop_keyspace_args args = new system_drop_keyspace_args();
       args.keyspace = keyspace;
       args.write(oprot_);
       oprot_.writeMessageEnd();
       oprot_.getTransport().flush();
     }
 
     public void recv_system_drop_keyspace() throws InvalidRequestException, TException
     {
       TMessage msg = iprot_.readMessageBegin();
       if (msg.type == TMessageType.EXCEPTION) {
         TApplicationException x = TApplicationException.read(iprot_);
         iprot_.readMessageEnd();
         throw x;
       }
       system_drop_keyspace_result result = new system_drop_keyspace_result();
       result.read(iprot_);
       iprot_.readMessageEnd();
       if (result.ire != null) {
         throw result.ire;
       }
       return;
     }
 
     public void system_rename_keyspace(String old_name, String new_name) throws InvalidRequestException, TException
     {
       send_system_rename_keyspace(old_name, new_name);
       recv_system_rename_keyspace();
     }
 
     public void send_system_rename_keyspace(String old_name, String new_name) throws TException
     {
       oprot_.writeMessageBegin(new TMessage("system_rename_keyspace", TMessageType.CALL, seqid_));
       system_rename_keyspace_args args = new system_rename_keyspace_args();
       args.old_name = old_name;
       args.new_name = new_name;
       args.write(oprot_);
       oprot_.writeMessageEnd();
       oprot_.getTransport().flush();
     }
 
     public void recv_system_rename_keyspace() throws InvalidRequestException, TException
     {
       TMessage msg = iprot_.readMessageBegin();
       if (msg.type == TMessageType.EXCEPTION) {
         TApplicationException x = TApplicationException.read(iprot_);
         iprot_.readMessageEnd();
         throw x;
       }
       system_rename_keyspace_result result = new system_rename_keyspace_result();
       result.read(iprot_);
       iprot_.readMessageEnd();
       if (result.ire != null) {
         throw result.ire;
       }
       return;
     }
 
   }
   public static class Processor implements TProcessor {
     private static final Logger LOGGER = LoggerFactory.getLogger(Processor.class.getName());
     public Processor(Iface iface)
     {
       iface_ = iface;
       processMap_.put("login", new login());
       processMap_.put("get", new get());
       processMap_.put("get_slice", new get_slice());
       processMap_.put("multiget", new multiget());
       processMap_.put("multiget_slice", new multiget_slice());
       processMap_.put("get_count", new get_count());
      processMap_.put("multiget_count", new multiget_count());
       processMap_.put("get_range_slice", new get_range_slice());
       processMap_.put("get_range_slices", new get_range_slices());
       processMap_.put("insert", new insert());
       processMap_.put("batch_insert", new batch_insert());
       processMap_.put("remove", new remove());
       processMap_.put("batch_mutate", new batch_mutate());
       processMap_.put("describe_keyspaces", new describe_keyspaces());
       processMap_.put("describe_cluster_name", new describe_cluster_name());
       processMap_.put("describe_version", new describe_version());
       processMap_.put("describe_ring", new describe_ring());
       processMap_.put("describe_keyspace", new describe_keyspace());
       processMap_.put("describe_splits", new describe_splits());
       processMap_.put("system_add_column_family", new system_add_column_family());
       processMap_.put("system_drop_column_family", new system_drop_column_family());
       processMap_.put("system_rename_column_family", new system_rename_column_family());
       processMap_.put("system_add_keyspace", new system_add_keyspace());
       processMap_.put("system_drop_keyspace", new system_drop_keyspace());
       processMap_.put("system_rename_keyspace", new system_rename_keyspace());
     }
 
     protected static interface ProcessFunction {
       public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException;
     }
 
     private Iface iface_;
     protected final HashMap<String,ProcessFunction> processMap_ = new HashMap<String,ProcessFunction>();
 
     public boolean process(TProtocol iprot, TProtocol oprot) throws TException
     {
       TMessage msg = iprot.readMessageBegin();
       ProcessFunction fn = processMap_.get(msg.name);
       if (fn == null) {
         TProtocolUtil.skip(iprot, TType.STRUCT);
         iprot.readMessageEnd();
         TApplicationException x = new TApplicationException(TApplicationException.UNKNOWN_METHOD, "Invalid method name: '"+msg.name+"'");
         oprot.writeMessageBegin(new TMessage(msg.name, TMessageType.EXCEPTION, msg.seqid));
         x.write(oprot);
         oprot.writeMessageEnd();
         oprot.getTransport().flush();
         return true;
       }
       fn.process(msg.seqid, iprot, oprot);
       return true;
     }
 
     private class login implements ProcessFunction {
       public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
       {
         login_args args = new login_args();
         try {
           args.read(iprot);
         } catch (TProtocolException e) {
           iprot.readMessageEnd();
           TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
           oprot.writeMessageBegin(new TMessage("login", TMessageType.EXCEPTION, seqid));
           x.write(oprot);
           oprot.writeMessageEnd();
           oprot.getTransport().flush();
           return;
         }
         iprot.readMessageEnd();
         login_result result = new login_result();
         try {
           result.success = iface_.login(args.keyspace, args.auth_request);
         } catch (AuthenticationException authnx) {
           result.authnx = authnx;
         } catch (AuthorizationException authzx) {
           result.authzx = authzx;
         } catch (Throwable th) {
           LOGGER.error("Internal error processing login", th);
           TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing login");
           oprot.writeMessageBegin(new TMessage("login", TMessageType.EXCEPTION, seqid));
           x.write(oprot);
           oprot.writeMessageEnd();
           oprot.getTransport().flush();
           return;
         }
         oprot.writeMessageBegin(new TMessage("login", TMessageType.REPLY, seqid));
         result.write(oprot);
         oprot.writeMessageEnd();
         oprot.getTransport().flush();
       }
 
     }
 
     private class get implements ProcessFunction {
       public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
       {
         get_args args = new get_args();
         try {
           args.read(iprot);
         } catch (TProtocolException e) {
           iprot.readMessageEnd();
           TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
           oprot.writeMessageBegin(new TMessage("get", TMessageType.EXCEPTION, seqid));
           x.write(oprot);
           oprot.writeMessageEnd();
           oprot.getTransport().flush();
           return;
         }
         iprot.readMessageEnd();
         get_result result = new get_result();
         try {
           result.success = iface_.get(args.keyspace, args.key, args.column_path, args.consistency_level);
         } catch (InvalidRequestException ire) {
           result.ire = ire;
         } catch (NotFoundException nfe) {
           result.nfe = nfe;
         } catch (UnavailableException ue) {
           result.ue = ue;
         } catch (TimedOutException te) {
           result.te = te;
         } catch (Throwable th) {
           LOGGER.error("Internal error processing get", th);
           TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing get");
           oprot.writeMessageBegin(new TMessage("get", TMessageType.EXCEPTION, seqid));
           x.write(oprot);
           oprot.writeMessageEnd();
           oprot.getTransport().flush();
           return;
         }
         oprot.writeMessageBegin(new TMessage("get", TMessageType.REPLY, seqid));
         result.write(oprot);
         oprot.writeMessageEnd();
         oprot.getTransport().flush();
       }
 
     }
 
     private class get_slice implements ProcessFunction {
       public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
       {
         get_slice_args args = new get_slice_args();
         try {
           args.read(iprot);
         } catch (TProtocolException e) {
           iprot.readMessageEnd();
           TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
           oprot.writeMessageBegin(new TMessage("get_slice", TMessageType.EXCEPTION, seqid));
           x.write(oprot);
           oprot.writeMessageEnd();
           oprot.getTransport().flush();
           return;
         }
         iprot.readMessageEnd();
         get_slice_result result = new get_slice_result();
         try {
           result.success = iface_.get_slice(args.keyspace, args.key, args.column_parent, args.predicate, args.consistency_level);
         } catch (InvalidRequestException ire) {
           result.ire = ire;
         } catch (UnavailableException ue) {
           result.ue = ue;
         } catch (TimedOutException te) {
           result.te = te;
         } catch (Throwable th) {
           LOGGER.error("Internal error processing get_slice", th);
           TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing get_slice");
           oprot.writeMessageBegin(new TMessage("get_slice", TMessageType.EXCEPTION, seqid));
           x.write(oprot);
           oprot.writeMessageEnd();
           oprot.getTransport().flush();
           return;
         }
         oprot.writeMessageBegin(new TMessage("get_slice", TMessageType.REPLY, seqid));
         result.write(oprot);
         oprot.writeMessageEnd();
         oprot.getTransport().flush();
       }
 
     }
 
     private class multiget implements ProcessFunction {
       public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
       {
         multiget_args args = new multiget_args();
         try {
           args.read(iprot);
         } catch (TProtocolException e) {
           iprot.readMessageEnd();
           TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
           oprot.writeMessageBegin(new TMessage("multiget", TMessageType.EXCEPTION, seqid));
           x.write(oprot);
           oprot.writeMessageEnd();
           oprot.getTransport().flush();
           return;
         }
         iprot.readMessageEnd();
         multiget_result result = new multiget_result();
         try {
           result.success = iface_.multiget(args.keyspace, args.keys, args.column_path, args.consistency_level);
         } catch (InvalidRequestException ire) {
           result.ire = ire;
         } catch (UnavailableException ue) {
           result.ue = ue;
         } catch (TimedOutException te) {
           result.te = te;
         } catch (Throwable th) {
           LOGGER.error("Internal error processing multiget", th);
           TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing multiget");
           oprot.writeMessageBegin(new TMessage("multiget", TMessageType.EXCEPTION, seqid));
           x.write(oprot);
           oprot.writeMessageEnd();
           oprot.getTransport().flush();
           return;
         }
         oprot.writeMessageBegin(new TMessage("multiget", TMessageType.REPLY, seqid));
         result.write(oprot);
         oprot.writeMessageEnd();
         oprot.getTransport().flush();
       }
 
     }
 
     private class multiget_slice implements ProcessFunction {
       public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
       {
         multiget_slice_args args = new multiget_slice_args();
         try {
           args.read(iprot);
         } catch (TProtocolException e) {
           iprot.readMessageEnd();
           TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
           oprot.writeMessageBegin(new TMessage("multiget_slice", TMessageType.EXCEPTION, seqid));
           x.write(oprot);
           oprot.writeMessageEnd();
           oprot.getTransport().flush();
           return;
         }
         iprot.readMessageEnd();
         multiget_slice_result result = new multiget_slice_result();
         try {
           result.success = iface_.multiget_slice(args.keyspace, args.keys, args.column_parent, args.predicate, args.consistency_level);
         } catch (InvalidRequestException ire) {
           result.ire = ire;
         } catch (UnavailableException ue) {
           result.ue = ue;
         } catch (TimedOutException te) {
           result.te = te;
         } catch (Throwable th) {
           LOGGER.error("Internal error processing multiget_slice", th);
           TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing multiget_slice");
           oprot.writeMessageBegin(new TMessage("multiget_slice", TMessageType.EXCEPTION, seqid));
           x.write(oprot);
           oprot.writeMessageEnd();
           oprot.getTransport().flush();
           return;
         }
         oprot.writeMessageBegin(new TMessage("multiget_slice", TMessageType.REPLY, seqid));
         result.write(oprot);
         oprot.writeMessageEnd();
         oprot.getTransport().flush();
       }
 
     }
 
     private class get_count implements ProcessFunction {
       public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
       {
         get_count_args args = new get_count_args();
         try {
           args.read(iprot);
         } catch (TProtocolException e) {
           iprot.readMessageEnd();
           TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
           oprot.writeMessageBegin(new TMessage("get_count", TMessageType.EXCEPTION, seqid));
           x.write(oprot);
           oprot.writeMessageEnd();
           oprot.getTransport().flush();
           return;
         }
         iprot.readMessageEnd();
         get_count_result result = new get_count_result();
         try {
          result.success = iface_.get_count(args.keyspace, args.key, args.column_parent, args.predicate, args.consistency_level);
           result.setSuccessIsSet(true);
         } catch (InvalidRequestException ire) {
           result.ire = ire;
         } catch (UnavailableException ue) {
           result.ue = ue;
         } catch (TimedOutException te) {
           result.te = te;
         } catch (Throwable th) {
           LOGGER.error("Internal error processing get_count", th);
           TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing get_count");
           oprot.writeMessageBegin(new TMessage("get_count", TMessageType.EXCEPTION, seqid));
           x.write(oprot);
           oprot.writeMessageEnd();
           oprot.getTransport().flush();
           return;
         }
         oprot.writeMessageBegin(new TMessage("get_count", TMessageType.REPLY, seqid));
         result.write(oprot);
         oprot.writeMessageEnd();
         oprot.getTransport().flush();
       }
 
     }
 
    private class multiget_count implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        multiget_count_args args = new multiget_count_args();
        try {
          args.read(iprot);
        } catch (TProtocolException e) {
          iprot.readMessageEnd();
          TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
          oprot.writeMessageBegin(new TMessage("multiget_count", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        iprot.readMessageEnd();
        multiget_count_result result = new multiget_count_result();
        try {
          result.success = iface_.multiget_count(args.keyspace, args.keys, args.column_parent, args.predicate, args.consistency_level);
        } catch (InvalidRequestException ire) {
          result.ire = ire;
        } catch (UnavailableException ue) {
          result.ue = ue;
        } catch (TimedOutException te) {
          result.te = te;
        } catch (Throwable th) {
          LOGGER.error("Internal error processing multiget_count", th);
          TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing multiget_count");
          oprot.writeMessageBegin(new TMessage("multiget_count", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("multiget_count", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

     private class get_range_slice implements ProcessFunction {
       public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
       {
         get_range_slice_args args = new get_range_slice_args();
         try {
           args.read(iprot);
         } catch (TProtocolException e) {
           iprot.readMessageEnd();
           TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
           oprot.writeMessageBegin(new TMessage("get_range_slice", TMessageType.EXCEPTION, seqid));
           x.write(oprot);
           oprot.writeMessageEnd();
           oprot.getTransport().flush();
           return;
         }
         iprot.readMessageEnd();
         get_range_slice_result result = new get_range_slice_result();
         try {
           result.success = iface_.get_range_slice(args.keyspace, args.column_parent, args.predicate, args.start_key, args.finish_key, args.row_count, args.consistency_level);
         } catch (InvalidRequestException ire) {
           result.ire = ire;
         } catch (UnavailableException ue) {
           result.ue = ue;
         } catch (TimedOutException te) {
           result.te = te;
         } catch (Throwable th) {
           LOGGER.error("Internal error processing get_range_slice", th);
           TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing get_range_slice");
           oprot.writeMessageBegin(new TMessage("get_range_slice", TMessageType.EXCEPTION, seqid));
           x.write(oprot);
           oprot.writeMessageEnd();
           oprot.getTransport().flush();
           return;
         }
         oprot.writeMessageBegin(new TMessage("get_range_slice", TMessageType.REPLY, seqid));
         result.write(oprot);
         oprot.writeMessageEnd();
         oprot.getTransport().flush();
       }
 
     }
 
     private class get_range_slices implements ProcessFunction {
       public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
       {
         get_range_slices_args args = new get_range_slices_args();
         try {
           args.read(iprot);
         } catch (TProtocolException e) {
           iprot.readMessageEnd();
           TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
           oprot.writeMessageBegin(new TMessage("get_range_slices", TMessageType.EXCEPTION, seqid));
           x.write(oprot);
           oprot.writeMessageEnd();
           oprot.getTransport().flush();
           return;
         }
         iprot.readMessageEnd();
         get_range_slices_result result = new get_range_slices_result();
         try {
           result.success = iface_.get_range_slices(args.keyspace, args.column_parent, args.predicate, args.range, args.consistency_level);
         } catch (InvalidRequestException ire) {
           result.ire = ire;
         } catch (UnavailableException ue) {
           result.ue = ue;
         } catch (TimedOutException te) {
           result.te = te;
         } catch (Throwable th) {
           LOGGER.error("Internal error processing get_range_slices", th);
           TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing get_range_slices");
           oprot.writeMessageBegin(new TMessage("get_range_slices", TMessageType.EXCEPTION, seqid));
           x.write(oprot);
           oprot.writeMessageEnd();
           oprot.getTransport().flush();
           return;
         }
         oprot.writeMessageBegin(new TMessage("get_range_slices", TMessageType.REPLY, seqid));
         result.write(oprot);
         oprot.writeMessageEnd();
         oprot.getTransport().flush();
       }
 
     }
 
     private class insert implements ProcessFunction {
       public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
       {
         insert_args args = new insert_args();
         try {
           args.read(iprot);
         } catch (TProtocolException e) {
           iprot.readMessageEnd();
           TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
           oprot.writeMessageBegin(new TMessage("insert", TMessageType.EXCEPTION, seqid));
           x.write(oprot);
           oprot.writeMessageEnd();
           oprot.getTransport().flush();
           return;
         }
         iprot.readMessageEnd();
         insert_result result = new insert_result();
         try {
           iface_.insert(args.keyspace, args.key, args.column_parent, args.column, args.consistency_level);
         } catch (InvalidRequestException ire) {
           result.ire = ire;
         } catch (UnavailableException ue) {
           result.ue = ue;
         } catch (TimedOutException te) {
           result.te = te;
         } catch (Throwable th) {
           LOGGER.error("Internal error processing insert", th);
           TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing insert");
           oprot.writeMessageBegin(new TMessage("insert", TMessageType.EXCEPTION, seqid));
           x.write(oprot);
           oprot.writeMessageEnd();
           oprot.getTransport().flush();
           return;
         }
         oprot.writeMessageBegin(new TMessage("insert", TMessageType.REPLY, seqid));
         result.write(oprot);
         oprot.writeMessageEnd();
         oprot.getTransport().flush();
       }
 
     }
 
     private class batch_insert implements ProcessFunction {
       public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
       {
         batch_insert_args args = new batch_insert_args();
         try {
           args.read(iprot);
         } catch (TProtocolException e) {
           iprot.readMessageEnd();
           TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
           oprot.writeMessageBegin(new TMessage("batch_insert", TMessageType.EXCEPTION, seqid));
           x.write(oprot);
           oprot.writeMessageEnd();
           oprot.getTransport().flush();
           return;
         }
         iprot.readMessageEnd();
         batch_insert_result result = new batch_insert_result();
         try {
           iface_.batch_insert(args.keyspace, args.key, args.cfmap, args.consistency_level);
         } catch (InvalidRequestException ire) {
           result.ire = ire;
         } catch (UnavailableException ue) {
           result.ue = ue;
         } catch (TimedOutException te) {
           result.te = te;
         } catch (Throwable th) {
           LOGGER.error("Internal error processing batch_insert", th);
           TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing batch_insert");
           oprot.writeMessageBegin(new TMessage("batch_insert", TMessageType.EXCEPTION, seqid));
           x.write(oprot);
           oprot.writeMessageEnd();
           oprot.getTransport().flush();
           return;
         }
         oprot.writeMessageBegin(new TMessage("batch_insert", TMessageType.REPLY, seqid));
         result.write(oprot);
         oprot.writeMessageEnd();
         oprot.getTransport().flush();
       }
 
     }
 
     private class remove implements ProcessFunction {
       public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
       {
         remove_args args = new remove_args();
         try {
           args.read(iprot);
         } catch (TProtocolException e) {
           iprot.readMessageEnd();
           TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
           oprot.writeMessageBegin(new TMessage("remove", TMessageType.EXCEPTION, seqid));
           x.write(oprot);
           oprot.writeMessageEnd();
           oprot.getTransport().flush();
           return;
         }
         iprot.readMessageEnd();
         remove_result result = new remove_result();
         try {
           iface_.remove(args.keyspace, args.key, args.column_path, args.timestamp, args.consistency_level);
         } catch (InvalidRequestException ire) {
           result.ire = ire;
         } catch (UnavailableException ue) {
           result.ue = ue;
         } catch (TimedOutException te) {
           result.te = te;
         } catch (Throwable th) {
           LOGGER.error("Internal error processing remove", th);
           TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing remove");
           oprot.writeMessageBegin(new TMessage("remove", TMessageType.EXCEPTION, seqid));
           x.write(oprot);
           oprot.writeMessageEnd();
           oprot.getTransport().flush();
           return;
         }
         oprot.writeMessageBegin(new TMessage("remove", TMessageType.REPLY, seqid));
         result.write(oprot);
         oprot.writeMessageEnd();
         oprot.getTransport().flush();
       }
 
     }
 
     private class batch_mutate implements ProcessFunction {
       public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
       {
         batch_mutate_args args = new batch_mutate_args();
         try {
           args.read(iprot);
         } catch (TProtocolException e) {
           iprot.readMessageEnd();
           TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
           oprot.writeMessageBegin(new TMessage("batch_mutate", TMessageType.EXCEPTION, seqid));
           x.write(oprot);
           oprot.writeMessageEnd();
           oprot.getTransport().flush();
           return;
         }
         iprot.readMessageEnd();
         batch_mutate_result result = new batch_mutate_result();
         try {
           iface_.batch_mutate(args.keyspace, args.mutation_map, args.consistency_level);
         } catch (InvalidRequestException ire) {
           result.ire = ire;
         } catch (UnavailableException ue) {
           result.ue = ue;
         } catch (TimedOutException te) {
           result.te = te;
         } catch (Throwable th) {
           LOGGER.error("Internal error processing batch_mutate", th);
           TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing batch_mutate");
           oprot.writeMessageBegin(new TMessage("batch_mutate", TMessageType.EXCEPTION, seqid));
           x.write(oprot);
           oprot.writeMessageEnd();
           oprot.getTransport().flush();
           return;
         }
         oprot.writeMessageBegin(new TMessage("batch_mutate", TMessageType.REPLY, seqid));
         result.write(oprot);
         oprot.writeMessageEnd();
         oprot.getTransport().flush();
       }
 
     }
 
     private class describe_keyspaces implements ProcessFunction {
       public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
       {
         describe_keyspaces_args args = new describe_keyspaces_args();
         try {
           args.read(iprot);
         } catch (TProtocolException e) {
           iprot.readMessageEnd();
           TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
           oprot.writeMessageBegin(new TMessage("describe_keyspaces", TMessageType.EXCEPTION, seqid));
           x.write(oprot);
           oprot.writeMessageEnd();
           oprot.getTransport().flush();
           return;
         }
         iprot.readMessageEnd();
         describe_keyspaces_result result = new describe_keyspaces_result();
         result.success = iface_.describe_keyspaces();
         oprot.writeMessageBegin(new TMessage("describe_keyspaces", TMessageType.REPLY, seqid));
         result.write(oprot);
         oprot.writeMessageEnd();
         oprot.getTransport().flush();
       }
 
     }
 
     private class describe_cluster_name implements ProcessFunction {
       public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
       {
         describe_cluster_name_args args = new describe_cluster_name_args();
         try {
           args.read(iprot);
         } catch (TProtocolException e) {
           iprot.readMessageEnd();
           TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
           oprot.writeMessageBegin(new TMessage("describe_cluster_name", TMessageType.EXCEPTION, seqid));
           x.write(oprot);
           oprot.writeMessageEnd();
           oprot.getTransport().flush();
           return;
         }
         iprot.readMessageEnd();
         describe_cluster_name_result result = new describe_cluster_name_result();
         result.success = iface_.describe_cluster_name();
         oprot.writeMessageBegin(new TMessage("describe_cluster_name", TMessageType.REPLY, seqid));
         result.write(oprot);
         oprot.writeMessageEnd();
         oprot.getTransport().flush();
       }
 
     }
 
     private class describe_version implements ProcessFunction {
       public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
       {
         describe_version_args args = new describe_version_args();
         try {
           args.read(iprot);
         } catch (TProtocolException e) {
           iprot.readMessageEnd();
           TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
           oprot.writeMessageBegin(new TMessage("describe_version", TMessageType.EXCEPTION, seqid));
           x.write(oprot);
           oprot.writeMessageEnd();
           oprot.getTransport().flush();
           return;
         }
         iprot.readMessageEnd();
         describe_version_result result = new describe_version_result();
         result.success = iface_.describe_version();
         oprot.writeMessageBegin(new TMessage("describe_version", TMessageType.REPLY, seqid));
         result.write(oprot);
         oprot.writeMessageEnd();
         oprot.getTransport().flush();
       }
 
     }
 
     private class describe_ring implements ProcessFunction {
       public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
       {
         describe_ring_args args = new describe_ring_args();
         try {
           args.read(iprot);
         } catch (TProtocolException e) {
           iprot.readMessageEnd();
           TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
           oprot.writeMessageBegin(new TMessage("describe_ring", TMessageType.EXCEPTION, seqid));
           x.write(oprot);
           oprot.writeMessageEnd();
           oprot.getTransport().flush();
           return;
         }
         iprot.readMessageEnd();
         describe_ring_result result = new describe_ring_result();
         result.success = iface_.describe_ring(args.keyspace);
         oprot.writeMessageBegin(new TMessage("describe_ring", TMessageType.REPLY, seqid));
         result.write(oprot);
         oprot.writeMessageEnd();
         oprot.getTransport().flush();
       }
 
     }
 
     private class describe_keyspace implements ProcessFunction {
       public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
       {
         describe_keyspace_args args = new describe_keyspace_args();
         try {
           args.read(iprot);
         } catch (TProtocolException e) {
           iprot.readMessageEnd();
           TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
           oprot.writeMessageBegin(new TMessage("describe_keyspace", TMessageType.EXCEPTION, seqid));
           x.write(oprot);
           oprot.writeMessageEnd();
           oprot.getTransport().flush();
           return;
         }
         iprot.readMessageEnd();
         describe_keyspace_result result = new describe_keyspace_result();
         try {
           result.success = iface_.describe_keyspace(args.keyspace);
         } catch (NotFoundException nfe) {
           result.nfe = nfe;
         } catch (Throwable th) {
           LOGGER.error("Internal error processing describe_keyspace", th);
           TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing describe_keyspace");
           oprot.writeMessageBegin(new TMessage("describe_keyspace", TMessageType.EXCEPTION, seqid));
           x.write(oprot);
           oprot.writeMessageEnd();
           oprot.getTransport().flush();
           return;
         }
         oprot.writeMessageBegin(new TMessage("describe_keyspace", TMessageType.REPLY, seqid));
         result.write(oprot);
         oprot.writeMessageEnd();
         oprot.getTransport().flush();
       }
 
     }
 
     private class describe_splits implements ProcessFunction {
       public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
       {
         describe_splits_args args = new describe_splits_args();
         try {
           args.read(iprot);
         } catch (TProtocolException e) {
           iprot.readMessageEnd();
           TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
           oprot.writeMessageBegin(new TMessage("describe_splits", TMessageType.EXCEPTION, seqid));
           x.write(oprot);
           oprot.writeMessageEnd();
           oprot.getTransport().flush();
           return;
         }
         iprot.readMessageEnd();
         describe_splits_result result = new describe_splits_result();
         result.success = iface_.describe_splits(args.start_token, args.end_token, args.keys_per_split);
         oprot.writeMessageBegin(new TMessage("describe_splits", TMessageType.REPLY, seqid));
         result.write(oprot);
         oprot.writeMessageEnd();
         oprot.getTransport().flush();
       }
 
     }
 
     private class system_add_column_family implements ProcessFunction {
       public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
       {
         system_add_column_family_args args = new system_add_column_family_args();
         try {
           args.read(iprot);
         } catch (TProtocolException e) {
           iprot.readMessageEnd();
           TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
           oprot.writeMessageBegin(new TMessage("system_add_column_family", TMessageType.EXCEPTION, seqid));
           x.write(oprot);
           oprot.writeMessageEnd();
           oprot.getTransport().flush();
           return;
         }
         iprot.readMessageEnd();
         system_add_column_family_result result = new system_add_column_family_result();
         try {
           iface_.system_add_column_family(args.cf_def);
         } catch (InvalidRequestException ire) {
           result.ire = ire;
         } catch (Throwable th) {
           LOGGER.error("Internal error processing system_add_column_family", th);
           TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing system_add_column_family");
           oprot.writeMessageBegin(new TMessage("system_add_column_family", TMessageType.EXCEPTION, seqid));
           x.write(oprot);
           oprot.writeMessageEnd();
           oprot.getTransport().flush();
           return;
         }
         oprot.writeMessageBegin(new TMessage("system_add_column_family", TMessageType.REPLY, seqid));
         result.write(oprot);
         oprot.writeMessageEnd();
         oprot.getTransport().flush();
       }
 
     }
 
     private class system_drop_column_family implements ProcessFunction {
       public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
       {
         system_drop_column_family_args args = new system_drop_column_family_args();
         try {
           args.read(iprot);
         } catch (TProtocolException e) {
           iprot.readMessageEnd();
           TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
           oprot.writeMessageBegin(new TMessage("system_drop_column_family", TMessageType.EXCEPTION, seqid));
           x.write(oprot);
           oprot.writeMessageEnd();
           oprot.getTransport().flush();
           return;
         }
         iprot.readMessageEnd();
         system_drop_column_family_result result = new system_drop_column_family_result();
         try {
           iface_.system_drop_column_family(args.keyspace, args.column_family);
         } catch (InvalidRequestException ire) {
           result.ire = ire;
         } catch (Throwable th) {
           LOGGER.error("Internal error processing system_drop_column_family", th);
           TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing system_drop_column_family");
           oprot.writeMessageBegin(new TMessage("system_drop_column_family", TMessageType.EXCEPTION, seqid));
           x.write(oprot);
           oprot.writeMessageEnd();
           oprot.getTransport().flush();
           return;
         }
         oprot.writeMessageBegin(new TMessage("system_drop_column_family", TMessageType.REPLY, seqid));
         result.write(oprot);
         oprot.writeMessageEnd();
         oprot.getTransport().flush();
       }
 
     }
 
     private class system_rename_column_family implements ProcessFunction {
       public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
       {
         system_rename_column_family_args args = new system_rename_column_family_args();
         try {
           args.read(iprot);
         } catch (TProtocolException e) {
           iprot.readMessageEnd();
           TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
           oprot.writeMessageBegin(new TMessage("system_rename_column_family", TMessageType.EXCEPTION, seqid));
           x.write(oprot);
           oprot.writeMessageEnd();
           oprot.getTransport().flush();
           return;
         }
         iprot.readMessageEnd();
         system_rename_column_family_result result = new system_rename_column_family_result();
         try {
           iface_.system_rename_column_family(args.keyspace, args.old_name, args.new_name);
         } catch (InvalidRequestException ire) {
           result.ire = ire;
         } catch (Throwable th) {
           LOGGER.error("Internal error processing system_rename_column_family", th);
           TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing system_rename_column_family");
           oprot.writeMessageBegin(new TMessage("system_rename_column_family", TMessageType.EXCEPTION, seqid));
           x.write(oprot);
           oprot.writeMessageEnd();
           oprot.getTransport().flush();
           return;
         }
         oprot.writeMessageBegin(new TMessage("system_rename_column_family", TMessageType.REPLY, seqid));
         result.write(oprot);
         oprot.writeMessageEnd();
         oprot.getTransport().flush();
       }
 
     }
 
     private class system_add_keyspace implements ProcessFunction {
       public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
       {
         system_add_keyspace_args args = new system_add_keyspace_args();
         try {
           args.read(iprot);
         } catch (TProtocolException e) {
           iprot.readMessageEnd();
           TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
           oprot.writeMessageBegin(new TMessage("system_add_keyspace", TMessageType.EXCEPTION, seqid));
           x.write(oprot);
           oprot.writeMessageEnd();
           oprot.getTransport().flush();
           return;
         }
         iprot.readMessageEnd();
         system_add_keyspace_result result = new system_add_keyspace_result();
         try {
           iface_.system_add_keyspace(args.ks_def);
         } catch (InvalidRequestException ire) {
           result.ire = ire;
         } catch (Throwable th) {
           LOGGER.error("Internal error processing system_add_keyspace", th);
           TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing system_add_keyspace");
           oprot.writeMessageBegin(new TMessage("system_add_keyspace", TMessageType.EXCEPTION, seqid));
           x.write(oprot);
           oprot.writeMessageEnd();
           oprot.getTransport().flush();
           return;
         }
         oprot.writeMessageBegin(new TMessage("system_add_keyspace", TMessageType.REPLY, seqid));
         result.write(oprot);
         oprot.writeMessageEnd();
         oprot.getTransport().flush();
       }
 
     }
 
     private class system_drop_keyspace implements ProcessFunction {
       public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
       {
         system_drop_keyspace_args args = new system_drop_keyspace_args();
         try {
           args.read(iprot);
         } catch (TProtocolException e) {
           iprot.readMessageEnd();
           TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
           oprot.writeMessageBegin(new TMessage("system_drop_keyspace", TMessageType.EXCEPTION, seqid));
           x.write(oprot);
           oprot.writeMessageEnd();
           oprot.getTransport().flush();
           return;
         }
         iprot.readMessageEnd();
         system_drop_keyspace_result result = new system_drop_keyspace_result();
         try {
           iface_.system_drop_keyspace(args.keyspace);
         } catch (InvalidRequestException ire) {
           result.ire = ire;
         } catch (Throwable th) {
           LOGGER.error("Internal error processing system_drop_keyspace", th);
           TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing system_drop_keyspace");
           oprot.writeMessageBegin(new TMessage("system_drop_keyspace", TMessageType.EXCEPTION, seqid));
           x.write(oprot);
           oprot.writeMessageEnd();
           oprot.getTransport().flush();
           return;
         }
         oprot.writeMessageBegin(new TMessage("system_drop_keyspace", TMessageType.REPLY, seqid));
         result.write(oprot);
         oprot.writeMessageEnd();
         oprot.getTransport().flush();
       }
 
     }
 
     private class system_rename_keyspace implements ProcessFunction {
       public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
       {
         system_rename_keyspace_args args = new system_rename_keyspace_args();
         try {
           args.read(iprot);
         } catch (TProtocolException e) {
           iprot.readMessageEnd();
           TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
           oprot.writeMessageBegin(new TMessage("system_rename_keyspace", TMessageType.EXCEPTION, seqid));
           x.write(oprot);
           oprot.writeMessageEnd();
           oprot.getTransport().flush();
           return;
         }
         iprot.readMessageEnd();
         system_rename_keyspace_result result = new system_rename_keyspace_result();
         try {
           iface_.system_rename_keyspace(args.old_name, args.new_name);
         } catch (InvalidRequestException ire) {
           result.ire = ire;
         } catch (Throwable th) {
           LOGGER.error("Internal error processing system_rename_keyspace", th);
           TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing system_rename_keyspace");
           oprot.writeMessageBegin(new TMessage("system_rename_keyspace", TMessageType.EXCEPTION, seqid));
           x.write(oprot);
           oprot.writeMessageEnd();
           oprot.getTransport().flush();
           return;
         }
         oprot.writeMessageBegin(new TMessage("system_rename_keyspace", TMessageType.REPLY, seqid));
         result.write(oprot);
         oprot.writeMessageEnd();
         oprot.getTransport().flush();
       }
 
     }
 
   }
 
   public static class login_args implements TBase<login_args._Fields>, java.io.Serializable, Cloneable   {
     private static final TStruct STRUCT_DESC = new TStruct("login_args");
 
     private static final TField KEYSPACE_FIELD_DESC = new TField("keyspace", TType.STRING, (short)1);
     private static final TField AUTH_REQUEST_FIELD_DESC = new TField("auth_request", TType.STRUCT, (short)2);
 
     public String keyspace;
     public AuthenticationRequest auth_request;
 
     /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
     public enum _Fields implements TFieldIdEnum {
       KEYSPACE((short)1, "keyspace"),
       AUTH_REQUEST((short)2, "auth_request");
 
       private static final Map<Integer, _Fields> byId = new HashMap<Integer, _Fields>();
       private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();
 
       static {
         for (_Fields field : EnumSet.allOf(_Fields.class)) {
           byId.put((int)field._thriftId, field);
           byName.put(field.getFieldName(), field);
         }
       }
 
       /**
        * Find the _Fields constant that matches fieldId, or null if its not found.
        */
       public static _Fields findByThriftId(int fieldId) {
         return byId.get(fieldId);
       }
 
       /**
        * Find the _Fields constant that matches fieldId, throwing an exception
        * if it is not found.
        */
       public static _Fields findByThriftIdOrThrow(int fieldId) {
         _Fields fields = findByThriftId(fieldId);
         if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
         return fields;
       }
 
       /**
        * Find the _Fields constant that matches name, or null if its not found.
        */
       public static _Fields findByName(String name) {
         return byName.get(name);
       }
 
       private final short _thriftId;
       private final String _fieldName;
 
       _Fields(short thriftId, String fieldName) {
         _thriftId = thriftId;
         _fieldName = fieldName;
       }
 
       public short getThriftFieldId() {
         return _thriftId;
       }
 
       public String getFieldName() {
         return _fieldName;
       }
     }
 
     // isset id assignments
 
     public static final Map<_Fields, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new EnumMap<_Fields, FieldMetaData>(_Fields.class) {{
       put(_Fields.KEYSPACE, new FieldMetaData("keyspace", TFieldRequirementType.REQUIRED, 
           new FieldValueMetaData(TType.STRING)));
       put(_Fields.AUTH_REQUEST, new FieldMetaData("auth_request", TFieldRequirementType.REQUIRED, 
           new StructMetaData(TType.STRUCT, AuthenticationRequest.class)));
     }});
 
     static {
       FieldMetaData.addStructMetaDataMap(login_args.class, metaDataMap);
     }
 
     public login_args() {
     }
 
     public login_args(
       String keyspace,
       AuthenticationRequest auth_request)
     {
       this();
       this.keyspace = keyspace;
       this.auth_request = auth_request;
     }
 
     /**
      * Performs a deep copy on <i>other</i>.
      */
     public login_args(login_args other) {
       if (other.isSetKeyspace()) {
         this.keyspace = other.keyspace;
       }
       if (other.isSetAuth_request()) {
         this.auth_request = new AuthenticationRequest(other.auth_request);
       }
     }
 
     public login_args deepCopy() {
       return new login_args(this);
     }
 
     @Deprecated
     public login_args clone() {
       return new login_args(this);
     }
 
     public String getKeyspace() {
       return this.keyspace;
     }
 
     public login_args setKeyspace(String keyspace) {
       this.keyspace = keyspace;
       return this;
     }
 
     public void unsetKeyspace() {
       this.keyspace = null;
     }
 
     /** Returns true if field keyspace is set (has been asigned a value) and false otherwise */
     public boolean isSetKeyspace() {
       return this.keyspace != null;
     }
 
     public void setKeyspaceIsSet(boolean value) {
       if (!value) {
         this.keyspace = null;
       }
     }
 
     public AuthenticationRequest getAuth_request() {
       return this.auth_request;
     }
 
     public login_args setAuth_request(AuthenticationRequest auth_request) {
       this.auth_request = auth_request;
       return this;
     }
 
     public void unsetAuth_request() {
       this.auth_request = null;
     }
 
     /** Returns true if field auth_request is set (has been asigned a value) and false otherwise */
     public boolean isSetAuth_request() {
       return this.auth_request != null;
     }
 
     public void setAuth_requestIsSet(boolean value) {
       if (!value) {
         this.auth_request = null;
       }
     }
 
     public void setFieldValue(_Fields field, Object value) {
       switch (field) {
       case KEYSPACE:
         if (value == null) {
           unsetKeyspace();
         } else {
           setKeyspace((String)value);
         }
         break;
 
       case AUTH_REQUEST:
         if (value == null) {
           unsetAuth_request();
         } else {
           setAuth_request((AuthenticationRequest)value);
         }
         break;
 
       }
     }
 
     public void setFieldValue(int fieldID, Object value) {
       setFieldValue(_Fields.findByThriftIdOrThrow(fieldID), value);
     }
 
     public Object getFieldValue(_Fields field) {
       switch (field) {
       case KEYSPACE:
         return getKeyspace();
 
       case AUTH_REQUEST:
         return getAuth_request();
 
       }
       throw new IllegalStateException();
     }
 
     public Object getFieldValue(int fieldId) {
       return getFieldValue(_Fields.findByThriftIdOrThrow(fieldId));
     }
 
     /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
     public boolean isSet(_Fields field) {
       switch (field) {
       case KEYSPACE:
         return isSetKeyspace();
       case AUTH_REQUEST:
         return isSetAuth_request();
       }
       throw new IllegalStateException();
     }
 
     public boolean isSet(int fieldID) {
       return isSet(_Fields.findByThriftIdOrThrow(fieldID));
     }
 
     @Override
     public boolean equals(Object that) {
       if (that == null)
         return false;
       if (that instanceof login_args)
         return this.equals((login_args)that);
       return false;
     }
 
     public boolean equals(login_args that) {
       if (that == null)
         return false;
 
       boolean this_present_keyspace = true && this.isSetKeyspace();
       boolean that_present_keyspace = true && that.isSetKeyspace();
       if (this_present_keyspace || that_present_keyspace) {
         if (!(this_present_keyspace && that_present_keyspace))
           return false;
         if (!this.keyspace.equals(that.keyspace))
           return false;
       }
 
       boolean this_present_auth_request = true && this.isSetAuth_request();
       boolean that_present_auth_request = true && that.isSetAuth_request();
       if (this_present_auth_request || that_present_auth_request) {
         if (!(this_present_auth_request && that_present_auth_request))
           return false;
         if (!this.auth_request.equals(that.auth_request))
           return false;
       }
 
       return true;
     }
 
     @Override
     public int hashCode() {
       return 0;
     }
 
     public void read(TProtocol iprot) throws TException {
       TField field;
       iprot.readStructBegin();
       while (true)
       {
         field = iprot.readFieldBegin();
         if (field.type == TType.STOP) { 
           break;
         }
         switch (field.id) {
           case 1: // KEYSPACE
             if (field.type == TType.STRING) {
               this.keyspace = iprot.readString();
             } else { 
               TProtocolUtil.skip(iprot, field.type);
             }
             break;
           case 2: // AUTH_REQUEST
             if (field.type == TType.STRUCT) {
               this.auth_request = new AuthenticationRequest();
               this.auth_request.read(iprot);
             } else { 
               TProtocolUtil.skip(iprot, field.type);
             }
             break;
           default:
             TProtocolUtil.skip(iprot, field.type);
         }
         iprot.readFieldEnd();
       }
       iprot.readStructEnd();
 
       // check for required fields of primitive type, which can't be checked in the validate method
       validate();
     }
 
     public void write(TProtocol oprot) throws TException {
       validate();
 
       oprot.writeStructBegin(STRUCT_DESC);
       if (this.keyspace != null) {
         oprot.writeFieldBegin(KEYSPACE_FIELD_DESC);
         oprot.writeString(this.keyspace);
         oprot.writeFieldEnd();
       }
       if (this.auth_request != null) {
         oprot.writeFieldBegin(AUTH_REQUEST_FIELD_DESC);
         this.auth_request.write(oprot);
         oprot.writeFieldEnd();
       }
       oprot.writeFieldStop();
       oprot.writeStructEnd();
     }
 
     @Override
     public String toString() {
       StringBuilder sb = new StringBuilder("login_args(");
       boolean first = true;
 
       sb.append("keyspace:");
       if (this.keyspace == null) {
         sb.append("null");
       } else {
         sb.append(this.keyspace);
       }
       first = false;
       if (!first) sb.append(", ");
       sb.append("auth_request:");
       if (this.auth_request == null) {
         sb.append("null");
       } else {
         sb.append(this.auth_request);
       }
       first = false;
       sb.append(")");
       return sb.toString();
     }
 
     public void validate() throws TException {
       // check for required fields
       if (keyspace == null) {
         throw new TProtocolException("Required field 'keyspace' was not present! Struct: " + toString());
       }
       if (auth_request == null) {
         throw new TProtocolException("Required field 'auth_request' was not present! Struct: " + toString());
       }
     }
 
   }
 
   public static class login_result implements TBase<login_result._Fields>, java.io.Serializable, Cloneable, Comparable<login_result>   {
     private static final TStruct STRUCT_DESC = new TStruct("login_result");
 
     private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.I32, (short)0);
     private static final TField AUTHNX_FIELD_DESC = new TField("authnx", TType.STRUCT, (short)1);
     private static final TField AUTHZX_FIELD_DESC = new TField("authzx", TType.STRUCT, (short)2);
 
     /**
      * 
      * @see AccessLevel
      */
     public AccessLevel success;
     public AuthenticationException authnx;
     public AuthorizationException authzx;
 
     /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
     public enum _Fields implements TFieldIdEnum {
       /**
        * 
        * @see AccessLevel
        */
       SUCCESS((short)0, "success"),
       AUTHNX((short)1, "authnx"),
       AUTHZX((short)2, "authzx");
 
       private static final Map<Integer, _Fields> byId = new HashMap<Integer, _Fields>();
       private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();
 
       static {
         for (_Fields field : EnumSet.allOf(_Fields.class)) {
           byId.put((int)field._thriftId, field);
           byName.put(field.getFieldName(), field);
         }
       }
 
       /**
        * Find the _Fields constant that matches fieldId, or null if its not found.
        */
       public static _Fields findByThriftId(int fieldId) {
         return byId.get(fieldId);
       }
 
       /**
        * Find the _Fields constant that matches fieldId, throwing an exception
        * if it is not found.
        */
       public static _Fields findByThriftIdOrThrow(int fieldId) {
         _Fields fields = findByThriftId(fieldId);
         if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
         return fields;
       }
 
       /**
        * Find the _Fields constant that matches name, or null if its not found.
        */
       public static _Fields findByName(String name) {
         return byName.get(name);
       }
 
       private final short _thriftId;
       private final String _fieldName;
 
       _Fields(short thriftId, String fieldName) {
         _thriftId = thriftId;
         _fieldName = fieldName;
       }
 
       public short getThriftFieldId() {
         return _thriftId;
       }
 
       public String getFieldName() {
         return _fieldName;
       }
     }
 
     // isset id assignments
 
     public static final Map<_Fields, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new EnumMap<_Fields, FieldMetaData>(_Fields.class) {{
       put(_Fields.SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
           new EnumMetaData(TType.ENUM, AccessLevel.class)));
       put(_Fields.AUTHNX, new FieldMetaData("authnx", TFieldRequirementType.DEFAULT, 
           new FieldValueMetaData(TType.STRUCT)));
       put(_Fields.AUTHZX, new FieldMetaData("authzx", TFieldRequirementType.DEFAULT, 
           new FieldValueMetaData(TType.STRUCT)));
     }});
 
     static {
       FieldMetaData.addStructMetaDataMap(login_result.class, metaDataMap);
     }
 
     public login_result() {
     }
 
     public login_result(
       AccessLevel success,
       AuthenticationException authnx,
       AuthorizationException authzx)
     {
       this();
       this.success = success;
       this.authnx = authnx;
       this.authzx = authzx;
     }
 
     /**
      * Performs a deep copy on <i>other</i>.
      */
     public login_result(login_result other) {
       if (other.isSetSuccess()) {
         this.success = other.success;
       }
       if (other.isSetAuthnx()) {
         this.authnx = new AuthenticationException(other.authnx);
       }
       if (other.isSetAuthzx()) {
         this.authzx = new AuthorizationException(other.authzx);
       }
     }
 
     public login_result deepCopy() {
       return new login_result(this);
     }
 
     @Deprecated
     public login_result clone() {
       return new login_result(this);
     }
 
     /**
      * 
      * @see AccessLevel
      */
     public AccessLevel getSuccess() {
       return this.success;
     }
 
     /**
      * 
      * @see AccessLevel
      */
     public login_result setSuccess(AccessLevel success) {
       this.success = success;
       return this;
     }
 
     public void unsetSuccess() {
       this.success = null;
     }
 
     /** Returns true if field success is set (has been asigned a value) and false otherwise */
     public boolean isSetSuccess() {
       return this.success != null;
     }
 
     public void setSuccessIsSet(boolean value) {
       if (!value) {
         this.success = null;
       }
     }
 
     public AuthenticationException getAuthnx() {
       return this.authnx;
     }
 
     public login_result setAuthnx(AuthenticationException authnx) {
       this.authnx = authnx;
       return this;
     }
 
     public void unsetAuthnx() {
       this.authnx = null;
     }
 
     /** Returns true if field authnx is set (has been asigned a value) and false otherwise */
     public boolean isSetAuthnx() {
       return this.authnx != null;
     }
 
     public void setAuthnxIsSet(boolean value) {
       if (!value) {
         this.authnx = null;
       }
     }
 
     public AuthorizationException getAuthzx() {
       return this.authzx;
     }
 
     public login_result setAuthzx(AuthorizationException authzx) {
       this.authzx = authzx;
       return this;
     }
 
     public void unsetAuthzx() {
       this.authzx = null;
     }
 
     /** Returns true if field authzx is set (has been asigned a value) and false otherwise */
     public boolean isSetAuthzx() {
       return this.authzx != null;
     }
 
     public void setAuthzxIsSet(boolean value) {
       if (!value) {
         this.authzx = null;
       }
     }
 
     public void setFieldValue(_Fields field, Object value) {
       switch (field) {
       case SUCCESS:
         if (value == null) {
           unsetSuccess();
         } else {
           setSuccess((AccessLevel)value);
         }
         break;
 
       case AUTHNX:
         if (value == null) {
           unsetAuthnx();
         } else {
           setAuthnx((AuthenticationException)value);
         }
         break;
 
       case AUTHZX:
         if (value == null) {
           unsetAuthzx();
         } else {
           setAuthzx((AuthorizationException)value);
         }
         break;
 
       }
     }
 
     public void setFieldValue(int fieldID, Object value) {
       setFieldValue(_Fields.findByThriftIdOrThrow(fieldID), value);
     }
 
     public Object getFieldValue(_Fields field) {
       switch (field) {
       case SUCCESS:
         return getSuccess();
 
       case AUTHNX:
         return getAuthnx();
 
       case AUTHZX:
         return getAuthzx();
 
       }
       throw new IllegalStateException();
     }
 
     public Object getFieldValue(int fieldId) {
       return getFieldValue(_Fields.findByThriftIdOrThrow(fieldId));
     }
 
     /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
     public boolean isSet(_Fields field) {
       switch (field) {
       case SUCCESS:
         return isSetSuccess();
       case AUTHNX:
         return isSetAuthnx();
       case AUTHZX:
         return isSetAuthzx();
       }
       throw new IllegalStateException();
     }
 
     public boolean isSet(int fieldID) {
       return isSet(_Fields.findByThriftIdOrThrow(fieldID));
     }
 
     @Override
     public boolean equals(Object that) {
       if (that == null)
         return false;
       if (that instanceof login_result)
         return this.equals((login_result)that);
       return false;
     }
 
     public boolean equals(login_result that) {
       if (that == null)
         return false;
 
       boolean this_present_success = true && this.isSetSuccess();
       boolean that_present_success = true && that.isSetSuccess();
       if (this_present_success || that_present_success) {
         if (!(this_present_success && that_present_success))
           return false;
         if (!this.success.equals(that.success))
           return false;
       }
 
       boolean this_present_authnx = true && this.isSetAuthnx();
       boolean that_present_authnx = true && that.isSetAuthnx();
       if (this_present_authnx || that_present_authnx) {
         if (!(this_present_authnx && that_present_authnx))
           return false;
         if (!this.authnx.equals(that.authnx))
           return false;
       }
 
       boolean this_present_authzx = true && this.isSetAuthzx();
       boolean that_present_authzx = true && that.isSetAuthzx();
       if (this_present_authzx || that_present_authzx) {
         if (!(this_present_authzx && that_present_authzx))
           return false;
         if (!this.authzx.equals(that.authzx))
           return false;
       }
 
       return true;
     }
 
     @Override
     public int hashCode() {
       return 0;
     }
 
     public int compareTo(login_result other) {
       if (!getClass().equals(other.getClass())) {
         return getClass().getName().compareTo(other.getClass().getName());
       }
 
       int lastComparison = 0;
       login_result typedOther = (login_result)other;
 
       lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(typedOther.isSetSuccess());
       if (lastComparison != 0) {
         return lastComparison;
       }
       if (isSetSuccess()) {        lastComparison = TBaseHelper.compareTo(success, typedOther.success);
         if (lastComparison != 0) {
           return lastComparison;
         }
       }
       lastComparison = Boolean.valueOf(isSetAuthnx()).compareTo(typedOther.isSetAuthnx());
       if (lastComparison != 0) {
         return lastComparison;
       }
       if (isSetAuthnx()) {        lastComparison = TBaseHelper.compareTo(authnx, typedOther.authnx);
         if (lastComparison != 0) {
           return lastComparison;
         }
       }
       lastComparison = Boolean.valueOf(isSetAuthzx()).compareTo(typedOther.isSetAuthzx());
       if (lastComparison != 0) {
         return lastComparison;
       }
       if (isSetAuthzx()) {        lastComparison = TBaseHelper.compareTo(authzx, typedOther.authzx);
         if (lastComparison != 0) {
           return lastComparison;
         }
       }
       return 0;
     }
 
     public void read(TProtocol iprot) throws TException {
       TField field;
       iprot.readStructBegin();
       while (true)
       {
         field = iprot.readFieldBegin();
         if (field.type == TType.STOP) { 
           break;
         }
         switch (field.id) {
           case 0: // SUCCESS
             if (field.type == TType.I32) {
               this.success = AccessLevel.findByValue(iprot.readI32());
             } else { 
               TProtocolUtil.skip(iprot, field.type);
             }
             break;
           case 1: // AUTHNX
             if (field.type == TType.STRUCT) {
               this.authnx = new AuthenticationException();
               this.authnx.read(iprot);
             } else { 
               TProtocolUtil.skip(iprot, field.type);
             }
             break;
           case 2: // AUTHZX
             if (field.type == TType.STRUCT) {
               this.authzx = new AuthorizationException();
               this.authzx.read(iprot);
             } else { 
               TProtocolUtil.skip(iprot, field.type);
             }
             break;
           default:
             TProtocolUtil.skip(iprot, field.type);
         }
         iprot.readFieldEnd();
       }
       iprot.readStructEnd();
 
       // check for required fields of primitive type, which can't be checked in the validate method
       validate();
     }
 
     public void write(TProtocol oprot) throws TException {
       oprot.writeStructBegin(STRUCT_DESC);
 
       if (this.isSetSuccess()) {
         oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
         oprot.writeI32(this.success.getValue());
         oprot.writeFieldEnd();
       } else if (this.isSetAuthnx()) {
         oprot.writeFieldBegin(AUTHNX_FIELD_DESC);
         this.authnx.write(oprot);
         oprot.writeFieldEnd();
       } else if (this.isSetAuthzx()) {
         oprot.writeFieldBegin(AUTHZX_FIELD_DESC);
         this.authzx.write(oprot);
         oprot.writeFieldEnd();
       }
       oprot.writeFieldStop();
       oprot.writeStructEnd();
     }
 
     @Override
     public String toString() {
       StringBuilder sb = new StringBuilder("login_result(");
       boolean first = true;
 
       sb.append("success:");
       if (this.success == null) {
         sb.append("null");
       } else {
         sb.append(this.success);
       }
       first = false;
       if (!first) sb.append(", ");
       sb.append("authnx:");
       if (this.authnx == null) {
         sb.append("null");
       } else {
         sb.append(this.authnx);
       }
       first = false;
       if (!first) sb.append(", ");
       sb.append("authzx:");
       if (this.authzx == null) {
         sb.append("null");
       } else {
         sb.append(this.authzx);
       }
       first = false;
       sb.append(")");
       return sb.toString();
     }
 
     public void validate() throws TException {
       // check for required fields
     }
 
   }
 
   public static class get_args implements TBase<get_args._Fields>, java.io.Serializable, Cloneable, Comparable<get_args>   {
     private static final TStruct STRUCT_DESC = new TStruct("get_args");
 
     private static final TField KEYSPACE_FIELD_DESC = new TField("keyspace", TType.STRING, (short)1);
     private static final TField KEY_FIELD_DESC = new TField("key", TType.STRING, (short)2);
     private static final TField COLUMN_PATH_FIELD_DESC = new TField("column_path", TType.STRUCT, (short)3);
     private static final TField CONSISTENCY_LEVEL_FIELD_DESC = new TField("consistency_level", TType.I32, (short)4);
 
     public String keyspace;
     public byte[] key;
     public ColumnPath column_path;
     /**
      * 
      * @see ConsistencyLevel
      */
     public ConsistencyLevel consistency_level;
 
     /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
     public enum _Fields implements TFieldIdEnum {
       KEYSPACE((short)1, "keyspace"),
       KEY((short)2, "key"),
       COLUMN_PATH((short)3, "column_path"),
       /**
        * 
        * @see ConsistencyLevel
        */
       CONSISTENCY_LEVEL((short)4, "consistency_level");
 
       private static final Map<Integer, _Fields> byId = new HashMap<Integer, _Fields>();
       private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();
 
       static {
         for (_Fields field : EnumSet.allOf(_Fields.class)) {
           byId.put((int)field._thriftId, field);
           byName.put(field.getFieldName(), field);
         }
       }
 
       /**
        * Find the _Fields constant that matches fieldId, or null if its not found.
        */
       public static _Fields findByThriftId(int fieldId) {
         return byId.get(fieldId);
       }
 
       /**
        * Find the _Fields constant that matches fieldId, throwing an exception
        * if it is not found.
        */
       public static _Fields findByThriftIdOrThrow(int fieldId) {
         _Fields fields = findByThriftId(fieldId);
         if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
         return fields;
       }
 
       /**
        * Find the _Fields constant that matches name, or null if its not found.
        */
       public static _Fields findByName(String name) {
         return byName.get(name);
       }
 
       private final short _thriftId;
       private final String _fieldName;
 
       _Fields(short thriftId, String fieldName) {
         _thriftId = thriftId;
         _fieldName = fieldName;
       }
 
       public short getThriftFieldId() {
         return _thriftId;
       }
 
       public String getFieldName() {
         return _fieldName;
       }
     }
 
     // isset id assignments
 
     public static final Map<_Fields, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new EnumMap<_Fields, FieldMetaData>(_Fields.class) {{
       put(_Fields.KEYSPACE, new FieldMetaData("keyspace", TFieldRequirementType.REQUIRED, 
           new FieldValueMetaData(TType.STRING)));
       put(_Fields.KEY, new FieldMetaData("key", TFieldRequirementType.REQUIRED, 
           new FieldValueMetaData(TType.STRING)));
       put(_Fields.COLUMN_PATH, new FieldMetaData("column_path", TFieldRequirementType.REQUIRED, 
           new StructMetaData(TType.STRUCT, ColumnPath.class)));
       put(_Fields.CONSISTENCY_LEVEL, new FieldMetaData("consistency_level", TFieldRequirementType.REQUIRED, 
           new EnumMetaData(TType.ENUM, ConsistencyLevel.class)));
     }});
 
     static {
       FieldMetaData.addStructMetaDataMap(get_args.class, metaDataMap);
     }
 
     public get_args() {
       this.consistency_level = ConsistencyLevel.ONE;
 
     }
 
     public get_args(
       String keyspace,
       byte[] key,
       ColumnPath column_path,
       ConsistencyLevel consistency_level)
     {
       this();
       this.keyspace = keyspace;
       this.key = key;
       this.column_path = column_path;
       this.consistency_level = consistency_level;
     }
 
     /**
      * Performs a deep copy on <i>other</i>.
      */
     public get_args(get_args other) {
       if (other.isSetKeyspace()) {
         this.keyspace = other.keyspace;
       }
       if (other.isSetKey()) {
         this.key = new byte[other.key.length];
         System.arraycopy(other.key, 0, key, 0, other.key.length);
       }
       if (other.isSetColumn_path()) {
         this.column_path = new ColumnPath(other.column_path);
       }
       if (other.isSetConsistency_level()) {
         this.consistency_level = other.consistency_level;
       }
     }
 
     public get_args deepCopy() {
       return new get_args(this);
     }
 
     @Deprecated
     public get_args clone() {
       return new get_args(this);
     }
 
     public String getKeyspace() {
       return this.keyspace;
     }
 
     public get_args setKeyspace(String keyspace) {
       this.keyspace = keyspace;
       return this;
     }
 
     public void unsetKeyspace() {
       this.keyspace = null;
     }
 
     /** Returns true if field keyspace is set (has been asigned a value) and false otherwise */
     public boolean isSetKeyspace() {
       return this.keyspace != null;
     }
 
     public void setKeyspaceIsSet(boolean value) {
       if (!value) {
         this.keyspace = null;
       }
     }
 
     public byte[] getKey() {
       return this.key;
     }
 
     public get_args setKey(byte[] key) {
       this.key = key;
       return this;
     }
 
     public void unsetKey() {
       this.key = null;
     }
 
     /** Returns true if field key is set (has been asigned a value) and false otherwise */
     public boolean isSetKey() {
       return this.key != null;
     }
 
     public void setKeyIsSet(boolean value) {
       if (!value) {
         this.key = null;
       }
     }
 
     public ColumnPath getColumn_path() {
       return this.column_path;
     }
 
     public get_args setColumn_path(ColumnPath column_path) {
       this.column_path = column_path;
       return this;
     }
 
     public void unsetColumn_path() {
       this.column_path = null;
     }
 
     /** Returns true if field column_path is set (has been asigned a value) and false otherwise */
     public boolean isSetColumn_path() {
       return this.column_path != null;
     }
 
     public void setColumn_pathIsSet(boolean value) {
       if (!value) {
         this.column_path = null;
       }
     }
 
     /**
      * 
      * @see ConsistencyLevel
      */
     public ConsistencyLevel getConsistency_level() {
       return this.consistency_level;
     }
 
     /**
      * 
      * @see ConsistencyLevel
      */
     public get_args setConsistency_level(ConsistencyLevel consistency_level) {
       this.consistency_level = consistency_level;
       return this;
     }
 
     public void unsetConsistency_level() {
       this.consistency_level = null;
     }
 
     /** Returns true if field consistency_level is set (has been asigned a value) and false otherwise */
     public boolean isSetConsistency_level() {
       return this.consistency_level != null;
     }
 
     public void setConsistency_levelIsSet(boolean value) {
       if (!value) {
         this.consistency_level = null;
       }
     }
 
     public void setFieldValue(_Fields field, Object value) {
       switch (field) {
       case KEYSPACE:
         if (value == null) {
           unsetKeyspace();
         } else {
           setKeyspace((String)value);
         }
         break;
 
       case KEY:
         if (value == null) {
           unsetKey();
         } else {
           setKey((byte[])value);
         }
         break;
 
       case COLUMN_PATH:
         if (value == null) {
           unsetColumn_path();
         } else {
           setColumn_path((ColumnPath)value);
         }
         break;
 
       case CONSISTENCY_LEVEL:
         if (value == null) {
           unsetConsistency_level();
         } else {
           setConsistency_level((ConsistencyLevel)value);
         }
         break;
 
       }
     }
 
     public void setFieldValue(int fieldID, Object value) {
       setFieldValue(_Fields.findByThriftIdOrThrow(fieldID), value);
     }
 
     public Object getFieldValue(_Fields field) {
       switch (field) {
       case KEYSPACE:
         return getKeyspace();
 
       case KEY:
         return getKey();
 
       case COLUMN_PATH:
         return getColumn_path();
 
       case CONSISTENCY_LEVEL:
         return getConsistency_level();
 
       }
       throw new IllegalStateException();
     }
 
     public Object getFieldValue(int fieldId) {
       return getFieldValue(_Fields.findByThriftIdOrThrow(fieldId));
     }
 
     /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
     public boolean isSet(_Fields field) {
       switch (field) {
       case KEYSPACE:
         return isSetKeyspace();
       case KEY:
         return isSetKey();
       case COLUMN_PATH:
         return isSetColumn_path();
       case CONSISTENCY_LEVEL:
         return isSetConsistency_level();
       }
       throw new IllegalStateException();
     }
 
     public boolean isSet(int fieldID) {
       return isSet(_Fields.findByThriftIdOrThrow(fieldID));
     }
 
     @Override
     public boolean equals(Object that) {
       if (that == null)
         return false;
       if (that instanceof get_args)
         return this.equals((get_args)that);
       return false;
     }
 
     public boolean equals(get_args that) {
       if (that == null)
         return false;
 
       boolean this_present_keyspace = true && this.isSetKeyspace();
       boolean that_present_keyspace = true && that.isSetKeyspace();
       if (this_present_keyspace || that_present_keyspace) {
         if (!(this_present_keyspace && that_present_keyspace))
           return false;
         if (!this.keyspace.equals(that.keyspace))
           return false;
       }
 
       boolean this_present_key = true && this.isSetKey();
       boolean that_present_key = true && that.isSetKey();
       if (this_present_key || that_present_key) {
         if (!(this_present_key && that_present_key))
           return false;
         if (!java.util.Arrays.equals(this.key, that.key))
           return false;
       }
 
       boolean this_present_column_path = true && this.isSetColumn_path();
       boolean that_present_column_path = true && that.isSetColumn_path();
       if (this_present_column_path || that_present_column_path) {
         if (!(this_present_column_path && that_present_column_path))
           return false;
         if (!this.column_path.equals(that.column_path))
           return false;
       }
 
       boolean this_present_consistency_level = true && this.isSetConsistency_level();
       boolean that_present_consistency_level = true && that.isSetConsistency_level();
       if (this_present_consistency_level || that_present_consistency_level) {
         if (!(this_present_consistency_level && that_present_consistency_level))
           return false;
         if (!this.consistency_level.equals(that.consistency_level))
           return false;
       }
 
       return true;
     }
 
     @Override
     public int hashCode() {
       return 0;
     }
 
     public int compareTo(get_args other) {
       if (!getClass().equals(other.getClass())) {
         return getClass().getName().compareTo(other.getClass().getName());
       }
 
       int lastComparison = 0;
       get_args typedOther = (get_args)other;
 
       lastComparison = Boolean.valueOf(isSetKeyspace()).compareTo(typedOther.isSetKeyspace());
       if (lastComparison != 0) {
         return lastComparison;
       }
       if (isSetKeyspace()) {        lastComparison = TBaseHelper.compareTo(keyspace, typedOther.keyspace);
         if (lastComparison != 0) {
           return lastComparison;
         }
       }
       lastComparison = Boolean.valueOf(isSetKey()).compareTo(typedOther.isSetKey());
       if (lastComparison != 0) {
         return lastComparison;
       }
       if (isSetKey()) {        lastComparison = TBaseHelper.compareTo(key, typedOther.key);
         if (lastComparison != 0) {
           return lastComparison;
         }
       }
       lastComparison = Boolean.valueOf(isSetColumn_path()).compareTo(typedOther.isSetColumn_path());
       if (lastComparison != 0) {
         return lastComparison;
       }
       if (isSetColumn_path()) {        lastComparison = TBaseHelper.compareTo(column_path, typedOther.column_path);
         if (lastComparison != 0) {
           return lastComparison;
         }
       }
       lastComparison = Boolean.valueOf(isSetConsistency_level()).compareTo(typedOther.isSetConsistency_level());
       if (lastComparison != 0) {
         return lastComparison;
       }
       if (isSetConsistency_level()) {        lastComparison = TBaseHelper.compareTo(consistency_level, typedOther.consistency_level);
         if (lastComparison != 0) {
           return lastComparison;
         }
       }
       return 0;
     }
 
     public void read(TProtocol iprot) throws TException {
       TField field;
       iprot.readStructBegin();
       while (true)
       {
         field = iprot.readFieldBegin();
         if (field.type == TType.STOP) { 
           break;
         }
         switch (field.id) {
           case 1: // KEYSPACE
             if (field.type == TType.STRING) {
               this.keyspace = iprot.readString();
             } else { 
               TProtocolUtil.skip(iprot, field.type);
             }
             break;
           case 2: // KEY
             if (field.type == TType.STRING) {
               this.key = iprot.readBinary();
             } else { 
               TProtocolUtil.skip(iprot, field.type);
             }
             break;
           case 3: // COLUMN_PATH
             if (field.type == TType.STRUCT) {
               this.column_path = new ColumnPath();
               this.column_path.read(iprot);
             } else { 
               TProtocolUtil.skip(iprot, field.type);
             }
             break;
           case 4: // CONSISTENCY_LEVEL
             if (field.type == TType.I32) {
               this.consistency_level = ConsistencyLevel.findByValue(iprot.readI32());
             } else { 
               TProtocolUtil.skip(iprot, field.type);
             }
             break;
           default:
             TProtocolUtil.skip(iprot, field.type);
         }
         iprot.readFieldEnd();
       }
       iprot.readStructEnd();
 
       // check for required fields of primitive type, which can't be checked in the validate method
       validate();
     }
 
     public void write(TProtocol oprot) throws TException {
       validate();
 
       oprot.writeStructBegin(STRUCT_DESC);
       if (this.keyspace != null) {
         oprot.writeFieldBegin(KEYSPACE_FIELD_DESC);
         oprot.writeString(this.keyspace);
         oprot.writeFieldEnd();
       }
       if (this.key != null) {
         oprot.writeFieldBegin(KEY_FIELD_DESC);
         oprot.writeBinary(this.key);
         oprot.writeFieldEnd();
       }
       if (this.column_path != null) {
         oprot.writeFieldBegin(COLUMN_PATH_FIELD_DESC);
         this.column_path.write(oprot);
         oprot.writeFieldEnd();
       }
       if (this.consistency_level != null) {
         oprot.writeFieldBegin(CONSISTENCY_LEVEL_FIELD_DESC);
         oprot.writeI32(this.consistency_level.getValue());
         oprot.writeFieldEnd();
       }
       oprot.writeFieldStop();
       oprot.writeStructEnd();
     }
 
     @Override
     public String toString() {
       StringBuilder sb = new StringBuilder("get_args(");
       boolean first = true;
 
       sb.append("keyspace:");
       if (this.keyspace == null) {
         sb.append("null");
       } else {
         sb.append(this.keyspace);
       }
       first = false;
       if (!first) sb.append(", ");
       sb.append("key:");
       if (this.key == null) {
         sb.append("null");
       } else {
           int __key_size = Math.min(this.key.length, 128);
           for (int i = 0; i < __key_size; i++) {
             if (i != 0) sb.append(" ");
             sb.append(Integer.toHexString(this.key[i]).length() > 1 ? Integer.toHexString(this.key[i]).substring(Integer.toHexString(this.key[i]).length() - 2).toUpperCase() : "0" + Integer.toHexString(this.key[i]).toUpperCase());
           }
           if (this.key.length > 128) sb.append(" ...");
       }
       first = false;
       if (!first) sb.append(", ");
       sb.append("column_path:");
       if (this.column_path == null) {
         sb.append("null");
       } else {
         sb.append(this.column_path);
       }
       first = false;
       if (!first) sb.append(", ");
       sb.append("consistency_level:");
       if (this.consistency_level == null) {
         sb.append("null");
       } else {
         sb.append(this.consistency_level);
       }
       first = false;
       sb.append(")");
       return sb.toString();
     }
 
     public void validate() throws TException {
       // check for required fields
       if (keyspace == null) {
         throw new TProtocolException("Required field 'keyspace' was not present! Struct: " + toString());
       }
       if (key == null) {
         throw new TProtocolException("Required field 'key' was not present! Struct: " + toString());
       }
       if (column_path == null) {
         throw new TProtocolException("Required field 'column_path' was not present! Struct: " + toString());
       }
       if (consistency_level == null) {
         throw new TProtocolException("Required field 'consistency_level' was not present! Struct: " + toString());
       }
     }
 
   }
 
   public static class get_result implements TBase<get_result._Fields>, java.io.Serializable, Cloneable, Comparable<get_result>   {
     private static final TStruct STRUCT_DESC = new TStruct("get_result");
 
     private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);
     private static final TField IRE_FIELD_DESC = new TField("ire", TType.STRUCT, (short)1);
     private static final TField NFE_FIELD_DESC = new TField("nfe", TType.STRUCT, (short)2);
     private static final TField UE_FIELD_DESC = new TField("ue", TType.STRUCT, (short)3);
     private static final TField TE_FIELD_DESC = new TField("te", TType.STRUCT, (short)4);
 
     public ColumnOrSuperColumn success;
     public InvalidRequestException ire;
     public NotFoundException nfe;
     public UnavailableException ue;
     public TimedOutException te;
 
     /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
     public enum _Fields implements TFieldIdEnum {
       SUCCESS((short)0, "success"),
       IRE((short)1, "ire"),
       NFE((short)2, "nfe"),
       UE((short)3, "ue"),
       TE((short)4, "te");
 
       private static final Map<Integer, _Fields> byId = new HashMap<Integer, _Fields>();
       private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();
 
       static {
         for (_Fields field : EnumSet.allOf(_Fields.class)) {
           byId.put((int)field._thriftId, field);
           byName.put(field.getFieldName(), field);
         }
       }
 
       /**
        * Find the _Fields constant that matches fieldId, or null if its not found.
        */
       public static _Fields findByThriftId(int fieldId) {
         return byId.get(fieldId);
       }
 
       /**
        * Find the _Fields constant that matches fieldId, throwing an exception
        * if it is not found.
        */
       public static _Fields findByThriftIdOrThrow(int fieldId) {
         _Fields fields = findByThriftId(fieldId);
         if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
         return fields;
       }
 
       /**
        * Find the _Fields constant that matches name, or null if its not found.
        */
       public static _Fields findByName(String name) {
         return byName.get(name);
       }
 
       private final short _thriftId;
       private final String _fieldName;
 
       _Fields(short thriftId, String fieldName) {
         _thriftId = thriftId;
         _fieldName = fieldName;
       }
 
       public short getThriftFieldId() {
         return _thriftId;
       }
 
       public String getFieldName() {
         return _fieldName;
       }
     }
 
     // isset id assignments
 
     public static final Map<_Fields, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new EnumMap<_Fields, FieldMetaData>(_Fields.class) {{
       put(_Fields.SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
           new StructMetaData(TType.STRUCT, ColumnOrSuperColumn.class)));
       put(_Fields.IRE, new FieldMetaData("ire", TFieldRequirementType.DEFAULT, 
           new FieldValueMetaData(TType.STRUCT)));
       put(_Fields.NFE, new FieldMetaData("nfe", TFieldRequirementType.DEFAULT, 
           new FieldValueMetaData(TType.STRUCT)));
       put(_Fields.UE, new FieldMetaData("ue", TFieldRequirementType.DEFAULT, 
           new FieldValueMetaData(TType.STRUCT)));
       put(_Fields.TE, new FieldMetaData("te", TFieldRequirementType.DEFAULT, 
           new FieldValueMetaData(TType.STRUCT)));
     }});
 
     static {
       FieldMetaData.addStructMetaDataMap(get_result.class, metaDataMap);
     }
 
     public get_result() {
     }
 
     public get_result(
       ColumnOrSuperColumn success,
       InvalidRequestException ire,
       NotFoundException nfe,
       UnavailableException ue,
       TimedOutException te)
     {
       this();
       this.success = success;
       this.ire = ire;
       this.nfe = nfe;
       this.ue = ue;
       this.te = te;
     }
 
     /**
      * Performs a deep copy on <i>other</i>.
      */
     public get_result(get_result other) {
       if (other.isSetSuccess()) {
         this.success = new ColumnOrSuperColumn(other.success);
       }
       if (other.isSetIre()) {
         this.ire = new InvalidRequestException(other.ire);
       }
       if (other.isSetNfe()) {
         this.nfe = new NotFoundException(other.nfe);
       }
       if (other.isSetUe()) {
         this.ue = new UnavailableException(other.ue);
       }
       if (other.isSetTe()) {
         this.te = new TimedOutException(other.te);
       }
     }
 
     public get_result deepCopy() {
       return new get_result(this);
     }
 
     @Deprecated
     public get_result clone() {
       return new get_result(this);
     }
 
     public ColumnOrSuperColumn getSuccess() {
       return this.success;
     }
 
     public get_result setSuccess(ColumnOrSuperColumn success) {
       this.success = success;
       return this;
     }
 
     public void unsetSuccess() {
       this.success = null;
     }
 
     /** Returns true if field success is set (has been asigned a value) and false otherwise */
     public boolean isSetSuccess() {
       return this.success != null;
     }
 
     public void setSuccessIsSet(boolean value) {
       if (!value) {
         this.success = null;
       }
     }
 
     public InvalidRequestException getIre() {
       return this.ire;
     }
 
     public get_result setIre(InvalidRequestException ire) {
       this.ire = ire;
       return this;
     }
 
     public void unsetIre() {
       this.ire = null;
     }
 
     /** Returns true if field ire is set (has been asigned a value) and false otherwise */
     public boolean isSetIre() {
       return this.ire != null;
     }
 
     public void setIreIsSet(boolean value) {
       if (!value) {
         this.ire = null;
       }
     }
 
     public NotFoundException getNfe() {
       return this.nfe;
     }
 
     public get_result setNfe(NotFoundException nfe) {
       this.nfe = nfe;
       return this;
     }
 
     public void unsetNfe() {
       this.nfe = null;
     }
 
     /** Returns true if field nfe is set (has been asigned a value) and false otherwise */
     public boolean isSetNfe() {
       return this.nfe != null;
     }
 
     public void setNfeIsSet(boolean value) {
       if (!value) {
         this.nfe = null;
       }
     }
 
     public UnavailableException getUe() {
       return this.ue;
     }
 
     public get_result setUe(UnavailableException ue) {
       this.ue = ue;
       return this;
     }
 
     public void unsetUe() {
       this.ue = null;
     }
 
     /** Returns true if field ue is set (has been asigned a value) and false otherwise */
     public boolean isSetUe() {
       return this.ue != null;
     }
 
     public void setUeIsSet(boolean value) {
       if (!value) {
         this.ue = null;
       }
     }
 
     public TimedOutException getTe() {
       return this.te;
     }
 
     public get_result setTe(TimedOutException te) {
       this.te = te;
       return this;
     }
 
     public void unsetTe() {
       this.te = null;
     }
 
     /** Returns true if field te is set (has been asigned a value) and false otherwise */
     public boolean isSetTe() {
       return this.te != null;
     }
 
     public void setTeIsSet(boolean value) {
       if (!value) {
         this.te = null;
       }
     }
 
     public void setFieldValue(_Fields field, Object value) {
       switch (field) {
       case SUCCESS:
         if (value == null) {
           unsetSuccess();
         } else {
           setSuccess((ColumnOrSuperColumn)value);
         }
         break;
 
       case IRE:
         if (value == null) {
           unsetIre();
         } else {
           setIre((InvalidRequestException)value);
         }
         break;
 
       case NFE:
         if (value == null) {
           unsetNfe();
         } else {
           setNfe((NotFoundException)value);
         }
         break;
 
       case UE:
         if (value == null) {
           unsetUe();
         } else {
           setUe((UnavailableException)value);
         }
         break;
 
       case TE:
         if (value == null) {
           unsetTe();
         } else {
           setTe((TimedOutException)value);
         }
         break;
 
       }
     }
 
     public void setFieldValue(int fieldID, Object value) {
       setFieldValue(_Fields.findByThriftIdOrThrow(fieldID), value);
     }
 
     public Object getFieldValue(_Fields field) {
       switch (field) {
       case SUCCESS:
         return getSuccess();
 
       case IRE:
         return getIre();
 
       case NFE:
         return getNfe();
 
       case UE:
         return getUe();
 
       case TE:
         return getTe();
 
       }
       throw new IllegalStateException();
     }
 
     public Object getFieldValue(int fieldId) {
       return getFieldValue(_Fields.findByThriftIdOrThrow(fieldId));
     }
 
     /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
     public boolean isSet(_Fields field) {
       switch (field) {
       case SUCCESS:
         return isSetSuccess();
       case IRE:
         return isSetIre();
       case NFE:
         return isSetNfe();
       case UE:
         return isSetUe();
       case TE:
         return isSetTe();
       }
       throw new IllegalStateException();
     }
 
     public boolean isSet(int fieldID) {
       return isSet(_Fields.findByThriftIdOrThrow(fieldID));
     }
 
     @Override
     public boolean equals(Object that) {
       if (that == null)
         return false;
       if (that instanceof get_result)
         return this.equals((get_result)that);
       return false;
     }
 
     public boolean equals(get_result that) {
       if (that == null)
         return false;
 
       boolean this_present_success = true && this.isSetSuccess();
       boolean that_present_success = true && that.isSetSuccess();
       if (this_present_success || that_present_success) {
         if (!(this_present_success && that_present_success))
           return false;
         if (!this.success.equals(that.success))
           return false;
       }
 
       boolean this_present_ire = true && this.isSetIre();
       boolean that_present_ire = true && that.isSetIre();
       if (this_present_ire || that_present_ire) {
         if (!(this_present_ire && that_present_ire))
           return false;
         if (!this.ire.equals(that.ire))
           return false;
       }
 
       boolean this_present_nfe = true && this.isSetNfe();
       boolean that_present_nfe = true && that.isSetNfe();
       if (this_present_nfe || that_present_nfe) {
         if (!(this_present_nfe && that_present_nfe))
           return false;
         if (!this.nfe.equals(that.nfe))
           return false;
       }
 
       boolean this_present_ue = true && this.isSetUe();
       boolean that_present_ue = true && that.isSetUe();
       if (this_present_ue || that_present_ue) {
         if (!(this_present_ue && that_present_ue))
           return false;
         if (!this.ue.equals(that.ue))
           return false;
       }
 
       boolean this_present_te = true && this.isSetTe();
       boolean that_present_te = true && that.isSetTe();
       if (this_present_te || that_present_te) {
         if (!(this_present_te && that_present_te))
           return false;
         if (!this.te.equals(that.te))
           return false;
       }
 
       return true;
     }
 
     @Override
     public int hashCode() {
       return 0;
     }
 
     public int compareTo(get_result other) {
       if (!getClass().equals(other.getClass())) {
         return getClass().getName().compareTo(other.getClass().getName());
       }
 
       int lastComparison = 0;
       get_result typedOther = (get_result)other;
 
       lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(typedOther.isSetSuccess());
       if (lastComparison != 0) {
         return lastComparison;
       }
       if (isSetSuccess()) {        lastComparison = TBaseHelper.compareTo(success, typedOther.success);
         if (lastComparison != 0) {
           return lastComparison;
         }
       }
       lastComparison = Boolean.valueOf(isSetIre()).compareTo(typedOther.isSetIre());
       if (lastComparison != 0) {
         return lastComparison;
       }
       if (isSetIre()) {        lastComparison = TBaseHelper.compareTo(ire, typedOther.ire);
         if (lastComparison != 0) {
           return lastComparison;
         }
       }
       lastComparison = Boolean.valueOf(isSetNfe()).compareTo(typedOther.isSetNfe());
       if (lastComparison != 0) {
         return lastComparison;
       }
       if (isSetNfe()) {        lastComparison = TBaseHelper.compareTo(nfe, typedOther.nfe);
         if (lastComparison != 0) {
           return lastComparison;
         }
       }
       lastComparison = Boolean.valueOf(isSetUe()).compareTo(typedOther.isSetUe());
       if (lastComparison != 0) {
         return lastComparison;
       }
       if (isSetUe()) {        lastComparison = TBaseHelper.compareTo(ue, typedOther.ue);
         if (lastComparison != 0) {
           return lastComparison;
         }
       }
       lastComparison = Boolean.valueOf(isSetTe()).compareTo(typedOther.isSetTe());
       if (lastComparison != 0) {
         return lastComparison;
       }
       if (isSetTe()) {        lastComparison = TBaseHelper.compareTo(te, typedOther.te);
         if (lastComparison != 0) {
           return lastComparison;
         }
       }
       return 0;
     }
 
     public void read(TProtocol iprot) throws TException {
       TField field;
       iprot.readStructBegin();
       while (true)
       {
         field = iprot.readFieldBegin();
         if (field.type == TType.STOP) { 
           break;
         }
         switch (field.id) {
           case 0: // SUCCESS
             if (field.type == TType.STRUCT) {
               this.success = new ColumnOrSuperColumn();
               this.success.read(iprot);
             } else { 
               TProtocolUtil.skip(iprot, field.type);
             }
             break;
           case 1: // IRE
             if (field.type == TType.STRUCT) {
               this.ire = new InvalidRequestException();
               this.ire.read(iprot);
             } else { 
               TProtocolUtil.skip(iprot, field.type);
             }
             break;
           case 2: // NFE
             if (field.type == TType.STRUCT) {
               this.nfe = new NotFoundException();
               this.nfe.read(iprot);
             } else { 
               TProtocolUtil.skip(iprot, field.type);
             }
             break;
           case 3: // UE
             if (field.type == TType.STRUCT) {
               this.ue = new UnavailableException();
               this.ue.read(iprot);
             } else { 
               TProtocolUtil.skip(iprot, field.type);
             }
             break;
           case 4: // TE
             if (field.type == TType.STRUCT) {
               this.te = new TimedOutException();
               this.te.read(iprot);
             } else { 
               TProtocolUtil.skip(iprot, field.type);
             }
             break;
           default:
             TProtocolUtil.skip(iprot, field.type);
         }
         iprot.readFieldEnd();
       }
       iprot.readStructEnd();
 
       // check for required fields of primitive type, which can't be checked in the validate method
       validate();
     }
 
     public void write(TProtocol oprot) throws TException {
       oprot.writeStructBegin(STRUCT_DESC);
 
       if (this.isSetSuccess()) {
         oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
         this.success.write(oprot);
         oprot.writeFieldEnd();
       } else if (this.isSetIre()) {
         oprot.writeFieldBegin(IRE_FIELD_DESC);
         this.ire.write(oprot);
         oprot.writeFieldEnd();
       } else if (this.isSetNfe()) {
         oprot.writeFieldBegin(NFE_FIELD_DESC);
         this.nfe.write(oprot);
         oprot.writeFieldEnd();
       } else if (this.isSetUe()) {
         oprot.writeFieldBegin(UE_FIELD_DESC);
         this.ue.write(oprot);
         oprot.writeFieldEnd();
       } else if (this.isSetTe()) {
         oprot.writeFieldBegin(TE_FIELD_DESC);
         this.te.write(oprot);
         oprot.writeFieldEnd();
       }
       oprot.writeFieldStop();
       oprot.writeStructEnd();
     }
 
     @Override
     public String toString() {
       StringBuilder sb = new StringBuilder("get_result(");
       boolean first = true;
 
       sb.append("success:");
       if (this.success == null) {
         sb.append("null");
       } else {
         sb.append(this.success);
       }
       first = false;
       if (!first) sb.append(", ");
       sb.append("ire:");
       if (this.ire == null) {
         sb.append("null");
       } else {
         sb.append(this.ire);
       }
       first = false;
       if (!first) sb.append(", ");
       sb.append("nfe:");
       if (this.nfe == null) {
         sb.append("null");
       } else {
         sb.append(this.nfe);
       }
       first = false;
       if (!first) sb.append(", ");
       sb.append("ue:");
       if (this.ue == null) {
         sb.append("null");
       } else {
         sb.append(this.ue);
       }
       first = false;
       if (!first) sb.append(", ");
       sb.append("te:");
       if (this.te == null) {
         sb.append("null");
       } else {
         sb.append(this.te);
       }
       first = false;
       sb.append(")");
       return sb.toString();
     }
 
     public void validate() throws TException {
       // check for required fields
     }
 
   }
 
   public static class get_slice_args implements TBase<get_slice_args._Fields>, java.io.Serializable, Cloneable, Comparable<get_slice_args>   {
     private static final TStruct STRUCT_DESC = new TStruct("get_slice_args");
 
     private static final TField KEYSPACE_FIELD_DESC = new TField("keyspace", TType.STRING, (short)1);
     private static final TField KEY_FIELD_DESC = new TField("key", TType.STRING, (short)2);
     private static final TField COLUMN_PARENT_FIELD_DESC = new TField("column_parent", TType.STRUCT, (short)3);
     private static final TField PREDICATE_FIELD_DESC = new TField("predicate", TType.STRUCT, (short)4);
     private static final TField CONSISTENCY_LEVEL_FIELD_DESC = new TField("consistency_level", TType.I32, (short)5);
 
     public String keyspace;
     public byte[] key;
     public ColumnParent column_parent;
     public SlicePredicate predicate;
     /**
      * 
      * @see ConsistencyLevel
      */
     public ConsistencyLevel consistency_level;
 
     /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
     public enum _Fields implements TFieldIdEnum {
       KEYSPACE((short)1, "keyspace"),
       KEY((short)2, "key"),
       COLUMN_PARENT((short)3, "column_parent"),
       PREDICATE((short)4, "predicate"),
       /**
        * 
        * @see ConsistencyLevel
        */
       CONSISTENCY_LEVEL((short)5, "consistency_level");
 
       private static final Map<Integer, _Fields> byId = new HashMap<Integer, _Fields>();
       private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();
 
       static {
         for (_Fields field : EnumSet.allOf(_Fields.class)) {
           byId.put((int)field._thriftId, field);
           byName.put(field.getFieldName(), field);
         }
       }
 
       /**
        * Find the _Fields constant that matches fieldId, or null if its not found.
        */
       public static _Fields findByThriftId(int fieldId) {
         return byId.get(fieldId);
       }
 
       /**
        * Find the _Fields constant that matches fieldId, throwing an exception
        * if it is not found.
        */
       public static _Fields findByThriftIdOrThrow(int fieldId) {
         _Fields fields = findByThriftId(fieldId);
         if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
         return fields;
       }
 
       /**
        * Find the _Fields constant that matches name, or null if its not found.
        */
       public static _Fields findByName(String name) {
         return byName.get(name);
       }
 
       private final short _thriftId;
       private final String _fieldName;
 
       _Fields(short thriftId, String fieldName) {
         _thriftId = thriftId;
         _fieldName = fieldName;
       }
 
       public short getThriftFieldId() {
         return _thriftId;
       }
 
       public String getFieldName() {
         return _fieldName;
       }
     }
 
     // isset id assignments
 
     public static final Map<_Fields, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new EnumMap<_Fields, FieldMetaData>(_Fields.class) {{
       put(_Fields.KEYSPACE, new FieldMetaData("keyspace", TFieldRequirementType.REQUIRED, 
           new FieldValueMetaData(TType.STRING)));
       put(_Fields.KEY, new FieldMetaData("key", TFieldRequirementType.REQUIRED, 
           new FieldValueMetaData(TType.STRING)));
       put(_Fields.COLUMN_PARENT, new FieldMetaData("column_parent", TFieldRequirementType.REQUIRED, 
           new StructMetaData(TType.STRUCT, ColumnParent.class)));
       put(_Fields.PREDICATE, new FieldMetaData("predicate", TFieldRequirementType.REQUIRED, 
           new StructMetaData(TType.STRUCT, SlicePredicate.class)));
       put(_Fields.CONSISTENCY_LEVEL, new FieldMetaData("consistency_level", TFieldRequirementType.REQUIRED, 
           new EnumMetaData(TType.ENUM, ConsistencyLevel.class)));
     }});
 
     static {
       FieldMetaData.addStructMetaDataMap(get_slice_args.class, metaDataMap);
     }
 
     public get_slice_args() {
       this.consistency_level = ConsistencyLevel.ONE;
 
     }
 
     public get_slice_args(
       String keyspace,
       byte[] key,
       ColumnParent column_parent,
       SlicePredicate predicate,
       ConsistencyLevel consistency_level)
     {
       this();
       this.keyspace = keyspace;
       this.key = key;
       this.column_parent = column_parent;
       this.predicate = predicate;
       this.consistency_level = consistency_level;
     }
 
     /**
      * Performs a deep copy on <i>other</i>.
      */
     public get_slice_args(get_slice_args other) {
       if (other.isSetKeyspace()) {
         this.keyspace = other.keyspace;
       }
       if (other.isSetKey()) {
         this.key = new byte[other.key.length];
         System.arraycopy(other.key, 0, key, 0, other.key.length);
       }
       if (other.isSetColumn_parent()) {
         this.column_parent = new ColumnParent(other.column_parent);
       }
       if (other.isSetPredicate()) {
         this.predicate = new SlicePredicate(other.predicate);
       }
       if (other.isSetConsistency_level()) {
         this.consistency_level = other.consistency_level;
       }
     }
 
     public get_slice_args deepCopy() {
       return new get_slice_args(this);
     }
 
     @Deprecated
     public get_slice_args clone() {
       return new get_slice_args(this);
     }
 
     public String getKeyspace() {
       return this.keyspace;
     }
 
     public get_slice_args setKeyspace(String keyspace) {
       this.keyspace = keyspace;
       return this;
     }
 
     public void unsetKeyspace() {
       this.keyspace = null;
     }
 
     /** Returns true if field keyspace is set (has been asigned a value) and false otherwise */
     public boolean isSetKeyspace() {
       return this.keyspace != null;
     }
 
     public void setKeyspaceIsSet(boolean value) {
       if (!value) {
         this.keyspace = null;
       }
     }
 
     public byte[] getKey() {
       return this.key;
     }
 
     public get_slice_args setKey(byte[] key) {
       this.key = key;
       return this;
     }
 
     public void unsetKey() {
       this.key = null;
     }
 
     /** Returns true if field key is set (has been asigned a value) and false otherwise */
     public boolean isSetKey() {
       return this.key != null;
     }
 
     public void setKeyIsSet(boolean value) {
       if (!value) {
         this.key = null;
       }
     }
 
     public ColumnParent getColumn_parent() {
       return this.column_parent;
     }
 
     public get_slice_args setColumn_parent(ColumnParent column_parent) {
       this.column_parent = column_parent;
       return this;
     }
 
     public void unsetColumn_parent() {
       this.column_parent = null;
     }
 
     /** Returns true if field column_parent is set (has been asigned a value) and false otherwise */
     public boolean isSetColumn_parent() {
       return this.column_parent != null;
     }
 
     public void setColumn_parentIsSet(boolean value) {
       if (!value) {
         this.column_parent = null;
       }
     }
 
     public SlicePredicate getPredicate() {
       return this.predicate;
     }
 
     public get_slice_args setPredicate(SlicePredicate predicate) {
       this.predicate = predicate;
       return this;
     }
 
     public void unsetPredicate() {
       this.predicate = null;
     }
 
     /** Returns true if field predicate is set (has been asigned a value) and false otherwise */
     public boolean isSetPredicate() {
       return this.predicate != null;
     }
 
     public void setPredicateIsSet(boolean value) {
       if (!value) {
         this.predicate = null;
       }
     }
 
     /**
      * 
      * @see ConsistencyLevel
      */
     public ConsistencyLevel getConsistency_level() {
       return this.consistency_level;
     }
 
     /**
      * 
      * @see ConsistencyLevel
      */
     public get_slice_args setConsistency_level(ConsistencyLevel consistency_level) {
       this.consistency_level = consistency_level;
       return this;
     }
 
     public void unsetConsistency_level() {
       this.consistency_level = null;
     }
 
     /** Returns true if field consistency_level is set (has been asigned a value) and false otherwise */
     public boolean isSetConsistency_level() {
       return this.consistency_level != null;
     }
 
     public void setConsistency_levelIsSet(boolean value) {
       if (!value) {
         this.consistency_level = null;
       }
     }
 
     public void setFieldValue(_Fields field, Object value) {
       switch (field) {
       case KEYSPACE:
         if (value == null) {
           unsetKeyspace();
         } else {
           setKeyspace((String)value);
         }
         break;
 
       case KEY:
         if (value == null) {
           unsetKey();
         } else {
           setKey((byte[])value);
         }
         break;
 
       case COLUMN_PARENT:
         if (value == null) {
           unsetColumn_parent();
         } else {
           setColumn_parent((ColumnParent)value);
         }
         break;
 
       case PREDICATE:
         if (value == null) {
           unsetPredicate();
         } else {
           setPredicate((SlicePredicate)value);
         }
         break;
 
       case CONSISTENCY_LEVEL:
         if (value == null) {
           unsetConsistency_level();
         } else {
           setConsistency_level((ConsistencyLevel)value);
         }
         break;
 
       }
     }
 
     public void setFieldValue(int fieldID, Object value) {
       setFieldValue(_Fields.findByThriftIdOrThrow(fieldID), value);
     }
 
     public Object getFieldValue(_Fields field) {
       switch (field) {
       case KEYSPACE:
         return getKeyspace();
 
       case KEY:
         return getKey();
 
       case COLUMN_PARENT:
         return getColumn_parent();
 
       case PREDICATE:
         return getPredicate();
 
       case CONSISTENCY_LEVEL:
         return getConsistency_level();
 
       }
       throw new IllegalStateException();
     }
 
     public Object getFieldValue(int fieldId) {
       return getFieldValue(_Fields.findByThriftIdOrThrow(fieldId));
     }
 
     /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
     public boolean isSet(_Fields field) {
       switch (field) {
       case KEYSPACE:
         return isSetKeyspace();
       case KEY:
         return isSetKey();
       case COLUMN_PARENT:
         return isSetColumn_parent();
       case PREDICATE:
         return isSetPredicate();
       case CONSISTENCY_LEVEL:
         return isSetConsistency_level();
       }
       throw new IllegalStateException();
     }
 
     public boolean isSet(int fieldID) {
       return isSet(_Fields.findByThriftIdOrThrow(fieldID));
     }
 
     @Override
     public boolean equals(Object that) {
       if (that == null)
         return false;
       if (that instanceof get_slice_args)
         return this.equals((get_slice_args)that);
       return false;
     }
 
     public boolean equals(get_slice_args that) {
       if (that == null)
         return false;
 
       boolean this_present_keyspace = true && this.isSetKeyspace();
       boolean that_present_keyspace = true && that.isSetKeyspace();
       if (this_present_keyspace || that_present_keyspace) {
         if (!(this_present_keyspace && that_present_keyspace))
           return false;
         if (!this.keyspace.equals(that.keyspace))
           return false;
       }
 
       boolean this_present_key = true && this.isSetKey();
       boolean that_present_key = true && that.isSetKey();
       if (this_present_key || that_present_key) {
         if (!(this_present_key && that_present_key))
           return false;
         if (!java.util.Arrays.equals(this.key, that.key))
           return false;
       }
 
       boolean this_present_column_parent = true && this.isSetColumn_parent();
       boolean that_present_column_parent = true && that.isSetColumn_parent();
       if (this_present_column_parent || that_present_column_parent) {
         if (!(this_present_column_parent && that_present_column_parent))
           return false;
         if (!this.column_parent.equals(that.column_parent))
           return false;
       }
 
       boolean this_present_predicate = true && this.isSetPredicate();
       boolean that_present_predicate = true && that.isSetPredicate();
       if (this_present_predicate || that_present_predicate) {
         if (!(this_present_predicate && that_present_predicate))
           return false;
         if (!this.predicate.equals(that.predicate))
           return false;
       }
 
       boolean this_present_consistency_level = true && this.isSetConsistency_level();
       boolean that_present_consistency_level = true && that.isSetConsistency_level();
       if (this_present_consistency_level || that_present_consistency_level) {
         if (!(this_present_consistency_level && that_present_consistency_level))
           return false;
         if (!this.consistency_level.equals(that.consistency_level))
           return false;
       }
 
       return true;
     }
 
     @Override
     public int hashCode() {
       return 0;
     }
 
     public int compareTo(get_slice_args other) {
       if (!getClass().equals(other.getClass())) {
         return getClass().getName().compareTo(other.getClass().getName());
       }
 
       int lastComparison = 0;
       get_slice_args typedOther = (get_slice_args)other;
 
       lastComparison = Boolean.valueOf(isSetKeyspace()).compareTo(typedOther.isSetKeyspace());
       if (lastComparison != 0) {
         return lastComparison;
       }
       if (isSetKeyspace()) {        lastComparison = TBaseHelper.compareTo(keyspace, typedOther.keyspace);
         if (lastComparison != 0) {
           return lastComparison;
         }
       }
       lastComparison = Boolean.valueOf(isSetKey()).compareTo(typedOther.isSetKey());
       if (lastComparison != 0) {
         return lastComparison;
       }
       if (isSetKey()) {        lastComparison = TBaseHelper.compareTo(key, typedOther.key);
         if (lastComparison != 0) {
           return lastComparison;
         }
       }
       lastComparison = Boolean.valueOf(isSetColumn_parent()).compareTo(typedOther.isSetColumn_parent());
       if (lastComparison != 0) {
         return lastComparison;
       }
       if (isSetColumn_parent()) {        lastComparison = TBaseHelper.compareTo(column_parent, typedOther.column_parent);
         if (lastComparison != 0) {
           return lastComparison;
         }
       }
       lastComparison = Boolean.valueOf(isSetPredicate()).compareTo(typedOther.isSetPredicate());
       if (lastComparison != 0) {
         return lastComparison;
       }
       if (isSetPredicate()) {        lastComparison = TBaseHelper.compareTo(predicate, typedOther.predicate);
         if (lastComparison != 0) {
           return lastComparison;
         }
       }
       lastComparison = Boolean.valueOf(isSetConsistency_level()).compareTo(typedOther.isSetConsistency_level());
       if (lastComparison != 0) {
         return lastComparison;
       }
       if (isSetConsistency_level()) {        lastComparison = TBaseHelper.compareTo(consistency_level, typedOther.consistency_level);
         if (lastComparison != 0) {
           return lastComparison;
         }
       }
       return 0;
     }
 
     public void read(TProtocol iprot) throws TException {
       TField field;
       iprot.readStructBegin();
       while (true)
       {
         field = iprot.readFieldBegin();
         if (field.type == TType.STOP) { 
           break;
         }
         switch (field.id) {
           case 1: // KEYSPACE
             if (field.type == TType.STRING) {
               this.keyspace = iprot.readString();
             } else { 
               TProtocolUtil.skip(iprot, field.type);
             }
             break;
           case 2: // KEY
             if (field.type == TType.STRING) {
               this.key = iprot.readBinary();
             } else { 
               TProtocolUtil.skip(iprot, field.type);
             }
             break;
           case 3: // COLUMN_PARENT
             if (field.type == TType.STRUCT) {
               this.column_parent = new ColumnParent();
               this.column_parent.read(iprot);
             } else { 
               TProtocolUtil.skip(iprot, field.type);
             }
             break;
           case 4: // PREDICATE
             if (field.type == TType.STRUCT) {
               this.predicate = new SlicePredicate();
               this.predicate.read(iprot);
             } else { 
               TProtocolUtil.skip(iprot, field.type);
             }
             break;
           case 5: // CONSISTENCY_LEVEL
             if (field.type == TType.I32) {
               this.consistency_level = ConsistencyLevel.findByValue(iprot.readI32());
             } else { 
               TProtocolUtil.skip(iprot, field.type);
             }
             break;
           default:
             TProtocolUtil.skip(iprot, field.type);
         }
         iprot.readFieldEnd();
       }
       iprot.readStructEnd();
 
       // check for required fields of primitive type, which can't be checked in the validate method
       validate();
     }
 
     public void write(TProtocol oprot) throws TException {
       validate();
 
       oprot.writeStructBegin(STRUCT_DESC);
       if (this.keyspace != null) {
         oprot.writeFieldBegin(KEYSPACE_FIELD_DESC);
         oprot.writeString(this.keyspace);
         oprot.writeFieldEnd();
       }
       if (this.key != null) {
         oprot.writeFieldBegin(KEY_FIELD_DESC);
         oprot.writeBinary(this.key);
         oprot.writeFieldEnd();
       }
       if (this.column_parent != null) {
         oprot.writeFieldBegin(COLUMN_PARENT_FIELD_DESC);
         this.column_parent.write(oprot);
         oprot.writeFieldEnd();
       }
       if (this.predicate != null) {
         oprot.writeFieldBegin(PREDICATE_FIELD_DESC);
         this.predicate.write(oprot);
         oprot.writeFieldEnd();
       }
       if (this.consistency_level != null) {
         oprot.writeFieldBegin(CONSISTENCY_LEVEL_FIELD_DESC);
         oprot.writeI32(this.consistency_level.getValue());
         oprot.writeFieldEnd();
       }
       oprot.writeFieldStop();
       oprot.writeStructEnd();
     }
 
     @Override
     public String toString() {
       StringBuilder sb = new StringBuilder("get_slice_args(");
       boolean first = true;
 
       sb.append("keyspace:");
       if (this.keyspace == null) {
         sb.append("null");
       } else {
         sb.append(this.keyspace);
       }
       first = false;
       if (!first) sb.append(", ");
       sb.append("key:");
       if (this.key == null) {
         sb.append("null");
       } else {
           int __key_size = Math.min(this.key.length, 128);
           for (int i = 0; i < __key_size; i++) {
             if (i != 0) sb.append(" ");
             sb.append(Integer.toHexString(this.key[i]).length() > 1 ? Integer.toHexString(this.key[i]).substring(Integer.toHexString(this.key[i]).length() - 2).toUpperCase() : "0" + Integer.toHexString(this.key[i]).toUpperCase());
           }
           if (this.key.length > 128) sb.append(" ...");
       }
       first = false;
       if (!first) sb.append(", ");
       sb.append("column_parent:");
       if (this.column_parent == null) {
         sb.append("null");
       } else {
         sb.append(this.column_parent);
       }
       first = false;
       if (!first) sb.append(", ");
       sb.append("predicate:");
       if (this.predicate == null) {
         sb.append("null");
       } else {
         sb.append(this.predicate);
       }
       first = false;
       if (!first) sb.append(", ");
       sb.append("consistency_level:");
       if (this.consistency_level == null) {
         sb.append("null");
       } else {
         sb.append(this.consistency_level);
       }
       first = false;
       sb.append(")");
       return sb.toString();
     }
 
     public void validate() throws TException {
       // check for required fields
       if (keyspace == null) {
         throw new TProtocolException("Required field 'keyspace' was not present! Struct: " + toString());
       }
       if (key == null) {
         throw new TProtocolException("Required field 'key' was not present! Struct: " + toString());
       }
       if (column_parent == null) {
         throw new TProtocolException("Required field 'column_parent' was not present! Struct: " + toString());
       }
       if (predicate == null) {
         throw new TProtocolException("Required field 'predicate' was not present! Struct: " + toString());
       }
       if (consistency_level == null) {
         throw new TProtocolException("Required field 'consistency_level' was not present! Struct: " + toString());
       }
     }
 
   }
 
   public static class get_slice_result implements TBase<get_slice_result._Fields>, java.io.Serializable, Cloneable, Comparable<get_slice_result>   {
     private static final TStruct STRUCT_DESC = new TStruct("get_slice_result");
 
     private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.LIST, (short)0);
     private static final TField IRE_FIELD_DESC = new TField("ire", TType.STRUCT, (short)1);
     private static final TField UE_FIELD_DESC = new TField("ue", TType.STRUCT, (short)2);
     private static final TField TE_FIELD_DESC = new TField("te", TType.STRUCT, (short)3);
 
     public List<ColumnOrSuperColumn> success;
     public InvalidRequestException ire;
     public UnavailableException ue;
     public TimedOutException te;
 
     /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
     public enum _Fields implements TFieldIdEnum {
       SUCCESS((short)0, "success"),
       IRE((short)1, "ire"),
       UE((short)2, "ue"),
       TE((short)3, "te");
 
       private static final Map<Integer, _Fields> byId = new HashMap<Integer, _Fields>();
       private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();
 
       static {
         for (_Fields field : EnumSet.allOf(_Fields.class)) {
           byId.put((int)field._thriftId, field);
           byName.put(field.getFieldName(), field);
         }
       }
 
       /**
        * Find the _Fields constant that matches fieldId, or null if its not found.
        */
       public static _Fields findByThriftId(int fieldId) {
         return byId.get(fieldId);
       }
 
       /**
        * Find the _Fields constant that matches fieldId, throwing an exception
        * if it is not found.
        */
       public static _Fields findByThriftIdOrThrow(int fieldId) {
         _Fields fields = findByThriftId(fieldId);
         if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
         return fields;
       }
 
       /**
        * Find the _Fields constant that matches name, or null if its not found.
        */
       public static _Fields findByName(String name) {
         return byName.get(name);
       }
 
       private final short _thriftId;
       private final String _fieldName;
 
       _Fields(short thriftId, String fieldName) {
         _thriftId = thriftId;
         _fieldName = fieldName;
       }
 
       public short getThriftFieldId() {
         return _thriftId;
       }
 
       public String getFieldName() {
         return _fieldName;
       }
     }
 
     // isset id assignments
 
     public static final Map<_Fields, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new EnumMap<_Fields, FieldMetaData>(_Fields.class) {{
       put(_Fields.SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
           new ListMetaData(TType.LIST, 
               new StructMetaData(TType.STRUCT, ColumnOrSuperColumn.class))));
       put(_Fields.IRE, new FieldMetaData("ire", TFieldRequirementType.DEFAULT, 
           new FieldValueMetaData(TType.STRUCT)));
       put(_Fields.UE, new FieldMetaData("ue", TFieldRequirementType.DEFAULT, 
           new FieldValueMetaData(TType.STRUCT)));
       put(_Fields.TE, new FieldMetaData("te", TFieldRequirementType.DEFAULT, 
           new FieldValueMetaData(TType.STRUCT)));
     }});
 
     static {
       FieldMetaData.addStructMetaDataMap(get_slice_result.class, metaDataMap);
     }
 
     public get_slice_result() {
     }
 
     public get_slice_result(
       List<ColumnOrSuperColumn> success,
       InvalidRequestException ire,
       UnavailableException ue,
       TimedOutException te)
     {
       this();
       this.success = success;
       this.ire = ire;
       this.ue = ue;
       this.te = te;
     }
 
     /**
      * Performs a deep copy on <i>other</i>.
      */
     public get_slice_result(get_slice_result other) {
       if (other.isSetSuccess()) {
         List<ColumnOrSuperColumn> __this__success = new ArrayList<ColumnOrSuperColumn>();
         for (ColumnOrSuperColumn other_element : other.success) {
           __this__success.add(new ColumnOrSuperColumn(other_element));
         }
         this.success = __this__success;
       }
       if (other.isSetIre()) {
         this.ire = new InvalidRequestException(other.ire);
       }
       if (other.isSetUe()) {
         this.ue = new UnavailableException(other.ue);
       }
       if (other.isSetTe()) {
         this.te = new TimedOutException(other.te);
       }
     }
 
     public get_slice_result deepCopy() {
       return new get_slice_result(this);
     }
 
     @Deprecated
     public get_slice_result clone() {
       return new get_slice_result(this);
     }
 
     public int getSuccessSize() {
       return (this.success == null) ? 0 : this.success.size();
     }
 
     public java.util.Iterator<ColumnOrSuperColumn> getSuccessIterator() {
       return (this.success == null) ? null : this.success.iterator();
     }
 
     public void addToSuccess(ColumnOrSuperColumn elem) {
       if (this.success == null) {
         this.success = new ArrayList<ColumnOrSuperColumn>();
       }
       this.success.add(elem);
     }
 
     public List<ColumnOrSuperColumn> getSuccess() {
       return this.success;
     }
 
     public get_slice_result setSuccess(List<ColumnOrSuperColumn> success) {
       this.success = success;
       return this;
     }
 
     public void unsetSuccess() {
       this.success = null;
     }
 
     /** Returns true if field success is set (has been asigned a value) and false otherwise */
     public boolean isSetSuccess() {
       return this.success != null;
     }
 
     public void setSuccessIsSet(boolean value) {
       if (!value) {
         this.success = null;
       }
     }
 
     public InvalidRequestException getIre() {
       return this.ire;
     }
 
     public get_slice_result setIre(InvalidRequestException ire) {
       this.ire = ire;
       return this;
     }
 
     public void unsetIre() {
       this.ire = null;
     }
 
     /** Returns true if field ire is set (has been asigned a value) and false otherwise */
     public boolean isSetIre() {
       return this.ire != null;
     }
 
     public void setIreIsSet(boolean value) {
       if (!value) {
         this.ire = null;
       }
     }
 
     public UnavailableException getUe() {
       return this.ue;
     }
 
     public get_slice_result setUe(UnavailableException ue) {
       this.ue = ue;
       return this;
     }
 
     public void unsetUe() {
       this.ue = null;
     }
 
     /** Returns true if field ue is set (has been asigned a value) and false otherwise */
     public boolean isSetUe() {
       return this.ue != null;
     }
 
     public void setUeIsSet(boolean value) {
       if (!value) {
         this.ue = null;
       }
     }
 
     public TimedOutException getTe() {
       return this.te;
     }
 
     public get_slice_result setTe(TimedOutException te) {
       this.te = te;
       return this;
     }
 
     public void unsetTe() {
       this.te = null;
     }
 
     /** Returns true if field te is set (has been asigned a value) and false otherwise */
     public boolean isSetTe() {
       return this.te != null;
     }
 
     public void setTeIsSet(boolean value) {
       if (!value) {
         this.te = null;
       }
     }
 
     public void setFieldValue(_Fields field, Object value) {
       switch (field) {
       case SUCCESS:
         if (value == null) {
           unsetSuccess();
         } else {
           setSuccess((List<ColumnOrSuperColumn>)value);
         }
         break;
 
       case IRE:
         if (value == null) {
           unsetIre();
         } else {
           setIre((InvalidRequestException)value);
         }
         break;
 
       case UE:
         if (value == null) {
           unsetUe();
         } else {
           setUe((UnavailableException)value);
         }
         break;
 
       case TE:
         if (value == null) {
           unsetTe();
         } else {
           setTe((TimedOutException)value);
         }
         break;
 
       }
     }
 
     public void setFieldValue(int fieldID, Object value) {
       setFieldValue(_Fields.findByThriftIdOrThrow(fieldID), value);
     }
 
     public Object getFieldValue(_Fields field) {
       switch (field) {
       case SUCCESS:
         return getSuccess();
 
       case IRE:
         return getIre();
 
       case UE:
         return getUe();
 
       case TE:
         return getTe();
 
       }
       throw new IllegalStateException();
     }
 
     public Object getFieldValue(int fieldId) {
       return getFieldValue(_Fields.findByThriftIdOrThrow(fieldId));
     }
 
     /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
     public boolean isSet(_Fields field) {
       switch (field) {
       case SUCCESS:
         return isSetSuccess();
       case IRE:
         return isSetIre();
       case UE:
         return isSetUe();
       case TE:
         return isSetTe();
       }
       throw new IllegalStateException();
     }
 
     public boolean isSet(int fieldID) {
       return isSet(_Fields.findByThriftIdOrThrow(fieldID));
     }
 
     @Override
     public boolean equals(Object that) {
       if (that == null)
         return false;
       if (that instanceof get_slice_result)
         return this.equals((get_slice_result)that);
       return false;
     }
 
     public boolean equals(get_slice_result that) {
       if (that == null)
         return false;
 
       boolean this_present_success = true && this.isSetSuccess();
       boolean that_present_success = true && that.isSetSuccess();
       if (this_present_success || that_present_success) {
         if (!(this_present_success && that_present_success))
           return false;
         if (!this.success.equals(that.success))
           return false;
       }
 
       boolean this_present_ire = true && this.isSetIre();
       boolean that_present_ire = true && that.isSetIre();
       if (this_present_ire || that_present_ire) {
         if (!(this_present_ire && that_present_ire))
           return false;
         if (!this.ire.equals(that.ire))
           return false;
       }
 
       boolean this_present_ue = true && this.isSetUe();
       boolean that_present_ue = true && that.isSetUe();
       if (this_present_ue || that_present_ue) {
         if (!(this_present_ue && that_present_ue))
           return false;
         if (!this.ue.equals(that.ue))
           return false;
       }
 
       boolean this_present_te = true && this.isSetTe();
       boolean that_present_te = true && that.isSetTe();
       if (this_present_te || that_present_te) {
         if (!(this_present_te && that_present_te))
           return false;
         if (!this.te.equals(that.te))
           return false;
       }
 
       return true;
     }
 
     @Override
     public int hashCode() {
       return 0;
     }
 
     public int compareTo(get_slice_result other) {
       if (!getClass().equals(other.getClass())) {
         return getClass().getName().compareTo(other.getClass().getName());
       }
 
       int lastComparison = 0;
       get_slice_result typedOther = (get_slice_result)other;
 
       lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(typedOther.isSetSuccess());
       if (lastComparison != 0) {
         return lastComparison;
       }
       if (isSetSuccess()) {        lastComparison = TBaseHelper.compareTo(success, typedOther.success);
         if (lastComparison != 0) {
           return lastComparison;
         }
       }
       lastComparison = Boolean.valueOf(isSetIre()).compareTo(typedOther.isSetIre());
       if (lastComparison != 0) {
         return lastComparison;
       }
       if (isSetIre()) {        lastComparison = TBaseHelper.compareTo(ire, typedOther.ire);
         if (lastComparison != 0) {
           return lastComparison;
         }
       }
       lastComparison = Boolean.valueOf(isSetUe()).compareTo(typedOther.isSetUe());
       if (lastComparison != 0) {
         return lastComparison;
       }
       if (isSetUe()) {        lastComparison = TBaseHelper.compareTo(ue, typedOther.ue);
         if (lastComparison != 0) {
           return lastComparison;
         }
       }
       lastComparison = Boolean.valueOf(isSetTe()).compareTo(typedOther.isSetTe());
       if (lastComparison != 0) {
         return lastComparison;
       }
       if (isSetTe()) {        lastComparison = TBaseHelper.compareTo(te, typedOther.te);
         if (lastComparison != 0) {
           return lastComparison;
         }
       }
       return 0;
     }
 
     public void read(TProtocol iprot) throws TException {
       TField field;
       iprot.readStructBegin();
       while (true)
       {
         field = iprot.readFieldBegin();
         if (field.type == TType.STOP) { 
           break;
         }
         switch (field.id) {
           case 0: // SUCCESS
             if (field.type == TType.LIST) {
               {
                 TList _list29 = iprot.readListBegin();
                 this.success = new ArrayList<ColumnOrSuperColumn>(_list29.size);
                 for (int _i30 = 0; _i30 < _list29.size; ++_i30)
                 {
                   ColumnOrSuperColumn _elem31;
                   _elem31 = new ColumnOrSuperColumn();
                   _elem31.read(iprot);
                   this.success.add(_elem31);
                 }
                 iprot.readListEnd();
               }
             } else { 
               TProtocolUtil.skip(iprot, field.type);
             }
             break;
           case 1: // IRE
             if (field.type == TType.STRUCT) {
               this.ire = new InvalidRequestException();
               this.ire.read(iprot);
             } else { 
               TProtocolUtil.skip(iprot, field.type);
             }
             break;
           case 2: // UE
             if (field.type == TType.STRUCT) {
               this.ue = new UnavailableException();
               this.ue.read(iprot);
             } else { 
               TProtocolUtil.skip(iprot, field.type);
             }
             break;
           case 3: // TE
             if (field.type == TType.STRUCT) {
               this.te = new TimedOutException();
               this.te.read(iprot);
             } else { 
               TProtocolUtil.skip(iprot, field.type);
             }
             break;
           default:
             TProtocolUtil.skip(iprot, field.type);
         }
         iprot.readFieldEnd();
       }
       iprot.readStructEnd();
 
       // check for required fields of primitive type, which can't be checked in the validate method
       validate();
     }
 
     public void write(TProtocol oprot) throws TException {
       oprot.writeStructBegin(STRUCT_DESC);
 
       if (this.isSetSuccess()) {
         oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
         {
           oprot.writeListBegin(new TList(TType.STRUCT, this.success.size()));
           for (ColumnOrSuperColumn _iter32 : this.success)
           {
             _iter32.write(oprot);
           }
           oprot.writeListEnd();
         }
         oprot.writeFieldEnd();
       } else if (this.isSetIre()) {
         oprot.writeFieldBegin(IRE_FIELD_DESC);
         this.ire.write(oprot);
         oprot.writeFieldEnd();
       } else if (this.isSetUe()) {
         oprot.writeFieldBegin(UE_FIELD_DESC);
         this.ue.write(oprot);
         oprot.writeFieldEnd();
       } else if (this.isSetTe()) {
         oprot.writeFieldBegin(TE_FIELD_DESC);
         this.te.write(oprot);
         oprot.writeFieldEnd();
       }
       oprot.writeFieldStop();
       oprot.writeStructEnd();
     }
 
     @Override
     public String toString() {
       StringBuilder sb = new StringBuilder("get_slice_result(");
       boolean first = true;
 
       sb.append("success:");
       if (this.success == null) {
         sb.append("null");
       } else {
         sb.append(this.success);
       }
       first = false;
       if (!first) sb.append(", ");
       sb.append("ire:");
       if (this.ire == null) {
         sb.append("null");
       } else {
         sb.append(this.ire);
       }
       first = false;
       if (!first) sb.append(", ");
       sb.append("ue:");
       if (this.ue == null) {
         sb.append("null");
       } else {
         sb.append(this.ue);
       }
       first = false;
       if (!first) sb.append(", ");
       sb.append("te:");
       if (this.te == null) {
         sb.append("null");
       } else {
         sb.append(this.te);
       }
       first = false;
       sb.append(")");
       return sb.toString();
     }
 
     public void validate() throws TException {
       // check for required fields
     }
 
   }
 
   public static class multiget_args implements TBase<multiget_args._Fields>, java.io.Serializable, Cloneable, Comparable<multiget_args>   {
     private static final TStruct STRUCT_DESC = new TStruct("multiget_args");
 
     private static final TField KEYSPACE_FIELD_DESC = new TField("keyspace", TType.STRING, (short)1);
     private static final TField KEYS_FIELD_DESC = new TField("keys", TType.LIST, (short)2);
     private static final TField COLUMN_PATH_FIELD_DESC = new TField("column_path", TType.STRUCT, (short)3);
     private static final TField CONSISTENCY_LEVEL_FIELD_DESC = new TField("consistency_level", TType.I32, (short)4);
 
     public String keyspace;
     public List<byte[]> keys;
     public ColumnPath column_path;
     /**
      * 
      * @see ConsistencyLevel
      */
     public ConsistencyLevel consistency_level;
 
     /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
     public enum _Fields implements TFieldIdEnum {
       KEYSPACE((short)1, "keyspace"),
       KEYS((short)2, "keys"),
       COLUMN_PATH((short)3, "column_path"),
       /**
        * 
        * @see ConsistencyLevel
        */
       CONSISTENCY_LEVEL((short)4, "consistency_level");
 
       private static final Map<Integer, _Fields> byId = new HashMap<Integer, _Fields>();
       private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();
 
       static {
         for (_Fields field : EnumSet.allOf(_Fields.class)) {
           byId.put((int)field._thriftId, field);
           byName.put(field.getFieldName(), field);
         }
       }
 
       /**
        * Find the _Fields constant that matches fieldId, or null if its not found.
        */
       public static _Fields findByThriftId(int fieldId) {
         return byId.get(fieldId);
       }
 
       /**
        * Find the _Fields constant that matches fieldId, throwing an exception
        * if it is not found.
        */
       public static _Fields findByThriftIdOrThrow(int fieldId) {
         _Fields fields = findByThriftId(fieldId);
         if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
         return fields;
       }
 
       /**
        * Find the _Fields constant that matches name, or null if its not found.
        */
       public static _Fields findByName(String name) {
         return byName.get(name);
       }
 
       private final short _thriftId;
       private final String _fieldName;
 
       _Fields(short thriftId, String fieldName) {
         _thriftId = thriftId;
         _fieldName = fieldName;
       }
 
       public short getThriftFieldId() {
         return _thriftId;
       }
 
       public String getFieldName() {
         return _fieldName;
       }
     }
 
     // isset id assignments
 
     public static final Map<_Fields, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new EnumMap<_Fields, FieldMetaData>(_Fields.class) {{
       put(_Fields.KEYSPACE, new FieldMetaData("keyspace", TFieldRequirementType.REQUIRED, 
           new FieldValueMetaData(TType.STRING)));
       put(_Fields.KEYS, new FieldMetaData("keys", TFieldRequirementType.REQUIRED, 
           new ListMetaData(TType.LIST, 
               new FieldValueMetaData(TType.STRING))));
       put(_Fields.COLUMN_PATH, new FieldMetaData("column_path", TFieldRequirementType.REQUIRED, 
           new StructMetaData(TType.STRUCT, ColumnPath.class)));
       put(_Fields.CONSISTENCY_LEVEL, new FieldMetaData("consistency_level", TFieldRequirementType.REQUIRED, 
           new EnumMetaData(TType.ENUM, ConsistencyLevel.class)));
     }});
 
     static {
       FieldMetaData.addStructMetaDataMap(multiget_args.class, metaDataMap);
     }
 
     public multiget_args() {
       this.consistency_level = ConsistencyLevel.ONE;
 
     }
 
     public multiget_args(
       String keyspace,
       List<byte[]> keys,
       ColumnPath column_path,
       ConsistencyLevel consistency_level)
     {
       this();
       this.keyspace = keyspace;
       this.keys = keys;
       this.column_path = column_path;
       this.consistency_level = consistency_level;
     }
 
     /**
      * Performs a deep copy on <i>other</i>.
      */
     public multiget_args(multiget_args other) {
       if (other.isSetKeyspace()) {
         this.keyspace = other.keyspace;
       }
       if (other.isSetKeys()) {
         List<byte[]> __this__keys = new ArrayList<byte[]>();
         for (byte[] other_element : other.keys) {
           byte[] temp_binary_element = new byte[other_element.length];
           System.arraycopy(other_element, 0, temp_binary_element, 0, other_element.length);
           __this__keys.add(temp_binary_element);
         }
         this.keys = __this__keys;
       }
       if (other.isSetColumn_path()) {
         this.column_path = new ColumnPath(other.column_path);
       }
       if (other.isSetConsistency_level()) {
         this.consistency_level = other.consistency_level;
       }
     }
 
     public multiget_args deepCopy() {
       return new multiget_args(this);
     }
 
     @Deprecated
     public multiget_args clone() {
       return new multiget_args(this);
     }
 
     public String getKeyspace() {
       return this.keyspace;
     }
 
     public multiget_args setKeyspace(String keyspace) {
       this.keyspace = keyspace;
       return this;
     }
 
     public void unsetKeyspace() {
       this.keyspace = null;
     }
 
     /** Returns true if field keyspace is set (has been asigned a value) and false otherwise */
     public boolean isSetKeyspace() {
       return this.keyspace != null;
     }
 
     public void setKeyspaceIsSet(boolean value) {
       if (!value) {
         this.keyspace = null;
       }
     }
 
     public int getKeysSize() {
       return (this.keys == null) ? 0 : this.keys.size();
     }
 
     public java.util.Iterator<byte[]> getKeysIterator() {
       return (this.keys == null) ? null : this.keys.iterator();
     }
 
     public void addToKeys(byte[] elem) {
       if (this.keys == null) {
         this.keys = new ArrayList<byte[]>();
       }
       this.keys.add(elem);
     }
 
     public List<byte[]> getKeys() {
       return this.keys;
     }
 
     public multiget_args setKeys(List<byte[]> keys) {
       this.keys = keys;
       return this;
     }
 
     public void unsetKeys() {
       this.keys = null;
     }
 
     /** Returns true if field keys is set (has been asigned a value) and false otherwise */
     public boolean isSetKeys() {
       return this.keys != null;
     }
 
     public void setKeysIsSet(boolean value) {
       if (!value) {
         this.keys = null;
       }
     }
 
     public ColumnPath getColumn_path() {
       return this.column_path;
     }
 
     public multiget_args setColumn_path(ColumnPath column_path) {
       this.column_path = column_path;
       return this;
     }
 
     public void unsetColumn_path() {
       this.column_path = null;
     }
 
     /** Returns true if field column_path is set (has been asigned a value) and false otherwise */
     public boolean isSetColumn_path() {
       return this.column_path != null;
     }
 
     public void setColumn_pathIsSet(boolean value) {
       if (!value) {
         this.column_path = null;
       }
     }
 
     /**
      * 
      * @see ConsistencyLevel
      */
     public ConsistencyLevel getConsistency_level() {
       return this.consistency_level;
     }
 
     /**
      * 
      * @see ConsistencyLevel
      */
     public multiget_args setConsistency_level(ConsistencyLevel consistency_level) {
       this.consistency_level = consistency_level;
       return this;
     }
 
     public void unsetConsistency_level() {
       this.consistency_level = null;
     }
 
     /** Returns true if field consistency_level is set (has been asigned a value) and false otherwise */
     public boolean isSetConsistency_level() {
       return this.consistency_level != null;
     }
 
     public void setConsistency_levelIsSet(boolean value) {
       if (!value) {
         this.consistency_level = null;
       }
     }
 
     public void setFieldValue(_Fields field, Object value) {
       switch (field) {
       case KEYSPACE:
         if (value == null) {
           unsetKeyspace();
         } else {
           setKeyspace((String)value);
         }
         break;
 
       case KEYS:
         if (value == null) {
           unsetKeys();
         } else {
           setKeys((List<byte[]>)value);
         }
         break;
 
       case COLUMN_PATH:
         if (value == null) {
           unsetColumn_path();
         } else {
           setColumn_path((ColumnPath)value);
         }
         break;
 
       case CONSISTENCY_LEVEL:
         if (value == null) {
           unsetConsistency_level();
         } else {
           setConsistency_level((ConsistencyLevel)value);
         }
         break;
 
       }
     }
 
     public void setFieldValue(int fieldID, Object value) {
       setFieldValue(_Fields.findByThriftIdOrThrow(fieldID), value);
     }
 
     public Object getFieldValue(_Fields field) {
       switch (field) {
       case KEYSPACE:
         return getKeyspace();
 
       case KEYS:
         return getKeys();
 
       case COLUMN_PATH:
         return getColumn_path();
 
       case CONSISTENCY_LEVEL:
         return getConsistency_level();
 
       }
       throw new IllegalStateException();
     }
 
     public Object getFieldValue(int fieldId) {
       return getFieldValue(_Fields.findByThriftIdOrThrow(fieldId));
     }
 
     /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
     public boolean isSet(_Fields field) {
       switch (field) {
       case KEYSPACE:
         return isSetKeyspace();
       case KEYS:
         return isSetKeys();
       case COLUMN_PATH:
         return isSetColumn_path();
       case CONSISTENCY_LEVEL:
         return isSetConsistency_level();
       }
       throw new IllegalStateException();
     }
 
     public boolean isSet(int fieldID) {
       return isSet(_Fields.findByThriftIdOrThrow(fieldID));
     }
 
     @Override
     public boolean equals(Object that) {
       if (that == null)
         return false;
       if (that instanceof multiget_args)
         return this.equals((multiget_args)that);
       return false;
     }
 
     public boolean equals(multiget_args that) {
       if (that == null)
         return false;
 
       boolean this_present_keyspace = true && this.isSetKeyspace();
       boolean that_present_keyspace = true && that.isSetKeyspace();
       if (this_present_keyspace || that_present_keyspace) {
         if (!(this_present_keyspace && that_present_keyspace))
           return false;
         if (!this.keyspace.equals(that.keyspace))
           return false;
       }
 
       boolean this_present_keys = true && this.isSetKeys();
       boolean that_present_keys = true && that.isSetKeys();
       if (this_present_keys || that_present_keys) {
         if (!(this_present_keys && that_present_keys))
           return false;
         if (!this.keys.equals(that.keys))
           return false;
       }
 
       boolean this_present_column_path = true && this.isSetColumn_path();
       boolean that_present_column_path = true && that.isSetColumn_path();
       if (this_present_column_path || that_present_column_path) {
         if (!(this_present_column_path && that_present_column_path))
           return false;
         if (!this.column_path.equals(that.column_path))
           return false;
       }
 
       boolean this_present_consistency_level = true && this.isSetConsistency_level();
       boolean that_present_consistency_level = true && that.isSetConsistency_level();
       if (this_present_consistency_level || that_present_consistency_level) {
         if (!(this_present_consistency_level && that_present_consistency_level))
           return false;
         if (!this.consistency_level.equals(that.consistency_level))
           return false;
       }
 
       return true;
     }
 
     @Override
     public int hashCode() {
       return 0;
     }
 
     public int compareTo(multiget_args other) {
       if (!getClass().equals(other.getClass())) {
         return getClass().getName().compareTo(other.getClass().getName());
       }
 
       int lastComparison = 0;
       multiget_args typedOther = (multiget_args)other;
 
       lastComparison = Boolean.valueOf(isSetKeyspace()).compareTo(typedOther.isSetKeyspace());
       if (lastComparison != 0) {
         return lastComparison;
       }
       if (isSetKeyspace()) {        lastComparison = TBaseHelper.compareTo(keyspace, typedOther.keyspace);
         if (lastComparison != 0) {
           return lastComparison;
         }
       }
       lastComparison = Boolean.valueOf(isSetKeys()).compareTo(typedOther.isSetKeys());
       if (lastComparison != 0) {
         return lastComparison;
       }
       if (isSetKeys()) {        lastComparison = TBaseHelper.compareTo(keys, typedOther.keys);
         if (lastComparison != 0) {
           return lastComparison;
         }
       }
       lastComparison = Boolean.valueOf(isSetColumn_path()).compareTo(typedOther.isSetColumn_path());
       if (lastComparison != 0) {
         return lastComparison;
       }
       if (isSetColumn_path()) {        lastComparison = TBaseHelper.compareTo(column_path, typedOther.column_path);
         if (lastComparison != 0) {
           return lastComparison;
         }
       }
       lastComparison = Boolean.valueOf(isSetConsistency_level()).compareTo(typedOther.isSetConsistency_level());
       if (lastComparison != 0) {
         return lastComparison;
       }
       if (isSetConsistency_level()) {        lastComparison = TBaseHelper.compareTo(consistency_level, typedOther.consistency_level);
         if (lastComparison != 0) {
           return lastComparison;
         }
       }
       return 0;
     }
 
     public void read(TProtocol iprot) throws TException {
       TField field;
       iprot.readStructBegin();
       while (true)
       {
         field = iprot.readFieldBegin();
         if (field.type == TType.STOP) { 
           break;
         }
         switch (field.id) {
           case 1: // KEYSPACE
             if (field.type == TType.STRING) {
               this.keyspace = iprot.readString();
             } else { 
               TProtocolUtil.skip(iprot, field.type);
             }
             break;
           case 2: // KEYS
             if (field.type == TType.LIST) {
               {
                 TList _list33 = iprot.readListBegin();
                 this.keys = new ArrayList<byte[]>(_list33.size);
                 for (int _i34 = 0; _i34 < _list33.size; ++_i34)
                 {
                   byte[] _elem35;
                   _elem35 = iprot.readBinary();
                   this.keys.add(_elem35);
                 }
                 iprot.readListEnd();
               }
             } else { 
               TProtocolUtil.skip(iprot, field.type);
             }
             break;
           case 3: // COLUMN_PATH
             if (field.type == TType.STRUCT) {
               this.column_path = new ColumnPath();
               this.column_path.read(iprot);
             } else { 
               TProtocolUtil.skip(iprot, field.type);
             }
             break;
           case 4: // CONSISTENCY_LEVEL
             if (field.type == TType.I32) {
               this.consistency_level = ConsistencyLevel.findByValue(iprot.readI32());
             } else { 
               TProtocolUtil.skip(iprot, field.type);
             }
             break;
           default:
             TProtocolUtil.skip(iprot, field.type);
         }
         iprot.readFieldEnd();
       }
       iprot.readStructEnd();
 
       // check for required fields of primitive type, which can't be checked in the validate method
       validate();
     }
 
     public void write(TProtocol oprot) throws TException {
       validate();
 
       oprot.writeStructBegin(STRUCT_DESC);
       if (this.keyspace != null) {
         oprot.writeFieldBegin(KEYSPACE_FIELD_DESC);
         oprot.writeString(this.keyspace);
         oprot.writeFieldEnd();
       }
       if (this.keys != null) {
         oprot.writeFieldBegin(KEYS_FIELD_DESC);
         {
           oprot.writeListBegin(new TList(TType.STRING, this.keys.size()));
           for (byte[] _iter36 : this.keys)
           {
             oprot.writeBinary(_iter36);
           }
           oprot.writeListEnd();
         }
         oprot.writeFieldEnd();
       }
       if (this.column_path != null) {
         oprot.writeFieldBegin(COLUMN_PATH_FIELD_DESC);
         this.column_path.write(oprot);
         oprot.writeFieldEnd();
       }
       if (this.consistency_level != null) {
         oprot.writeFieldBegin(CONSISTENCY_LEVEL_FIELD_DESC);
         oprot.writeI32(this.consistency_level.getValue());
         oprot.writeFieldEnd();
       }
       oprot.writeFieldStop();
       oprot.writeStructEnd();
     }
 
     @Override
     public String toString() {
       StringBuilder sb = new StringBuilder("multiget_args(");
       boolean first = true;
 
       sb.append("keyspace:");
       if (this.keyspace == null) {
         sb.append("null");
       } else {
         sb.append(this.keyspace);
       }
       first = false;
       if (!first) sb.append(", ");
       sb.append("keys:");
       if (this.keys == null) {
         sb.append("null");
       } else {
         sb.append(this.keys);
       }
       first = false;
       if (!first) sb.append(", ");
       sb.append("column_path:");
       if (this.column_path == null) {
         sb.append("null");
       } else {
         sb.append(this.column_path);
       }
       first = false;
       if (!first) sb.append(", ");
       sb.append("consistency_level:");
       if (this.consistency_level == null) {
         sb.append("null");
       } else {
         sb.append(this.consistency_level);
       }
       first = false;
       sb.append(")");
       return sb.toString();
     }
 
     public void validate() throws TException {
       // check for required fields
       if (keyspace == null) {
         throw new TProtocolException("Required field 'keyspace' was not present! Struct: " + toString());
       }
       if (keys == null) {
         throw new TProtocolException("Required field 'keys' was not present! Struct: " + toString());
       }
       if (column_path == null) {
         throw new TProtocolException("Required field 'column_path' was not present! Struct: " + toString());
       }
       if (consistency_level == null) {
         throw new TProtocolException("Required field 'consistency_level' was not present! Struct: " + toString());
       }
     }
 
   }
 
   public static class multiget_result implements TBase<multiget_result._Fields>, java.io.Serializable, Cloneable   {
     private static final TStruct STRUCT_DESC = new TStruct("multiget_result");
 
     private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.MAP, (short)0);
     private static final TField IRE_FIELD_DESC = new TField("ire", TType.STRUCT, (short)1);
     private static final TField UE_FIELD_DESC = new TField("ue", TType.STRUCT, (short)2);
     private static final TField TE_FIELD_DESC = new TField("te", TType.STRUCT, (short)3);
 
     public Map<byte[],ColumnOrSuperColumn> success;
     public InvalidRequestException ire;
     public UnavailableException ue;
     public TimedOutException te;
 
     /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
     public enum _Fields implements TFieldIdEnum {
       SUCCESS((short)0, "success"),
       IRE((short)1, "ire"),
       UE((short)2, "ue"),
       TE((short)3, "te");
 
       private static final Map<Integer, _Fields> byId = new HashMap<Integer, _Fields>();
       private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();
 
       static {
         for (_Fields field : EnumSet.allOf(_Fields.class)) {
           byId.put((int)field._thriftId, field);
           byName.put(field.getFieldName(), field);
         }
       }
 
       /**
        * Find the _Fields constant that matches fieldId, or null if its not found.
        */
       public static _Fields findByThriftId(int fieldId) {
         return byId.get(fieldId);
       }
 
       /**
        * Find the _Fields constant that matches fieldId, throwing an exception
        * if it is not found.
        */
       public static _Fields findByThriftIdOrThrow(int fieldId) {
         _Fields fields = findByThriftId(fieldId);
         if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
         return fields;
       }
 
       /**
        * Find the _Fields constant that matches name, or null if its not found.
        */
       public static _Fields findByName(String name) {
         return byName.get(name);
       }
 
       private final short _thriftId;
       private final String _fieldName;
 
       _Fields(short thriftId, String fieldName) {
         _thriftId = thriftId;
         _fieldName = fieldName;
       }
 
       public short getThriftFieldId() {
         return _thriftId;
       }
 
       public String getFieldName() {
         return _fieldName;
       }
     }
 
     // isset id assignments
 
     public static final Map<_Fields, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new EnumMap<_Fields, FieldMetaData>(_Fields.class) {{
       put(_Fields.SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
           new MapMetaData(TType.MAP, 
               new FieldValueMetaData(TType.STRING), 
               new StructMetaData(TType.STRUCT, ColumnOrSuperColumn.class))));
       put(_Fields.IRE, new FieldMetaData("ire", TFieldRequirementType.DEFAULT, 
           new FieldValueMetaData(TType.STRUCT)));
       put(_Fields.UE, new FieldMetaData("ue", TFieldRequirementType.DEFAULT, 
           new FieldValueMetaData(TType.STRUCT)));
       put(_Fields.TE, new FieldMetaData("te", TFieldRequirementType.DEFAULT, 
           new FieldValueMetaData(TType.STRUCT)));
     }});
 
     static {
       FieldMetaData.addStructMetaDataMap(multiget_result.class, metaDataMap);
     }
 
     public multiget_result() {
     }
 
     public multiget_result(
       Map<byte[],ColumnOrSuperColumn> success,
       InvalidRequestException ire,
       UnavailableException ue,
       TimedOutException te)
     {
       this();
       this.success = success;
       this.ire = ire;
       this.ue = ue;
       this.te = te;
     }
 
     /**
      * Performs a deep copy on <i>other</i>.
      */
     public multiget_result(multiget_result other) {
       if (other.isSetSuccess()) {
         Map<byte[],ColumnOrSuperColumn> __this__success = new HashMap<byte[],ColumnOrSuperColumn>();
         for (Map.Entry<byte[], ColumnOrSuperColumn> other_element : other.success.entrySet()) {
 
           byte[] other_element_key = other_element.getKey();
           ColumnOrSuperColumn other_element_value = other_element.getValue();
 
           byte[] __this__success_copy_key = new byte[other_element_key.length];
           System.arraycopy(other_element_key, 0, __this__success_copy_key, 0, other_element_key.length);
 
           ColumnOrSuperColumn __this__success_copy_value = new ColumnOrSuperColumn(other_element_value);
 
           __this__success.put(__this__success_copy_key, __this__success_copy_value);
         }
         this.success = __this__success;
       }
       if (other.isSetIre()) {
         this.ire = new InvalidRequestException(other.ire);
       }
       if (other.isSetUe()) {
         this.ue = new UnavailableException(other.ue);
       }
       if (other.isSetTe()) {
         this.te = new TimedOutException(other.te);
       }
     }
 
     public multiget_result deepCopy() {
       return new multiget_result(this);
     }
 
     @Deprecated
     public multiget_result clone() {
       return new multiget_result(this);
     }
 
     public int getSuccessSize() {
       return (this.success == null) ? 0 : this.success.size();
     }
 
     public void putToSuccess(byte[] key, ColumnOrSuperColumn val) {
       if (this.success == null) {
         this.success = new HashMap<byte[],ColumnOrSuperColumn>();
       }
       this.success.put(key, val);
     }
 
     public Map<byte[],ColumnOrSuperColumn> getSuccess() {
       return this.success;
     }
 
     public multiget_result setSuccess(Map<byte[],ColumnOrSuperColumn> success) {
       this.success = success;
       return this;
     }
 
     public void unsetSuccess() {
       this.success = null;
     }
 
     /** Returns true if field success is set (has been asigned a value) and false otherwise */
     public boolean isSetSuccess() {
       return this.success != null;
     }
 
     public void setSuccessIsSet(boolean value) {
       if (!value) {
         this.success = null;
       }
     }
 
     public InvalidRequestException getIre() {
       return this.ire;
     }
 
     public multiget_result setIre(InvalidRequestException ire) {
       this.ire = ire;
       return this;
     }
 
     public void unsetIre() {
       this.ire = null;
     }
 
     /** Returns true if field ire is set (has been asigned a value) and false otherwise */
     public boolean isSetIre() {
       return this.ire != null;
     }
 
     public void setIreIsSet(boolean value) {
       if (!value) {
         this.ire = null;
       }
     }
 
     public UnavailableException getUe() {
       return this.ue;
     }
 
     public multiget_result setUe(UnavailableException ue) {
       this.ue = ue;
       return this;
     }
 
     public void unsetUe() {
       this.ue = null;
     }
 
     /** Returns true if field ue is set (has been asigned a value) and false otherwise */
     public boolean isSetUe() {
       return this.ue != null;
     }
 
     public void setUeIsSet(boolean value) {
       if (!value) {
         this.ue = null;
       }
     }
 
     public TimedOutException getTe() {
       return this.te;
     }
 
     public multiget_result setTe(TimedOutException te) {
       this.te = te;
       return this;
     }
 
     public void unsetTe() {
       this.te = null;
     }
 
     /** Returns true if field te is set (has been asigned a value) and false otherwise */
     public boolean isSetTe() {
       return this.te != null;
     }
 
     public void setTeIsSet(boolean value) {
       if (!value) {
         this.te = null;
       }
     }
 
     public void setFieldValue(_Fields field, Object value) {
       switch (field) {
       case SUCCESS:
         if (value == null) {
           unsetSuccess();
         } else {
           setSuccess((Map<byte[],ColumnOrSuperColumn>)value);
         }
         break;
 
       case IRE:
         if (value == null) {
           unsetIre();
         } else {
           setIre((InvalidRequestException)value);
         }
         break;
 
       case UE:
         if (value == null) {
           unsetUe();
         } else {
           setUe((UnavailableException)value);
         }
         break;
 
       case TE:
         if (value == null) {
           unsetTe();
         } else {
           setTe((TimedOutException)value);
         }
         break;
 
       }
     }
 
     public void setFieldValue(int fieldID, Object value) {
       setFieldValue(_Fields.findByThriftIdOrThrow(fieldID), value);
     }
 
     public Object getFieldValue(_Fields field) {
       switch (field) {
       case SUCCESS:
         return getSuccess();
 
       case IRE:
         return getIre();
 
       case UE:
         return getUe();
 
       case TE:
         return getTe();
 
       }
       throw new IllegalStateException();
     }
 
     public Object getFieldValue(int fieldId) {
       return getFieldValue(_Fields.findByThriftIdOrThrow(fieldId));
     }
 
     /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
     public boolean isSet(_Fields field) {
       switch (field) {
       case SUCCESS:
         return isSetSuccess();
       case IRE:
         return isSetIre();
       case UE:
         return isSetUe();
       case TE:
         return isSetTe();
       }
       throw new IllegalStateException();
     }
 
     public boolean isSet(int fieldID) {
       return isSet(_Fields.findByThriftIdOrThrow(fieldID));
     }
 
     @Override
     public boolean equals(Object that) {
       if (that == null)
         return false;
       if (that instanceof multiget_result)
         return this.equals((multiget_result)that);
       return false;
     }
 
     public boolean equals(multiget_result that) {
       if (that == null)
         return false;
 
       boolean this_present_success = true && this.isSetSuccess();
       boolean that_present_success = true && that.isSetSuccess();
       if (this_present_success || that_present_success) {
         if (!(this_present_success && that_present_success))
           return false;
         if (!this.success.equals(that.success))
           return false;
       }
 
       boolean this_present_ire = true && this.isSetIre();
       boolean that_present_ire = true && that.isSetIre();
       if (this_present_ire || that_present_ire) {
         if (!(this_present_ire && that_present_ire))
           return false;
         if (!this.ire.equals(that.ire))
           return false;
       }
 
       boolean this_present_ue = true && this.isSetUe();
       boolean that_present_ue = true && that.isSetUe();
       if (this_present_ue || that_present_ue) {
         if (!(this_present_ue && that_present_ue))
           return false;
         if (!this.ue.equals(that.ue))
           return false;
       }
 
       boolean this_present_te = true && this.isSetTe();
       boolean that_present_te = true && that.isSetTe();
       if (this_present_te || that_present_te) {
         if (!(this_present_te && that_present_te))
           return false;
         if (!this.te.equals(that.te))
           return false;
       }
 
       return true;
     }
 
     @Override
     public int hashCode() {
       return 0;
     }
 
     public void read(TProtocol iprot) throws TException {
       TField field;
       iprot.readStructBegin();
       while (true)
       {
         field = iprot.readFieldBegin();
         if (field.type == TType.STOP) { 
           break;
         }
         switch (field.id) {
           case 0: // SUCCESS
             if (field.type == TType.MAP) {
               {
                 TMap _map37 = iprot.readMapBegin();
                 this.success = new HashMap<byte[],ColumnOrSuperColumn>(2*_map37.size);
                 for (int _i38 = 0; _i38 < _map37.size; ++_i38)
                 {
                   byte[] _key39;
                   ColumnOrSuperColumn _val40;
                   _key39 = iprot.readBinary();
                   _val40 = new ColumnOrSuperColumn();
                   _val40.read(iprot);
                   this.success.put(_key39, _val40);
                 }
                 iprot.readMapEnd();
               }
             } else { 
               TProtocolUtil.skip(iprot, field.type);
             }
             break;
           case 1: // IRE
             if (field.type == TType.STRUCT) {
               this.ire = new InvalidRequestException();
               this.ire.read(iprot);
             } else { 
               TProtocolUtil.skip(iprot, field.type);
             }
             break;
           case 2: // UE
             if (field.type == TType.STRUCT) {
               this.ue = new UnavailableException();
               this.ue.read(iprot);
             } else { 
               TProtocolUtil.skip(iprot, field.type);
             }
             break;
           case 3: // TE
             if (field.type == TType.STRUCT) {
               this.te = new TimedOutException();
               this.te.read(iprot);
             } else { 
               TProtocolUtil.skip(iprot, field.type);
             }
             break;
           default:
             TProtocolUtil.skip(iprot, field.type);
         }
         iprot.readFieldEnd();
       }
       iprot.readStructEnd();
 
       // check for required fields of primitive type, which can't be checked in the validate method
       validate();
     }
 
     public void write(TProtocol oprot) throws TException {
       oprot.writeStructBegin(STRUCT_DESC);
 
       if (this.isSetSuccess()) {
         oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
         {
           oprot.writeMapBegin(new TMap(TType.STRING, TType.STRUCT, this.success.size()));
           for (Map.Entry<byte[], ColumnOrSuperColumn> _iter41 : this.success.entrySet())
           {
             oprot.writeBinary(_iter41.getKey());
             _iter41.getValue().write(oprot);
           }
           oprot.writeMapEnd();
         }
         oprot.writeFieldEnd();
       } else if (this.isSetIre()) {
         oprot.writeFieldBegin(IRE_FIELD_DESC);
         this.ire.write(oprot);
         oprot.writeFieldEnd();
       } else if (this.isSetUe()) {
         oprot.writeFieldBegin(UE_FIELD_DESC);
         this.ue.write(oprot);
         oprot.writeFieldEnd();
       } else if (this.isSetTe()) {
         oprot.writeFieldBegin(TE_FIELD_DESC);
         this.te.write(oprot);
         oprot.writeFieldEnd();
       }
       oprot.writeFieldStop();
       oprot.writeStructEnd();
     }
 
     @Override
     public String toString() {
       StringBuilder sb = new StringBuilder("multiget_result(");
       boolean first = true;
 
       sb.append("success:");
       if (this.success == null) {
         sb.append("null");
       } else {
         sb.append(this.success);
       }
       first = false;
       if (!first) sb.append(", ");
       sb.append("ire:");
       if (this.ire == null) {
         sb.append("null");
       } else {
         sb.append(this.ire);
       }
       first = false;
       if (!first) sb.append(", ");
       sb.append("ue:");
       if (this.ue == null) {
         sb.append("null");
       } else {
         sb.append(this.ue);
       }
       first = false;
       if (!first) sb.append(", ");
       sb.append("te:");
       if (this.te == null) {
         sb.append("null");
       } else {
         sb.append(this.te);
       }
       first = false;
       sb.append(")");
       return sb.toString();
     }
 
     public void validate() throws TException {
       // check for required fields
     }
 
   }
 
   public static class multiget_slice_args implements TBase<multiget_slice_args._Fields>, java.io.Serializable, Cloneable, Comparable<multiget_slice_args>   {
     private static final TStruct STRUCT_DESC = new TStruct("multiget_slice_args");
 
     private static final TField KEYSPACE_FIELD_DESC = new TField("keyspace", TType.STRING, (short)1);
     private static final TField KEYS_FIELD_DESC = new TField("keys", TType.LIST, (short)2);
     private static final TField COLUMN_PARENT_FIELD_DESC = new TField("column_parent", TType.STRUCT, (short)3);
     private static final TField PREDICATE_FIELD_DESC = new TField("predicate", TType.STRUCT, (short)4);
     private static final TField CONSISTENCY_LEVEL_FIELD_DESC = new TField("consistency_level", TType.I32, (short)5);
 
     public String keyspace;
     public List<byte[]> keys;
     public ColumnParent column_parent;
     public SlicePredicate predicate;
     /**
      * 
      * @see ConsistencyLevel
      */
     public ConsistencyLevel consistency_level;
 
     /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
     public enum _Fields implements TFieldIdEnum {
       KEYSPACE((short)1, "keyspace"),
       KEYS((short)2, "keys"),
       COLUMN_PARENT((short)3, "column_parent"),
       PREDICATE((short)4, "predicate"),
       /**
        * 
        * @see ConsistencyLevel
        */
       CONSISTENCY_LEVEL((short)5, "consistency_level");
 
       private static final Map<Integer, _Fields> byId = new HashMap<Integer, _Fields>();
       private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();
 
       static {
         for (_Fields field : EnumSet.allOf(_Fields.class)) {
           byId.put((int)field._thriftId, field);
           byName.put(field.getFieldName(), field);
         }
       }
 
       /**
        * Find the _Fields constant that matches fieldId, or null if its not found.
        */
       public static _Fields findByThriftId(int fieldId) {
         return byId.get(fieldId);
       }
 
       /**
        * Find the _Fields constant that matches fieldId, throwing an exception
        * if it is not found.
        */
       public static _Fields findByThriftIdOrThrow(int fieldId) {
         _Fields fields = findByThriftId(fieldId);
         if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
         return fields;
       }
 
       /**
        * Find the _Fields constant that matches name, or null if its not found.
        */
       public static _Fields findByName(String name) {
         return byName.get(name);
       }
 
       private final short _thriftId;
       private final String _fieldName;
 
       _Fields(short thriftId, String fieldName) {
         _thriftId = thriftId;
         _fieldName = fieldName;
       }
 
       public short getThriftFieldId() {
         return _thriftId;
       }
 
       public String getFieldName() {
         return _fieldName;
       }
     }
 
     // isset id assignments
 
     public static final Map<_Fields, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new EnumMap<_Fields, FieldMetaData>(_Fields.class) {{
       put(_Fields.KEYSPACE, new FieldMetaData("keyspace", TFieldRequirementType.REQUIRED, 
           new FieldValueMetaData(TType.STRING)));
       put(_Fields.KEYS, new FieldMetaData("keys", TFieldRequirementType.REQUIRED, 
           new ListMetaData(TType.LIST, 
               new FieldValueMetaData(TType.STRING))));
       put(_Fields.COLUMN_PARENT, new FieldMetaData("column_parent", TFieldRequirementType.REQUIRED, 
           new StructMetaData(TType.STRUCT, ColumnParent.class)));
       put(_Fields.PREDICATE, new FieldMetaData("predicate", TFieldRequirementType.REQUIRED, 
           new StructMetaData(TType.STRUCT, SlicePredicate.class)));
       put(_Fields.CONSISTENCY_LEVEL, new FieldMetaData("consistency_level", TFieldRequirementType.REQUIRED, 
           new EnumMetaData(TType.ENUM, ConsistencyLevel.class)));
     }});
 
     static {
       FieldMetaData.addStructMetaDataMap(multiget_slice_args.class, metaDataMap);
     }
 
     public multiget_slice_args() {
       this.consistency_level = ConsistencyLevel.ONE;
 
     }
 
     public multiget_slice_args(
       String keyspace,
       List<byte[]> keys,
       ColumnParent column_parent,
       SlicePredicate predicate,
       ConsistencyLevel consistency_level)
     {
       this();
       this.keyspace = keyspace;
       this.keys = keys;
       this.column_parent = column_parent;
       this.predicate = predicate;
       this.consistency_level = consistency_level;
     }
 
     /**
      * Performs a deep copy on <i>other</i>.
      */
     public multiget_slice_args(multiget_slice_args other) {
       if (other.isSetKeyspace()) {
         this.keyspace = other.keyspace;
       }
       if (other.isSetKeys()) {
         List<byte[]> __this__keys = new ArrayList<byte[]>();
         for (byte[] other_element : other.keys) {
           byte[] temp_binary_element = new byte[other_element.length];
           System.arraycopy(other_element, 0, temp_binary_element, 0, other_element.length);
           __this__keys.add(temp_binary_element);
         }
         this.keys = __this__keys;
       }
       if (other.isSetColumn_parent()) {
         this.column_parent = new ColumnParent(other.column_parent);
       }
       if (other.isSetPredicate()) {
         this.predicate = new SlicePredicate(other.predicate);
       }
       if (other.isSetConsistency_level()) {
         this.consistency_level = other.consistency_level;
       }
     }
 
     public multiget_slice_args deepCopy() {
       return new multiget_slice_args(this);
     }
 
     @Deprecated
     public multiget_slice_args clone() {
       return new multiget_slice_args(this);
     }
 
     public String getKeyspace() {
       return this.keyspace;
     }
 
     public multiget_slice_args setKeyspace(String keyspace) {
       this.keyspace = keyspace;
       return this;
     }
 
     public void unsetKeyspace() {
       this.keyspace = null;
     }
 
     /** Returns true if field keyspace is set (has been asigned a value) and false otherwise */
     public boolean isSetKeyspace() {
       return this.keyspace != null;
     }
 
     public void setKeyspaceIsSet(boolean value) {
       if (!value) {
         this.keyspace = null;
       }
     }
 
     public int getKeysSize() {
       return (this.keys == null) ? 0 : this.keys.size();
     }
 
     public java.util.Iterator<byte[]> getKeysIterator() {
       return (this.keys == null) ? null : this.keys.iterator();
     }
 
     public void addToKeys(byte[] elem) {
       if (this.keys == null) {
         this.keys = new ArrayList<byte[]>();
       }
       this.keys.add(elem);
     }
 
     public List<byte[]> getKeys() {
       return this.keys;
     }
 
     public multiget_slice_args setKeys(List<byte[]> keys) {
       this.keys = keys;
       return this;
     }
 
     public void unsetKeys() {
       this.keys = null;
     }
 
     /** Returns true if field keys is set (has been asigned a value) and false otherwise */
     public boolean isSetKeys() {
       return this.keys != null;
     }
 
     public void setKeysIsSet(boolean value) {
       if (!value) {
         this.keys = null;
       }
     }
 
     public ColumnParent getColumn_parent() {
       return this.column_parent;
     }
 
     public multiget_slice_args setColumn_parent(ColumnParent column_parent) {
       this.column_parent = column_parent;
       return this;
     }
 
     public void unsetColumn_parent() {
       this.column_parent = null;
     }
 
     /** Returns true if field column_parent is set (has been asigned a value) and false otherwise */
     public boolean isSetColumn_parent() {
       return this.column_parent != null;
     }
 
     public void setColumn_parentIsSet(boolean value) {
       if (!value) {
         this.column_parent = null;
       }
     }
 
     public SlicePredicate getPredicate() {
       return this.predicate;
     }
 
     public multiget_slice_args setPredicate(SlicePredicate predicate) {
       this.predicate = predicate;
       return this;
     }
 
     public void unsetPredicate() {
       this.predicate = null;
     }
 
     /** Returns true if field predicate is set (has been asigned a value) and false otherwise */
     public boolean isSetPredicate() {
       return this.predicate != null;
     }
 
     public void setPredicateIsSet(boolean value) {
       if (!value) {
         this.predicate = null;
       }
     }
 
     /**
      * 
      * @see ConsistencyLevel
      */
     public ConsistencyLevel getConsistency_level() {
       return this.consistency_level;
     }
 
     /**
      * 
      * @see ConsistencyLevel
      */
     public multiget_slice_args setConsistency_level(ConsistencyLevel consistency_level) {
       this.consistency_level = consistency_level;
       return this;
     }
 
     public void unsetConsistency_level() {
       this.consistency_level = null;
     }
 
     /** Returns true if field consistency_level is set (has been asigned a value) and false otherwise */
     public boolean isSetConsistency_level() {
       return this.consistency_level != null;
     }
 
     public void setConsistency_levelIsSet(boolean value) {
       if (!value) {
         this.consistency_level = null;
       }
     }
 
     public void setFieldValue(_Fields field, Object value) {
       switch (field) {
       case KEYSPACE:
         if (value == null) {
           unsetKeyspace();
         } else {
           setKeyspace((String)value);
         }
         break;
 
       case KEYS:
         if (value == null) {
           unsetKeys();
         } else {
           setKeys((List<byte[]>)value);
         }
         break;
 
       case COLUMN_PARENT:
         if (value == null) {
           unsetColumn_parent();
         } else {
           setColumn_parent((ColumnParent)value);
         }
         break;
 
       case PREDICATE:
         if (value == null) {
           unsetPredicate();
         } else {
           setPredicate((SlicePredicate)value);
         }
         break;
 
       case CONSISTENCY_LEVEL:
         if (value == null) {
           unsetConsistency_level();
         } else {
           setConsistency_level((ConsistencyLevel)value);
         }
         break;
 
       }
     }
 
     public void setFieldValue(int fieldID, Object value) {
       setFieldValue(_Fields.findByThriftIdOrThrow(fieldID), value);
     }
 
     public Object getFieldValue(_Fields field) {
       switch (field) {
       case KEYSPACE:
         return getKeyspace();
 
       case KEYS:
         return getKeys();
 
       case COLUMN_PARENT:
         return getColumn_parent();
 
       case PREDICATE:
         return getPredicate();
 
       case CONSISTENCY_LEVEL:
         return getConsistency_level();
 
       }
       throw new IllegalStateException();
     }
 
     public Object getFieldValue(int fieldId) {
       return getFieldValue(_Fields.findByThriftIdOrThrow(fieldId));
     }
 
     /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
     public boolean isSet(_Fields field) {
       switch (field) {
       case KEYSPACE:
         return isSetKeyspace();
       case KEYS:
         return isSetKeys();
       case COLUMN_PARENT:
         return isSetColumn_parent();
       case PREDICATE:
         return isSetPredicate();
       case CONSISTENCY_LEVEL:
         return isSetConsistency_level();
       }
       throw new IllegalStateException();
     }
 
     public boolean isSet(int fieldID) {
       return isSet(_Fields.findByThriftIdOrThrow(fieldID));
     }
 
     @Override
     public boolean equals(Object that) {
       if (that == null)
         return false;
       if (that instanceof multiget_slice_args)
         return this.equals((multiget_slice_args)that);
       return false;
     }
 
     public boolean equals(multiget_slice_args that) {
       if (that == null)
         return false;
 
       boolean this_present_keyspace = true && this.isSetKeyspace();
       boolean that_present_keyspace = true && that.isSetKeyspace();
       if (this_present_keyspace || that_present_keyspace) {
         if (!(this_present_keyspace && that_present_keyspace))
           return false;
         if (!this.keyspace.equals(that.keyspace))
           return false;
       }
 
       boolean this_present_keys = true && this.isSetKeys();
       boolean that_present_keys = true && that.isSetKeys();
       if (this_present_keys || that_present_keys) {
         if (!(this_present_keys && that_present_keys))
           return false;
         if (!this.keys.equals(that.keys))
           return false;
       }
 
       boolean this_present_column_parent = true && this.isSetColumn_parent();
       boolean that_present_column_parent = true && that.isSetColumn_parent();
       if (this_present_column_parent || that_present_column_parent) {
         if (!(this_present_column_parent && that_present_column_parent))
           return false;
         if (!this.column_parent.equals(that.column_parent))
           return false;
       }
 
       boolean this_present_predicate = true && this.isSetPredicate();
       boolean that_present_predicate = true && that.isSetPredicate();
       if (this_present_predicate || that_present_predicate) {
         if (!(this_present_predicate && that_present_predicate))
           return false;
         if (!this.predicate.equals(that.predicate))
           return false;
       }
 
       boolean this_present_consistency_level = true && this.isSetConsistency_level();
       boolean that_present_consistency_level = true && that.isSetConsistency_level();
       if (this_present_consistency_level || that_present_consistency_level) {
         if (!(this_present_consistency_level && that_present_consistency_level))
           return false;
         if (!this.consistency_level.equals(that.consistency_level))
           return false;
       }
 
       return true;
     }
 
     @Override
     public int hashCode() {
       return 0;
     }
 
     public int compareTo(multiget_slice_args other) {
       if (!getClass().equals(other.getClass())) {
         return getClass().getName().compareTo(other.getClass().getName());
       }
 
       int lastComparison = 0;
       multiget_slice_args typedOther = (multiget_slice_args)other;
 
       lastComparison = Boolean.valueOf(isSetKeyspace()).compareTo(typedOther.isSetKeyspace());
       if (lastComparison != 0) {
         return lastComparison;
       }
       if (isSetKeyspace()) {        lastComparison = TBaseHelper.compareTo(keyspace, typedOther.keyspace);
         if (lastComparison != 0) {
           return lastComparison;
         }
       }
       lastComparison = Boolean.valueOf(isSetKeys()).compareTo(typedOther.isSetKeys());
       if (lastComparison != 0) {
         return lastComparison;
       }
       if (isSetKeys()) {        lastComparison = TBaseHelper.compareTo(keys, typedOther.keys);
         if (lastComparison != 0) {
           return lastComparison;
         }
       }
       lastComparison = Boolean.valueOf(isSetColumn_parent()).compareTo(typedOther.isSetColumn_parent());
       if (lastComparison != 0) {
         return lastComparison;
       }
       if (isSetColumn_parent()) {        lastComparison = TBaseHelper.compareTo(column_parent, typedOther.column_parent);
         if (lastComparison != 0) {
           return lastComparison;
         }
       }
       lastComparison = Boolean.valueOf(isSetPredicate()).compareTo(typedOther.isSetPredicate());
       if (lastComparison != 0) {
         return lastComparison;
       }
       if (isSetPredicate()) {        lastComparison = TBaseHelper.compareTo(predicate, typedOther.predicate);
         if (lastComparison != 0) {
           return lastComparison;
         }
       }
       lastComparison = Boolean.valueOf(isSetConsistency_level()).compareTo(typedOther.isSetConsistency_level());
       if (lastComparison != 0) {
         return lastComparison;
       }
       if (isSetConsistency_level()) {        lastComparison = TBaseHelper.compareTo(consistency_level, typedOther.consistency_level);
         if (lastComparison != 0) {
           return lastComparison;
         }
       }
       return 0;
     }
 
     public void read(TProtocol iprot) throws TException {
       TField field;
       iprot.readStructBegin();
       while (true)
       {
         field = iprot.readFieldBegin();
         if (field.type == TType.STOP) { 
           break;
         }
         switch (field.id) {
           case 1: // KEYSPACE
             if (field.type == TType.STRING) {
               this.keyspace = iprot.readString();
             } else { 
               TProtocolUtil.skip(iprot, field.type);
             }
             break;
           case 2: // KEYS
             if (field.type == TType.LIST) {
               {
                 TList _list42 = iprot.readListBegin();
                 this.keys = new ArrayList<byte[]>(_list42.size);
                 for (int _i43 = 0; _i43 < _list42.size; ++_i43)
                 {
                   byte[] _elem44;
                   _elem44 = iprot.readBinary();
                   this.keys.add(_elem44);
                 }
                 iprot.readListEnd();
               }
             } else { 
               TProtocolUtil.skip(iprot, field.type);
             }
             break;
           case 3: // COLUMN_PARENT
             if (field.type == TType.STRUCT) {
               this.column_parent = new ColumnParent();
               this.column_parent.read(iprot);
             } else { 
               TProtocolUtil.skip(iprot, field.type);
             }
             break;
           case 4: // PREDICATE
             if (field.type == TType.STRUCT) {
               this.predicate = new SlicePredicate();
               this.predicate.read(iprot);
             } else { 
               TProtocolUtil.skip(iprot, field.type);
             }
             break;
           case 5: // CONSISTENCY_LEVEL
             if (field.type == TType.I32) {
               this.consistency_level = ConsistencyLevel.findByValue(iprot.readI32());
             } else { 
               TProtocolUtil.skip(iprot, field.type);
             }
             break;
           default:
             TProtocolUtil.skip(iprot, field.type);
         }
         iprot.readFieldEnd();
       }
       iprot.readStructEnd();
 
       // check for required fields of primitive type, which can't be checked in the validate method
       validate();
     }
 
     public void write(TProtocol oprot) throws TException {
       validate();
 
       oprot.writeStructBegin(STRUCT_DESC);
       if (this.keyspace != null) {
         oprot.writeFieldBegin(KEYSPACE_FIELD_DESC);
         oprot.writeString(this.keyspace);
         oprot.writeFieldEnd();
       }
       if (this.keys != null) {
         oprot.writeFieldBegin(KEYS_FIELD_DESC);
         {
           oprot.writeListBegin(new TList(TType.STRING, this.keys.size()));
           for (byte[] _iter45 : this.keys)
           {
             oprot.writeBinary(_iter45);
           }
           oprot.writeListEnd();
         }
         oprot.writeFieldEnd();
       }
       if (this.column_parent != null) {
         oprot.writeFieldBegin(COLUMN_PARENT_FIELD_DESC);
         this.column_parent.write(oprot);
         oprot.writeFieldEnd();
       }
       if (this.predicate != null) {
         oprot.writeFieldBegin(PREDICATE_FIELD_DESC);
         this.predicate.write(oprot);
         oprot.writeFieldEnd();
       }
       if (this.consistency_level != null) {
         oprot.writeFieldBegin(CONSISTENCY_LEVEL_FIELD_DESC);
         oprot.writeI32(this.consistency_level.getValue());
         oprot.writeFieldEnd();
       }
       oprot.writeFieldStop();
       oprot.writeStructEnd();
     }
 
     @Override
     public String toString() {
       StringBuilder sb = new StringBuilder("multiget_slice_args(");
       boolean first = true;
 
       sb.append("keyspace:");
       if (this.keyspace == null) {
         sb.append("null");
       } else {
         sb.append(this.keyspace);
       }
       first = false;
       if (!first) sb.append(", ");
       sb.append("keys:");
       if (this.keys == null) {
         sb.append("null");
       } else {
         sb.append(this.keys);
       }
       first = false;
       if (!first) sb.append(", ");
       sb.append("column_parent:");
       if (this.column_parent == null) {
         sb.append("null");
       } else {
         sb.append(this.column_parent);
       }
       first = false;
       if (!first) sb.append(", ");
       sb.append("predicate:");
       if (this.predicate == null) {
         sb.append("null");
       } else {
         sb.append(this.predicate);
       }
       first = false;
       if (!first) sb.append(", ");
       sb.append("consistency_level:");
       if (this.consistency_level == null) {
         sb.append("null");
       } else {
         sb.append(this.consistency_level);
       }
       first = false;
       sb.append(")");
       return sb.toString();
     }
 
     public void validate() throws TException {
       // check for required fields
       if (keyspace == null) {
         throw new TProtocolException("Required field 'keyspace' was not present! Struct: " + toString());
       }
       if (keys == null) {
         throw new TProtocolException("Required field 'keys' was not present! Struct: " + toString());
       }
       if (column_parent == null) {
         throw new TProtocolException("Required field 'column_parent' was not present! Struct: " + toString());
       }
       if (predicate == null) {
         throw new TProtocolException("Required field 'predicate' was not present! Struct: " + toString());
       }
       if (consistency_level == null) {
         throw new TProtocolException("Required field 'consistency_level' was not present! Struct: " + toString());
       }
     }
 
   }
 
   public static class multiget_slice_result implements TBase<multiget_slice_result._Fields>, java.io.Serializable, Cloneable   {
     private static final TStruct STRUCT_DESC = new TStruct("multiget_slice_result");
 
     private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.MAP, (short)0);
     private static final TField IRE_FIELD_DESC = new TField("ire", TType.STRUCT, (short)1);
     private static final TField UE_FIELD_DESC = new TField("ue", TType.STRUCT, (short)2);
     private static final TField TE_FIELD_DESC = new TField("te", TType.STRUCT, (short)3);
 
     public Map<byte[],List<ColumnOrSuperColumn>> success;
     public InvalidRequestException ire;
     public UnavailableException ue;
     public TimedOutException te;
 
     /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
     public enum _Fields implements TFieldIdEnum {
       SUCCESS((short)0, "success"),
       IRE((short)1, "ire"),
       UE((short)2, "ue"),
       TE((short)3, "te");
 
       private static final Map<Integer, _Fields> byId = new HashMap<Integer, _Fields>();
       private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();
 
       static {
         for (_Fields field : EnumSet.allOf(_Fields.class)) {
           byId.put((int)field._thriftId, field);
           byName.put(field.getFieldName(), field);
         }
       }
 
       /**
        * Find the _Fields constant that matches fieldId, or null if its not found.
        */
       public static _Fields findByThriftId(int fieldId) {
         return byId.get(fieldId);
       }
 
       /**
        * Find the _Fields constant that matches fieldId, throwing an exception
        * if it is not found.
        */
       public static _Fields findByThriftIdOrThrow(int fieldId) {
         _Fields fields = findByThriftId(fieldId);
         if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
         return fields;
       }
 
       /**
        * Find the _Fields constant that matches name, or null if its not found.
        */
       public static _Fields findByName(String name) {
         return byName.get(name);
       }
 
       private final short _thriftId;
       private final String _fieldName;
 
       _Fields(short thriftId, String fieldName) {
         _thriftId = thriftId;
         _fieldName = fieldName;
       }
 
       public short getThriftFieldId() {
         return _thriftId;
       }
 
       public String getFieldName() {
         return _fieldName;
       }
     }
 
     // isset id assignments
 
     public static final Map<_Fields, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new EnumMap<_Fields, FieldMetaData>(_Fields.class) {{
       put(_Fields.SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
           new MapMetaData(TType.MAP, 
               new FieldValueMetaData(TType.STRING), 
               new ListMetaData(TType.LIST, 
                   new StructMetaData(TType.STRUCT, ColumnOrSuperColumn.class)))));
       put(_Fields.IRE, new FieldMetaData("ire", TFieldRequirementType.DEFAULT, 
           new FieldValueMetaData(TType.STRUCT)));
       put(_Fields.UE, new FieldMetaData("ue", TFieldRequirementType.DEFAULT, 
           new FieldValueMetaData(TType.STRUCT)));
       put(_Fields.TE, new FieldMetaData("te", TFieldRequirementType.DEFAULT, 
           new FieldValueMetaData(TType.STRUCT)));
     }});
 
     static {
       FieldMetaData.addStructMetaDataMap(multiget_slice_result.class, metaDataMap);
     }
 
     public multiget_slice_result() {
     }
 
     public multiget_slice_result(
       Map<byte[],List<ColumnOrSuperColumn>> success,
       InvalidRequestException ire,
       UnavailableException ue,
       TimedOutException te)
     {
       this();
       this.success = success;
       this.ire = ire;
       this.ue = ue;
       this.te = te;
     }
 
     /**
      * Performs a deep copy on <i>other</i>.
      */
     public multiget_slice_result(multiget_slice_result other) {
       if (other.isSetSuccess()) {
         Map<byte[],List<ColumnOrSuperColumn>> __this__success = new HashMap<byte[],List<ColumnOrSuperColumn>>();
         for (Map.Entry<byte[], List<ColumnOrSuperColumn>> other_element : other.success.entrySet()) {
 
           byte[] other_element_key = other_element.getKey();
           List<ColumnOrSuperColumn> other_element_value = other_element.getValue();
 
           byte[] __this__success_copy_key = new byte[other_element_key.length];
           System.arraycopy(other_element_key, 0, __this__success_copy_key, 0, other_element_key.length);
 
           List<ColumnOrSuperColumn> __this__success_copy_value = new ArrayList<ColumnOrSuperColumn>();
           for (ColumnOrSuperColumn other_element_value_element : other_element_value) {
             __this__success_copy_value.add(new ColumnOrSuperColumn(other_element_value_element));
           }
 
           __this__success.put(__this__success_copy_key, __this__success_copy_value);
         }
         this.success = __this__success;
       }
       if (other.isSetIre()) {
         this.ire = new InvalidRequestException(other.ire);
       }
       if (other.isSetUe()) {
         this.ue = new UnavailableException(other.ue);
       }
       if (other.isSetTe()) {
         this.te = new TimedOutException(other.te);
       }
     }
 
     public multiget_slice_result deepCopy() {
       return new multiget_slice_result(this);
     }
 
     @Deprecated
     public multiget_slice_result clone() {
       return new multiget_slice_result(this);
     }
 
     public int getSuccessSize() {
       return (this.success == null) ? 0 : this.success.size();
     }
 
     public void putToSuccess(byte[] key, List<ColumnOrSuperColumn> val) {
       if (this.success == null) {
         this.success = new HashMap<byte[],List<ColumnOrSuperColumn>>();
       }
       this.success.put(key, val);
     }
 
     public Map<byte[],List<ColumnOrSuperColumn>> getSuccess() {
       return this.success;
     }
 
     public multiget_slice_result setSuccess(Map<byte[],List<ColumnOrSuperColumn>> success) {
       this.success = success;
       return this;
     }
 
     public void unsetSuccess() {
       this.success = null;
     }
 
     /** Returns true if field success is set (has been asigned a value) and false otherwise */
     public boolean isSetSuccess() {
       return this.success != null;
     }
 
     public void setSuccessIsSet(boolean value) {
       if (!value) {
         this.success = null;
       }
     }
 
     public InvalidRequestException getIre() {
       return this.ire;
     }
 
     public multiget_slice_result setIre(InvalidRequestException ire) {
       this.ire = ire;
       return this;
     }
 
     public void unsetIre() {
       this.ire = null;
     }
 
     /** Returns true if field ire is set (has been asigned a value) and false otherwise */
     public boolean isSetIre() {
       return this.ire != null;
     }
 
     public void setIreIsSet(boolean value) {
       if (!value) {
         this.ire = null;
       }
     }
 
     public UnavailableException getUe() {
       return this.ue;
     }
 
     public multiget_slice_result setUe(UnavailableException ue) {
       this.ue = ue;
       return this;
     }
 
     public void unsetUe() {
       this.ue = null;
     }
 
     /** Returns true if field ue is set (has been asigned a value) and false otherwise */
     public boolean isSetUe() {
       return this.ue != null;
     }
 
     public void setUeIsSet(boolean value) {
       if (!value) {
         this.ue = null;
       }
     }
 
     public TimedOutException getTe() {
       return this.te;
     }
 
     public multiget_slice_result setTe(TimedOutException te) {
       this.te = te;
       return this;
     }
 
     public void unsetTe() {
       this.te = null;
     }
 
     /** Returns true if field te is set (has been asigned a value) and false otherwise */
     public boolean isSetTe() {
       return this.te != null;
     }
 
     public void setTeIsSet(boolean value) {
       if (!value) {
         this.te = null;
       }
     }
 
     public void setFieldValue(_Fields field, Object value) {
       switch (field) {
       case SUCCESS:
         if (value == null) {
           unsetSuccess();
         } else {
           setSuccess((Map<byte[],List<ColumnOrSuperColumn>>)value);
         }
         break;
 
       case IRE:
         if (value == null) {
           unsetIre();
         } else {
           setIre((InvalidRequestException)value);
         }
         break;
 
       case UE:
         if (value == null) {
           unsetUe();
         } else {
           setUe((UnavailableException)value);
         }
         break;
 
       case TE:
         if (value == null) {
           unsetTe();
         } else {
           setTe((TimedOutException)value);
         }
         break;
 
       }
     }
 
     public void setFieldValue(int fieldID, Object value) {
       setFieldValue(_Fields.findByThriftIdOrThrow(fieldID), value);
     }
 
     public Object getFieldValue(_Fields field) {
       switch (field) {
       case SUCCESS:
         return getSuccess();
 
       case IRE:
         return getIre();
 
       case UE:
         return getUe();
 
       case TE:
         return getTe();
 
       }
       throw new IllegalStateException();
     }
 
     public Object getFieldValue(int fieldId) {
       return getFieldValue(_Fields.findByThriftIdOrThrow(fieldId));
     }
 
     /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
     public boolean isSet(_Fields field) {
       switch (field) {
       case SUCCESS:
         return isSetSuccess();
       case IRE:
         return isSetIre();
       case UE:
         return isSetUe();
       case TE:
         return isSetTe();
       }
       throw new IllegalStateException();
     }
 
     public boolean isSet(int fieldID) {
       return isSet(_Fields.findByThriftIdOrThrow(fieldID));
     }
 
     @Override
     public boolean equals(Object that) {
       if (that == null)
         return false;
       if (that instanceof multiget_slice_result)
         return this.equals((multiget_slice_result)that);
       return false;
     }
 
     public boolean equals(multiget_slice_result that) {
       if (that == null)
         return false;
 
       boolean this_present_success = true && this.isSetSuccess();
       boolean that_present_success = true && that.isSetSuccess();
       if (this_present_success || that_present_success) {
         if (!(this_present_success && that_present_success))
           return false;
         if (!this.success.equals(that.success))
           return false;
       }
 
       boolean this_present_ire = true && this.isSetIre();
       boolean that_present_ire = true && that.isSetIre();
       if (this_present_ire || that_present_ire) {
         if (!(this_present_ire && that_present_ire))
           return false;
         if (!this.ire.equals(that.ire))
           return false;
       }
 
       boolean this_present_ue = true && this.isSetUe();
       boolean that_present_ue = true && that.isSetUe();
       if (this_present_ue || that_present_ue) {
         if (!(this_present_ue && that_present_ue))
           return false;
         if (!this.ue.equals(that.ue))
           return false;
       }
 
       boolean this_present_te = true && this.isSetTe();
       boolean that_present_te = true && that.isSetTe();
       if (this_present_te || that_present_te) {
         if (!(this_present_te && that_present_te))
           return false;
         if (!this.te.equals(that.te))
           return false;
       }
 
       return true;
     }
 
     @Override
     public int hashCode() {
       return 0;
     }
 
     public void read(TProtocol iprot) throws TException {
       TField field;
       iprot.readStructBegin();
       while (true)
       {
         field = iprot.readFieldBegin();
         if (field.type == TType.STOP) { 
           break;
         }
         switch (field.id) {
           case 0: // SUCCESS
             if (field.type == TType.MAP) {
               {
                 TMap _map46 = iprot.readMapBegin();
                 this.success = new HashMap<byte[],List<ColumnOrSuperColumn>>(2*_map46.size);
                 for (int _i47 = 0; _i47 < _map46.size; ++_i47)
                 {
                   byte[] _key48;
                   List<ColumnOrSuperColumn> _val49;
                   _key48 = iprot.readBinary();
                   {
                     TList _list50 = iprot.readListBegin();
                     _val49 = new ArrayList<ColumnOrSuperColumn>(_list50.size);
                     for (int _i51 = 0; _i51 < _list50.size; ++_i51)
                     {
                       ColumnOrSuperColumn _elem52;
                       _elem52 = new ColumnOrSuperColumn();
                       _elem52.read(iprot);
                       _val49.add(_elem52);
                     }
                     iprot.readListEnd();
                   }
                   this.success.put(_key48, _val49);
                 }
                 iprot.readMapEnd();
               }
             } else { 
               TProtocolUtil.skip(iprot, field.type);
             }
             break;
           case 1: // IRE
             if (field.type == TType.STRUCT) {
               this.ire = new InvalidRequestException();
               this.ire.read(iprot);
             } else { 
               TProtocolUtil.skip(iprot, field.type);
             }
             break;
           case 2: // UE
             if (field.type == TType.STRUCT) {
               this.ue = new UnavailableException();
               this.ue.read(iprot);
             } else { 
               TProtocolUtil.skip(iprot, field.type);
             }
             break;
           case 3: // TE
             if (field.type == TType.STRUCT) {
               this.te = new TimedOutException();
               this.te.read(iprot);
             } else { 
               TProtocolUtil.skip(iprot, field.type);
             }
             break;
           default:
             TProtocolUtil.skip(iprot, field.type);
         }
         iprot.readFieldEnd();
       }
       iprot.readStructEnd();
 
       // check for required fields of primitive type, which can't be checked in the validate method
       validate();
     }
 
     public void write(TProtocol oprot) throws TException {
       oprot.writeStructBegin(STRUCT_DESC);
 
       if (this.isSetSuccess()) {
         oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
         {
           oprot.writeMapBegin(new TMap(TType.STRING, TType.LIST, this.success.size()));
           for (Map.Entry<byte[], List<ColumnOrSuperColumn>> _iter53 : this.success.entrySet())
           {
             oprot.writeBinary(_iter53.getKey());
             {
               oprot.writeListBegin(new TList(TType.STRUCT, _iter53.getValue().size()));
               for (ColumnOrSuperColumn _iter54 : _iter53.getValue())
               {
                 _iter54.write(oprot);
               }
               oprot.writeListEnd();
             }
           }
           oprot.writeMapEnd();
         }
         oprot.writeFieldEnd();
       } else if (this.isSetIre()) {
         oprot.writeFieldBegin(IRE_FIELD_DESC);
         this.ire.write(oprot);
         oprot.writeFieldEnd();
       } else if (this.isSetUe()) {
         oprot.writeFieldBegin(UE_FIELD_DESC);
         this.ue.write(oprot);
         oprot.writeFieldEnd();
       } else if (this.isSetTe()) {
         oprot.writeFieldBegin(TE_FIELD_DESC);
         this.te.write(oprot);
         oprot.writeFieldEnd();
       }
       oprot.writeFieldStop();
       oprot.writeStructEnd();
     }
 
     @Override
     public String toString() {
       StringBuilder sb = new StringBuilder("multiget_slice_result(");
       boolean first = true;
 
       sb.append("success:");
       if (this.success == null) {
         sb.append("null");
       } else {
         sb.append(this.success);
       }
       first = false;
       if (!first) sb.append(", ");
       sb.append("ire:");
       if (this.ire == null) {
         sb.append("null");
       } else {
         sb.append(this.ire);
       }
       first = false;
       if (!first) sb.append(", ");
       sb.append("ue:");
       if (this.ue == null) {
         sb.append("null");
       } else {
         sb.append(this.ue);
       }
       first = false;
       if (!first) sb.append(", ");
       sb.append("te:");
       if (this.te == null) {
         sb.append("null");
       } else {
         sb.append(this.te);
       }
       first = false;
       sb.append(")");
       return sb.toString();
     }
 
     public void validate() throws TException {
       // check for required fields
     }
 
   }
 
   public static class get_count_args implements TBase<get_count_args._Fields>, java.io.Serializable, Cloneable, Comparable<get_count_args>   {
     private static final TStruct STRUCT_DESC = new TStruct("get_count_args");
 
     private static final TField KEYSPACE_FIELD_DESC = new TField("keyspace", TType.STRING, (short)1);
     private static final TField KEY_FIELD_DESC = new TField("key", TType.STRING, (short)2);
     private static final TField COLUMN_PARENT_FIELD_DESC = new TField("column_parent", TType.STRUCT, (short)3);
    private static final TField PREDICATE_FIELD_DESC = new TField("predicate", TType.STRUCT, (short)4);
    private static final TField CONSISTENCY_LEVEL_FIELD_DESC = new TField("consistency_level", TType.I32, (short)5);
 
     public String keyspace;
     public byte[] key;
     public ColumnParent column_parent;
    public SlicePredicate predicate;
     /**
      * 
      * @see ConsistencyLevel
      */
     public ConsistencyLevel consistency_level;
 
     /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
     public enum _Fields implements TFieldIdEnum {
       KEYSPACE((short)1, "keyspace"),
       KEY((short)2, "key"),
       COLUMN_PARENT((short)3, "column_parent"),
      PREDICATE((short)4, "predicate"),
       /**
        * 
        * @see ConsistencyLevel
        */
      CONSISTENCY_LEVEL((short)5, "consistency_level");
 
       private static final Map<Integer, _Fields> byId = new HashMap<Integer, _Fields>();
       private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();
 
       static {
         for (_Fields field : EnumSet.allOf(_Fields.class)) {
           byId.put((int)field._thriftId, field);
           byName.put(field.getFieldName(), field);
         }
       }
 
       /**
        * Find the _Fields constant that matches fieldId, or null if its not found.
        */
       public static _Fields findByThriftId(int fieldId) {
         return byId.get(fieldId);
       }
 
       /**
        * Find the _Fields constant that matches fieldId, throwing an exception
        * if it is not found.
        */
       public static _Fields findByThriftIdOrThrow(int fieldId) {
         _Fields fields = findByThriftId(fieldId);
         if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
         return fields;
       }
 
       /**
        * Find the _Fields constant that matches name, or null if its not found.
        */
       public static _Fields findByName(String name) {
         return byName.get(name);
       }
 
       private final short _thriftId;
       private final String _fieldName;
 
       _Fields(short thriftId, String fieldName) {
         _thriftId = thriftId;
         _fieldName = fieldName;
       }
 
       public short getThriftFieldId() {
         return _thriftId;
       }
 
       public String getFieldName() {
         return _fieldName;
       }
     }
 
     // isset id assignments
 
     public static final Map<_Fields, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new EnumMap<_Fields, FieldMetaData>(_Fields.class) {{
       put(_Fields.KEYSPACE, new FieldMetaData("keyspace", TFieldRequirementType.REQUIRED, 
           new FieldValueMetaData(TType.STRING)));
       put(_Fields.KEY, new FieldMetaData("key", TFieldRequirementType.REQUIRED, 
           new FieldValueMetaData(TType.STRING)));
       put(_Fields.COLUMN_PARENT, new FieldMetaData("column_parent", TFieldRequirementType.REQUIRED, 
           new StructMetaData(TType.STRUCT, ColumnParent.class)));
      put(_Fields.PREDICATE, new FieldMetaData("predicate", TFieldRequirementType.REQUIRED, 
          new StructMetaData(TType.STRUCT, SlicePredicate.class)));
       put(_Fields.CONSISTENCY_LEVEL, new FieldMetaData("consistency_level", TFieldRequirementType.REQUIRED, 
           new EnumMetaData(TType.ENUM, ConsistencyLevel.class)));
     }});
 
     static {
       FieldMetaData.addStructMetaDataMap(get_count_args.class, metaDataMap);
     }
 
     public get_count_args() {
       this.consistency_level = ConsistencyLevel.ONE;
 
     }
 
     public get_count_args(
       String keyspace,
       byte[] key,
       ColumnParent column_parent,
      SlicePredicate predicate,
       ConsistencyLevel consistency_level)
     {
       this();
       this.keyspace = keyspace;
       this.key = key;
       this.column_parent = column_parent;
      this.predicate = predicate;
       this.consistency_level = consistency_level;
     }
 
     /**
      * Performs a deep copy on <i>other</i>.
      */
     public get_count_args(get_count_args other) {
       if (other.isSetKeyspace()) {
         this.keyspace = other.keyspace;
       }
       if (other.isSetKey()) {
         this.key = new byte[other.key.length];
         System.arraycopy(other.key, 0, key, 0, other.key.length);
       }
       if (other.isSetColumn_parent()) {
         this.column_parent = new ColumnParent(other.column_parent);
       }
      if (other.isSetPredicate()) {
        this.predicate = new SlicePredicate(other.predicate);
      }
       if (other.isSetConsistency_level()) {
         this.consistency_level = other.consistency_level;
       }
     }
 
     public get_count_args deepCopy() {
       return new get_count_args(this);
     }
 
     @Deprecated
     public get_count_args clone() {
       return new get_count_args(this);
     }
 
     public String getKeyspace() {
       return this.keyspace;
     }
 
     public get_count_args setKeyspace(String keyspace) {
       this.keyspace = keyspace;
       return this;
     }
 
     public void unsetKeyspace() {
       this.keyspace = null;
     }
 
     /** Returns true if field keyspace is set (has been asigned a value) and false otherwise */
     public boolean isSetKeyspace() {
       return this.keyspace != null;
     }
 
     public void setKeyspaceIsSet(boolean value) {
       if (!value) {
         this.keyspace = null;
       }
     }
 
     public byte[] getKey() {
       return this.key;
     }
 
     public get_count_args setKey(byte[] key) {
       this.key = key;
       return this;
     }
 
     public void unsetKey() {
       this.key = null;
     }
 
     /** Returns true if field key is set (has been asigned a value) and false otherwise */
     public boolean isSetKey() {
       return this.key != null;
     }
 
     public void setKeyIsSet(boolean value) {
       if (!value) {
         this.key = null;
       }
     }
 
     public ColumnParent getColumn_parent() {
       return this.column_parent;
     }
 
     public get_count_args setColumn_parent(ColumnParent column_parent) {
       this.column_parent = column_parent;
       return this;
     }
 
     public void unsetColumn_parent() {
       this.column_parent = null;
     }
 
     /** Returns true if field column_parent is set (has been asigned a value) and false otherwise */
     public boolean isSetColumn_parent() {
       return this.column_parent != null;
     }
 
     public void setColumn_parentIsSet(boolean value) {
       if (!value) {
         this.column_parent = null;
       }
     }
 
    public SlicePredicate getPredicate() {
      return this.predicate;
    }

    public get_count_args setPredicate(SlicePredicate predicate) {
      this.predicate = predicate;
      return this;
    }

    public void unsetPredicate() {
      this.predicate = null;
    }

    /** Returns true if field predicate is set (has been asigned a value) and false otherwise */
    public boolean isSetPredicate() {
      return this.predicate != null;
    }

    public void setPredicateIsSet(boolean value) {
      if (!value) {
        this.predicate = null;
      }
    }

     /**
      * 
      * @see ConsistencyLevel
      */
     public ConsistencyLevel getConsistency_level() {
       return this.consistency_level;
     }
 
     /**
      * 
      * @see ConsistencyLevel
      */
     public get_count_args setConsistency_level(ConsistencyLevel consistency_level) {
       this.consistency_level = consistency_level;
       return this;
     }
 
     public void unsetConsistency_level() {
       this.consistency_level = null;
     }
 
     /** Returns true if field consistency_level is set (has been asigned a value) and false otherwise */
     public boolean isSetConsistency_level() {
       return this.consistency_level != null;
     }
 
     public void setConsistency_levelIsSet(boolean value) {
       if (!value) {
         this.consistency_level = null;
       }
     }
 
     public void setFieldValue(_Fields field, Object value) {
       switch (field) {
       case KEYSPACE:
         if (value == null) {
           unsetKeyspace();
         } else {
           setKeyspace((String)value);
         }
         break;
 
       case KEY:
         if (value == null) {
           unsetKey();
         } else {
           setKey((byte[])value);
         }
         break;
 
       case COLUMN_PARENT:
         if (value == null) {
           unsetColumn_parent();
         } else {
           setColumn_parent((ColumnParent)value);
         }
         break;
 
      case PREDICATE:
        if (value == null) {
          unsetPredicate();
        } else {
          setPredicate((SlicePredicate)value);
        }
        break;

       case CONSISTENCY_LEVEL:
         if (value == null) {
           unsetConsistency_level();
         } else {
           setConsistency_level((ConsistencyLevel)value);
         }
         break;
 
       }
     }
 
     public void setFieldValue(int fieldID, Object value) {
       setFieldValue(_Fields.findByThriftIdOrThrow(fieldID), value);
     }
 
     public Object getFieldValue(_Fields field) {
       switch (field) {
       case KEYSPACE:
         return getKeyspace();
 
       case KEY:
         return getKey();
 
       case COLUMN_PARENT:
         return getColumn_parent();
 
      case PREDICATE:
        return getPredicate();

       case CONSISTENCY_LEVEL:
         return getConsistency_level();
 
       }
       throw new IllegalStateException();
     }
 
     public Object getFieldValue(int fieldId) {
       return getFieldValue(_Fields.findByThriftIdOrThrow(fieldId));
     }
 
     /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
     public boolean isSet(_Fields field) {
       switch (field) {
       case KEYSPACE:
         return isSetKeyspace();
       case KEY:
         return isSetKey();
       case COLUMN_PARENT:
         return isSetColumn_parent();
      case PREDICATE:
        return isSetPredicate();
       case CONSISTENCY_LEVEL:
         return isSetConsistency_level();
       }
       throw new IllegalStateException();
     }
 
     public boolean isSet(int fieldID) {
       return isSet(_Fields.findByThriftIdOrThrow(fieldID));
     }
 
     @Override
     public boolean equals(Object that) {
       if (that == null)
         return false;
       if (that instanceof get_count_args)
         return this.equals((get_count_args)that);
       return false;
     }
 
     public boolean equals(get_count_args that) {
       if (that == null)
         return false;
 
       boolean this_present_keyspace = true && this.isSetKeyspace();
       boolean that_present_keyspace = true && that.isSetKeyspace();
       if (this_present_keyspace || that_present_keyspace) {
         if (!(this_present_keyspace && that_present_keyspace))
           return false;
         if (!this.keyspace.equals(that.keyspace))
           return false;
       }
 
       boolean this_present_key = true && this.isSetKey();
       boolean that_present_key = true && that.isSetKey();
       if (this_present_key || that_present_key) {
         if (!(this_present_key && that_present_key))
           return false;
         if (!java.util.Arrays.equals(this.key, that.key))
           return false;
       }
 
       boolean this_present_column_parent = true && this.isSetColumn_parent();
       boolean that_present_column_parent = true && that.isSetColumn_parent();
       if (this_present_column_parent || that_present_column_parent) {
         if (!(this_present_column_parent && that_present_column_parent))
           return false;
         if (!this.column_parent.equals(that.column_parent))
           return false;
       }
 
      boolean this_present_predicate = true && this.isSetPredicate();
      boolean that_present_predicate = true && that.isSetPredicate();
      if (this_present_predicate || that_present_predicate) {
        if (!(this_present_predicate && that_present_predicate))
          return false;
        if (!this.predicate.equals(that.predicate))
          return false;
      }

       boolean this_present_consistency_level = true && this.isSetConsistency_level();
       boolean that_present_consistency_level = true && that.isSetConsistency_level();
       if (this_present_consistency_level || that_present_consistency_level) {
         if (!(this_present_consistency_level && that_present_consistency_level))
           return false;
         if (!this.consistency_level.equals(that.consistency_level))
           return false;
       }
 
       return true;
     }
 
     @Override
     public int hashCode() {
       return 0;
     }
 
     public int compareTo(get_count_args other) {
       if (!getClass().equals(other.getClass())) {
         return getClass().getName().compareTo(other.getClass().getName());
       }
 
       int lastComparison = 0;
       get_count_args typedOther = (get_count_args)other;
 
       lastComparison = Boolean.valueOf(isSetKeyspace()).compareTo(typedOther.isSetKeyspace());
       if (lastComparison != 0) {
         return lastComparison;
       }
       if (isSetKeyspace()) {        lastComparison = TBaseHelper.compareTo(keyspace, typedOther.keyspace);
         if (lastComparison != 0) {
           return lastComparison;
         }
       }
       lastComparison = Boolean.valueOf(isSetKey()).compareTo(typedOther.isSetKey());
       if (lastComparison != 0) {
         return lastComparison;
       }
       if (isSetKey()) {        lastComparison = TBaseHelper.compareTo(key, typedOther.key);
         if (lastComparison != 0) {
           return lastComparison;
         }
       }
       lastComparison = Boolean.valueOf(isSetColumn_parent()).compareTo(typedOther.isSetColumn_parent());
       if (lastComparison != 0) {
         return lastComparison;
       }
       if (isSetColumn_parent()) {        lastComparison = TBaseHelper.compareTo(column_parent, typedOther.column_parent);
         if (lastComparison != 0) {
           return lastComparison;
         }
       }
      lastComparison = Boolean.valueOf(isSetPredicate()).compareTo(typedOther.isSetPredicate());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetPredicate()) {        lastComparison = TBaseHelper.compareTo(predicate, typedOther.predicate);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
       lastComparison = Boolean.valueOf(isSetConsistency_level()).compareTo(typedOther.isSetConsistency_level());
       if (lastComparison != 0) {
         return lastComparison;
       }
       if (isSetConsistency_level()) {        lastComparison = TBaseHelper.compareTo(consistency_level, typedOther.consistency_level);
         if (lastComparison != 0) {
           return lastComparison;
         }
       }
       return 0;
     }
 
     public void read(TProtocol iprot) throws TException {
       TField field;
       iprot.readStructBegin();
       while (true)
       {
         field = iprot.readFieldBegin();
         if (field.type == TType.STOP) { 
           break;
         }
         switch (field.id) {
           case 1: // KEYSPACE
             if (field.type == TType.STRING) {
               this.keyspace = iprot.readString();
             } else { 
               TProtocolUtil.skip(iprot, field.type);
             }
             break;
           case 2: // KEY
             if (field.type == TType.STRING) {
               this.key = iprot.readBinary();
             } else { 
               TProtocolUtil.skip(iprot, field.type);
             }
             break;
           case 3: // COLUMN_PARENT
             if (field.type == TType.STRUCT) {
               this.column_parent = new ColumnParent();
               this.column_parent.read(iprot);
             } else { 
               TProtocolUtil.skip(iprot, field.type);
             }
             break;
          case 4: // PREDICATE
            if (field.type == TType.STRUCT) {
              this.predicate = new SlicePredicate();
              this.predicate.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 5: // CONSISTENCY_LEVEL
             if (field.type == TType.I32) {
               this.consistency_level = ConsistencyLevel.findByValue(iprot.readI32());
             } else { 
               TProtocolUtil.skip(iprot, field.type);
             }
             break;
           default:
             TProtocolUtil.skip(iprot, field.type);
         }
         iprot.readFieldEnd();
       }
       iprot.readStructEnd();
 
       // check for required fields of primitive type, which can't be checked in the validate method
       validate();
     }
 
     public void write(TProtocol oprot) throws TException {
       validate();
 
       oprot.writeStructBegin(STRUCT_DESC);
       if (this.keyspace != null) {
         oprot.writeFieldBegin(KEYSPACE_FIELD_DESC);
         oprot.writeString(this.keyspace);
         oprot.writeFieldEnd();
       }
       if (this.key != null) {
         oprot.writeFieldBegin(KEY_FIELD_DESC);
         oprot.writeBinary(this.key);
         oprot.writeFieldEnd();
       }
       if (this.column_parent != null) {
         oprot.writeFieldBegin(COLUMN_PARENT_FIELD_DESC);
         this.column_parent.write(oprot);
         oprot.writeFieldEnd();
       }
      if (this.predicate != null) {
        oprot.writeFieldBegin(PREDICATE_FIELD_DESC);
        this.predicate.write(oprot);
        oprot.writeFieldEnd();
      }
       if (this.consistency_level != null) {
         oprot.writeFieldBegin(CONSISTENCY_LEVEL_FIELD_DESC);
         oprot.writeI32(this.consistency_level.getValue());
         oprot.writeFieldEnd();
       }
       oprot.writeFieldStop();
       oprot.writeStructEnd();
     }
 
     @Override
     public String toString() {
       StringBuilder sb = new StringBuilder("get_count_args(");
       boolean first = true;
 
       sb.append("keyspace:");
       if (this.keyspace == null) {
         sb.append("null");
       } else {
         sb.append(this.keyspace);
       }
       first = false;
       if (!first) sb.append(", ");
       sb.append("key:");
       if (this.key == null) {
         sb.append("null");
       } else {
           int __key_size = Math.min(this.key.length, 128);
           for (int i = 0; i < __key_size; i++) {
             if (i != 0) sb.append(" ");
             sb.append(Integer.toHexString(this.key[i]).length() > 1 ? Integer.toHexString(this.key[i]).substring(Integer.toHexString(this.key[i]).length() - 2).toUpperCase() : "0" + Integer.toHexString(this.key[i]).toUpperCase());
           }
           if (this.key.length > 128) sb.append(" ...");
       }
       first = false;
       if (!first) sb.append(", ");
       sb.append("column_parent:");
       if (this.column_parent == null) {
         sb.append("null");
       } else {
         sb.append(this.column_parent);
       }
       first = false;
       if (!first) sb.append(", ");
      sb.append("predicate:");
      if (this.predicate == null) {
        sb.append("null");
      } else {
        sb.append(this.predicate);
      }
      first = false;
      if (!first) sb.append(", ");
       sb.append("consistency_level:");
       if (this.consistency_level == null) {
         sb.append("null");
       } else {
         sb.append(this.consistency_level);
       }
       first = false;
       sb.append(")");
       return sb.toString();
     }
 
     public void validate() throws TException {
       // check for required fields
       if (keyspace == null) {
         throw new TProtocolException("Required field 'keyspace' was not present! Struct: " + toString());
       }
       if (key == null) {
         throw new TProtocolException("Required field 'key' was not present! Struct: " + toString());
       }
       if (column_parent == null) {
         throw new TProtocolException("Required field 'column_parent' was not present! Struct: " + toString());
       }
      if (predicate == null) {
        throw new TProtocolException("Required field 'predicate' was not present! Struct: " + toString());
      }
       if (consistency_level == null) {
         throw new TProtocolException("Required field 'consistency_level' was not present! Struct: " + toString());
       }
     }
 
   }
 
   public static class get_count_result implements TBase<get_count_result._Fields>, java.io.Serializable, Cloneable, Comparable<get_count_result>   {
     private static final TStruct STRUCT_DESC = new TStruct("get_count_result");
 
     private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.I32, (short)0);
     private static final TField IRE_FIELD_DESC = new TField("ire", TType.STRUCT, (short)1);
     private static final TField UE_FIELD_DESC = new TField("ue", TType.STRUCT, (short)2);
     private static final TField TE_FIELD_DESC = new TField("te", TType.STRUCT, (short)3);
 
     public int success;
     public InvalidRequestException ire;
     public UnavailableException ue;
     public TimedOutException te;
 
     /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
     public enum _Fields implements TFieldIdEnum {
       SUCCESS((short)0, "success"),
       IRE((short)1, "ire"),
       UE((short)2, "ue"),
       TE((short)3, "te");
 
       private static final Map<Integer, _Fields> byId = new HashMap<Integer, _Fields>();
       private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();
 
       static {
         for (_Fields field : EnumSet.allOf(_Fields.class)) {
           byId.put((int)field._thriftId, field);
           byName.put(field.getFieldName(), field);
         }
       }
 
       /**
        * Find the _Fields constant that matches fieldId, or null if its not found.
        */
       public static _Fields findByThriftId(int fieldId) {
         return byId.get(fieldId);
       }
 
       /**
        * Find the _Fields constant that matches fieldId, throwing an exception
        * if it is not found.
        */
       public static _Fields findByThriftIdOrThrow(int fieldId) {
         _Fields fields = findByThriftId(fieldId);
         if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
         return fields;
       }
 
       /**
        * Find the _Fields constant that matches name, or null if its not found.
        */
       public static _Fields findByName(String name) {
         return byName.get(name);
       }
 
       private final short _thriftId;
       private final String _fieldName;
 
       _Fields(short thriftId, String fieldName) {
         _thriftId = thriftId;
         _fieldName = fieldName;
       }
 
       public short getThriftFieldId() {
         return _thriftId;
       }
 
       public String getFieldName() {
         return _fieldName;
       }
     }
 
     // isset id assignments
     private static final int __SUCCESS_ISSET_ID = 0;
     private BitSet __isset_bit_vector = new BitSet(1);
 
     public static final Map<_Fields, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new EnumMap<_Fields, FieldMetaData>(_Fields.class) {{
       put(_Fields.SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
           new FieldValueMetaData(TType.I32)));
       put(_Fields.IRE, new FieldMetaData("ire", TFieldRequirementType.DEFAULT, 
           new FieldValueMetaData(TType.STRUCT)));
       put(_Fields.UE, new FieldMetaData("ue", TFieldRequirementType.DEFAULT, 
           new FieldValueMetaData(TType.STRUCT)));
       put(_Fields.TE, new FieldMetaData("te", TFieldRequirementType.DEFAULT, 
           new FieldValueMetaData(TType.STRUCT)));
     }});
 
     static {
       FieldMetaData.addStructMetaDataMap(get_count_result.class, metaDataMap);
     }
 
     public get_count_result() {
     }
 
     public get_count_result(
       int success,
       InvalidRequestException ire,
       UnavailableException ue,
       TimedOutException te)
     {
       this();
       this.success = success;
       setSuccessIsSet(true);
       this.ire = ire;
       this.ue = ue;
       this.te = te;
     }
 
     /**
      * Performs a deep copy on <i>other</i>.
      */
     public get_count_result(get_count_result other) {
       __isset_bit_vector.clear();
       __isset_bit_vector.or(other.__isset_bit_vector);
       this.success = other.success;
       if (other.isSetIre()) {
         this.ire = new InvalidRequestException(other.ire);
       }
       if (other.isSetUe()) {
         this.ue = new UnavailableException(other.ue);
       }
       if (other.isSetTe()) {
         this.te = new TimedOutException(other.te);
       }
     }
 
     public get_count_result deepCopy() {
       return new get_count_result(this);
     }
 
     @Deprecated
     public get_count_result clone() {
       return new get_count_result(this);
     }
 
     public int getSuccess() {
       return this.success;
     }
 
     public get_count_result setSuccess(int success) {
       this.success = success;
       setSuccessIsSet(true);
       return this;
     }
 
     public void unsetSuccess() {
       __isset_bit_vector.clear(__SUCCESS_ISSET_ID);
     }
 
     /** Returns true if field success is set (has been asigned a value) and false otherwise */
     public boolean isSetSuccess() {
       return __isset_bit_vector.get(__SUCCESS_ISSET_ID);
     }
 
     public void setSuccessIsSet(boolean value) {
       __isset_bit_vector.set(__SUCCESS_ISSET_ID, value);
     }
 
     public InvalidRequestException getIre() {
       return this.ire;
     }
 
     public get_count_result setIre(InvalidRequestException ire) {
       this.ire = ire;
       return this;
     }
 
     public void unsetIre() {
       this.ire = null;
     }
 
     /** Returns true if field ire is set (has been asigned a value) and false otherwise */
     public boolean isSetIre() {
       return this.ire != null;
     }
 
     public void setIreIsSet(boolean value) {
       if (!value) {
         this.ire = null;
       }
     }
 
     public UnavailableException getUe() {
       return this.ue;
     }
 
     public get_count_result setUe(UnavailableException ue) {
       this.ue = ue;
       return this;
     }
 
     public void unsetUe() {
       this.ue = null;
     }
 
     /** Returns true if field ue is set (has been asigned a value) and false otherwise */
     public boolean isSetUe() {
       return this.ue != null;
     }
 
     public void setUeIsSet(boolean value) {
       if (!value) {
         this.ue = null;
       }
     }
 
     public TimedOutException getTe() {
       return this.te;
     }
 
     public get_count_result setTe(TimedOutException te) {
       this.te = te;
       return this;
     }
 
     public void unsetTe() {
       this.te = null;
     }
 
     /** Returns true if field te is set (has been asigned a value) and false otherwise */
     public boolean isSetTe() {
       return this.te != null;
     }
 
     public void setTeIsSet(boolean value) {
       if (!value) {
         this.te = null;
       }
     }
 
     public void setFieldValue(_Fields field, Object value) {
       switch (field) {
       case SUCCESS:
         if (value == null) {
           unsetSuccess();
         } else {
           setSuccess((Integer)value);
         }
         break;
 
       case IRE:
         if (value == null) {
           unsetIre();
         } else {
           setIre((InvalidRequestException)value);
         }
         break;
 
       case UE:
         if (value == null) {
           unsetUe();
         } else {
           setUe((UnavailableException)value);
         }
         break;
 
       case TE:
         if (value == null) {
           unsetTe();
         } else {
           setTe((TimedOutException)value);
         }
         break;
 
       }
     }
 
     public void setFieldValue(int fieldID, Object value) {
       setFieldValue(_Fields.findByThriftIdOrThrow(fieldID), value);
     }
 
     public Object getFieldValue(_Fields field) {
       switch (field) {
       case SUCCESS:
         return new Integer(getSuccess());
 
       case IRE:
         return getIre();
 
       case UE:
         return getUe();
 
       case TE:
         return getTe();
 
       }
       throw new IllegalStateException();
     }
 
     public Object getFieldValue(int fieldId) {
       return getFieldValue(_Fields.findByThriftIdOrThrow(fieldId));
     }
 
     /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
     public boolean isSet(_Fields field) {
       switch (field) {
       case SUCCESS:
         return isSetSuccess();
       case IRE:
         return isSetIre();
       case UE:
         return isSetUe();
       case TE:
         return isSetTe();
       }
       throw new IllegalStateException();
     }
 
     public boolean isSet(int fieldID) {
       return isSet(_Fields.findByThriftIdOrThrow(fieldID));
     }
 
     @Override
     public boolean equals(Object that) {
       if (that == null)
         return false;
       if (that instanceof get_count_result)
         return this.equals((get_count_result)that);
       return false;
     }
 
     public boolean equals(get_count_result that) {
       if (that == null)
         return false;
 
       boolean this_present_success = true;
       boolean that_present_success = true;
       if (this_present_success || that_present_success) {
         if (!(this_present_success && that_present_success))
           return false;
         if (this.success != that.success)
           return false;
       }
 
       boolean this_present_ire = true && this.isSetIre();
       boolean that_present_ire = true && that.isSetIre();
       if (this_present_ire || that_present_ire) {
         if (!(this_present_ire && that_present_ire))
           return false;
         if (!this.ire.equals(that.ire))
           return false;
       }
 
       boolean this_present_ue = true && this.isSetUe();
       boolean that_present_ue = true && that.isSetUe();
       if (this_present_ue || that_present_ue) {
         if (!(this_present_ue && that_present_ue))
           return false;
         if (!this.ue.equals(that.ue))
           return false;
       }
 
       boolean this_present_te = true && this.isSetTe();
       boolean that_present_te = true && that.isSetTe();
       if (this_present_te || that_present_te) {
         if (!(this_present_te && that_present_te))
           return false;
         if (!this.te.equals(that.te))
           return false;
       }
 
       return true;
     }
 
     @Override
     public int hashCode() {
       return 0;
     }
 
     public int compareTo(get_count_result other) {
       if (!getClass().equals(other.getClass())) {
         return getClass().getName().compareTo(other.getClass().getName());
       }
 
       int lastComparison = 0;
       get_count_result typedOther = (get_count_result)other;
 
       lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(typedOther.isSetSuccess());
       if (lastComparison != 0) {
         return lastComparison;
       }
       if (isSetSuccess()) {        lastComparison = TBaseHelper.compareTo(success, typedOther.success);
         if (lastComparison != 0) {
           return lastComparison;
         }
       }
       lastComparison = Boolean.valueOf(isSetIre()).compareTo(typedOther.isSetIre());
       if (lastComparison != 0) {
         return lastComparison;
       }
       if (isSetIre()) {        lastComparison = TBaseHelper.compareTo(ire, typedOther.ire);
         if (lastComparison != 0) {
           return lastComparison;
         }
       }
       lastComparison = Boolean.valueOf(isSetUe()).compareTo(typedOther.isSetUe());
       if (lastComparison != 0) {
         return lastComparison;
       }
       if (isSetUe()) {        lastComparison = TBaseHelper.compareTo(ue, typedOther.ue);
         if (lastComparison != 0) {
           return lastComparison;
         }
       }
       lastComparison = Boolean.valueOf(isSetTe()).compareTo(typedOther.isSetTe());
       if (lastComparison != 0) {
         return lastComparison;
       }
       if (isSetTe()) {        lastComparison = TBaseHelper.compareTo(te, typedOther.te);
         if (lastComparison != 0) {
           return lastComparison;
         }
       }
       return 0;
     }
 
     public void read(TProtocol iprot) throws TException {
       TField field;
       iprot.readStructBegin();
       while (true)
       {
         field = iprot.readFieldBegin();
         if (field.type == TType.STOP) { 
           break;
         }
         switch (field.id) {
           case 0: // SUCCESS
             if (field.type == TType.I32) {
               this.success = iprot.readI32();
               setSuccessIsSet(true);
             } else { 
               TProtocolUtil.skip(iprot, field.type);
             }
             break;
           case 1: // IRE
             if (field.type == TType.STRUCT) {
               this.ire = new InvalidRequestException();
               this.ire.read(iprot);
             } else { 
               TProtocolUtil.skip(iprot, field.type);
             }
             break;
           case 2: // UE
             if (field.type == TType.STRUCT) {
               this.ue = new UnavailableException();
               this.ue.read(iprot);
             } else { 
               TProtocolUtil.skip(iprot, field.type);
             }
             break;
           case 3: // TE
             if (field.type == TType.STRUCT) {
               this.te = new TimedOutException();
               this.te.read(iprot);
             } else { 
               TProtocolUtil.skip(iprot, field.type);
             }
             break;
           default:
             TProtocolUtil.skip(iprot, field.type);
         }
         iprot.readFieldEnd();
       }
       iprot.readStructEnd();
 
       // check for required fields of primitive type, which can't be checked in the validate method
       validate();
     }
 
     public void write(TProtocol oprot) throws TException {
       oprot.writeStructBegin(STRUCT_DESC);
 
       if (this.isSetSuccess()) {
         oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
         oprot.writeI32(this.success);
         oprot.writeFieldEnd();
       } else if (this.isSetIre()) {
         oprot.writeFieldBegin(IRE_FIELD_DESC);
         this.ire.write(oprot);
         oprot.writeFieldEnd();
       } else if (this.isSetUe()) {
         oprot.writeFieldBegin(UE_FIELD_DESC);
         this.ue.write(oprot);
         oprot.writeFieldEnd();
       } else if (this.isSetTe()) {
         oprot.writeFieldBegin(TE_FIELD_DESC);
         this.te.write(oprot);
         oprot.writeFieldEnd();
       }
       oprot.writeFieldStop();
       oprot.writeStructEnd();
     }
 
     @Override
     public String toString() {
       StringBuilder sb = new StringBuilder("get_count_result(");
       boolean first = true;
 
       sb.append("success:");
       sb.append(this.success);
       first = false;
       if (!first) sb.append(", ");
       sb.append("ire:");
       if (this.ire == null) {
         sb.append("null");
       } else {
         sb.append(this.ire);
       }
       first = false;
       if (!first) sb.append(", ");
       sb.append("ue:");
       if (this.ue == null) {
         sb.append("null");
       } else {
         sb.append(this.ue);
       }
       first = false;
       if (!first) sb.append(", ");
       sb.append("te:");
       if (this.te == null) {
         sb.append("null");
       } else {
         sb.append(this.te);
       }
       first = false;
       sb.append(")");
       return sb.toString();
     }
 
     public void validate() throws TException {
       // check for required fields
     }
 
   }
 
  public static class multiget_count_args implements TBase<multiget_count_args._Fields>, java.io.Serializable, Cloneable, Comparable<multiget_count_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("multiget_count_args");
 
     private static final TField KEYSPACE_FIELD_DESC = new TField("keyspace", TType.STRING, (short)1);
    private static final TField KEYS_FIELD_DESC = new TField("keys", TType.LIST, (short)2);
    private static final TField COLUMN_PARENT_FIELD_DESC = new TField("column_parent", TType.STRUCT, (short)3);
    private static final TField PREDICATE_FIELD_DESC = new TField("predicate", TType.STRUCT, (short)4);
    private static final TField CONSISTENCY_LEVEL_FIELD_DESC = new TField("consistency_level", TType.I32, (short)5);
 
     public String keyspace;
    public List<byte[]> keys;
     public ColumnParent column_parent;
     public SlicePredicate predicate;
     /**
      * 
      * @see ConsistencyLevel
      */
     public ConsistencyLevel consistency_level;
 
     /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
     public enum _Fields implements TFieldIdEnum {
       KEYSPACE((short)1, "keyspace"),
      KEYS((short)2, "keys"),
      COLUMN_PARENT((short)3, "column_parent"),
      PREDICATE((short)4, "predicate"),
       /**
        * 
        * @see ConsistencyLevel
        */
      CONSISTENCY_LEVEL((short)5, "consistency_level");
 
       private static final Map<Integer, _Fields> byId = new HashMap<Integer, _Fields>();
       private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();
 
       static {
         for (_Fields field : EnumSet.allOf(_Fields.class)) {
           byId.put((int)field._thriftId, field);
           byName.put(field.getFieldName(), field);
         }
       }
 
       /**
        * Find the _Fields constant that matches fieldId, or null if its not found.
        */
       public static _Fields findByThriftId(int fieldId) {
         return byId.get(fieldId);
       }
 
       /**
        * Find the _Fields constant that matches fieldId, throwing an exception
        * if it is not found.
        */
       public static _Fields findByThriftIdOrThrow(int fieldId) {
         _Fields fields = findByThriftId(fieldId);
         if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
         return fields;
       }
 
       /**
        * Find the _Fields constant that matches name, or null if its not found.
        */
       public static _Fields findByName(String name) {
         return byName.get(name);
       }
 
       private final short _thriftId;
       private final String _fieldName;
 
       _Fields(short thriftId, String fieldName) {
         _thriftId = thriftId;
         _fieldName = fieldName;
       }
 
       public short getThriftFieldId() {
         return _thriftId;
       }
 
       public String getFieldName() {
         return _fieldName;
       }
     }
 
     // isset id assignments
 
     public static final Map<_Fields, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new EnumMap<_Fields, FieldMetaData>(_Fields.class) {{
       put(_Fields.KEYSPACE, new FieldMetaData("keyspace", TFieldRequirementType.REQUIRED, 
           new FieldValueMetaData(TType.STRING)));
      put(_Fields.KEYS, new FieldMetaData("keys", TFieldRequirementType.REQUIRED, 
          new ListMetaData(TType.LIST, 
              new FieldValueMetaData(TType.STRING))));
       put(_Fields.COLUMN_PARENT, new FieldMetaData("column_parent", TFieldRequirementType.REQUIRED, 
           new StructMetaData(TType.STRUCT, ColumnParent.class)));
       put(_Fields.PREDICATE, new FieldMetaData("predicate", TFieldRequirementType.REQUIRED, 
           new StructMetaData(TType.STRUCT, SlicePredicate.class)));
       put(_Fields.CONSISTENCY_LEVEL, new FieldMetaData("consistency_level", TFieldRequirementType.REQUIRED, 
           new EnumMetaData(TType.ENUM, ConsistencyLevel.class)));
     }});
 
     static {
      FieldMetaData.addStructMetaDataMap(multiget_count_args.class, metaDataMap);
     }
 
    public multiget_count_args() {
       this.consistency_level = ConsistencyLevel.ONE;
 
     }
 
    public multiget_count_args(
       String keyspace,
      List<byte[]> keys,
       ColumnParent column_parent,
       SlicePredicate predicate,
       ConsistencyLevel consistency_level)
     {
       this();
       this.keyspace = keyspace;
      this.keys = keys;
       this.column_parent = column_parent;
       this.predicate = predicate;
       this.consistency_level = consistency_level;
     }
 
     /**
      * Performs a deep copy on <i>other</i>.
      */
    public multiget_count_args(multiget_count_args other) {
       if (other.isSetKeyspace()) {
         this.keyspace = other.keyspace;
       }
      if (other.isSetKeys()) {
        List<byte[]> __this__keys = new ArrayList<byte[]>();
        for (byte[] other_element : other.keys) {
          byte[] temp_binary_element = new byte[other_element.length];
          System.arraycopy(other_element, 0, temp_binary_element, 0, other_element.length);
          __this__keys.add(temp_binary_element);
        }
        this.keys = __this__keys;
      }
       if (other.isSetColumn_parent()) {
         this.column_parent = new ColumnParent(other.column_parent);
       }
       if (other.isSetPredicate()) {
         this.predicate = new SlicePredicate(other.predicate);
       }
       if (other.isSetConsistency_level()) {
         this.consistency_level = other.consistency_level;
       }
     }
 
    public multiget_count_args deepCopy() {
      return new multiget_count_args(this);
     }
 
     @Deprecated
    public multiget_count_args clone() {
      return new multiget_count_args(this);
     }
 
     public String getKeyspace() {
       return this.keyspace;
     }
 
    public multiget_count_args setKeyspace(String keyspace) {
       this.keyspace = keyspace;
       return this;
     }
 
     public void unsetKeyspace() {
       this.keyspace = null;
     }
 
     /** Returns true if field keyspace is set (has been asigned a value) and false otherwise */
     public boolean isSetKeyspace() {
       return this.keyspace != null;
     }
 
     public void setKeyspaceIsSet(boolean value) {
       if (!value) {
         this.keyspace = null;
       }
     }
 
    public int getKeysSize() {
      return (this.keys == null) ? 0 : this.keys.size();
    }

    public java.util.Iterator<byte[]> getKeysIterator() {
      return (this.keys == null) ? null : this.keys.iterator();
    }

    public void addToKeys(byte[] elem) {
      if (this.keys == null) {
        this.keys = new ArrayList<byte[]>();
      }
      this.keys.add(elem);
    }

    public List<byte[]> getKeys() {
      return this.keys;
    }

    public multiget_count_args setKeys(List<byte[]> keys) {
      this.keys = keys;
      return this;
    }

    public void unsetKeys() {
      this.keys = null;
    }

    /** Returns true if field keys is set (has been asigned a value) and false otherwise */
    public boolean isSetKeys() {
      return this.keys != null;
    }

    public void setKeysIsSet(boolean value) {
      if (!value) {
        this.keys = null;
      }
    }

    public ColumnParent getColumn_parent() {
      return this.column_parent;
    }

    public multiget_count_args setColumn_parent(ColumnParent column_parent) {
      this.column_parent = column_parent;
      return this;
    }

    public void unsetColumn_parent() {
      this.column_parent = null;
    }

    /** Returns true if field column_parent is set (has been asigned a value) and false otherwise */
    public boolean isSetColumn_parent() {
      return this.column_parent != null;
    }

    public void setColumn_parentIsSet(boolean value) {
      if (!value) {
        this.column_parent = null;
      }
    }

    public SlicePredicate getPredicate() {
      return this.predicate;
    }

    public multiget_count_args setPredicate(SlicePredicate predicate) {
      this.predicate = predicate;
      return this;
    }

    public void unsetPredicate() {
      this.predicate = null;
    }

    /** Returns true if field predicate is set (has been asigned a value) and false otherwise */
    public boolean isSetPredicate() {
      return this.predicate != null;
    }

    public void setPredicateIsSet(boolean value) {
      if (!value) {
        this.predicate = null;
      }
    }

    /**
     * 
     * @see ConsistencyLevel
     */
    public ConsistencyLevel getConsistency_level() {
      return this.consistency_level;
    }

    /**
     * 
     * @see ConsistencyLevel
     */
    public multiget_count_args setConsistency_level(ConsistencyLevel consistency_level) {
      this.consistency_level = consistency_level;
      return this;
    }

    public void unsetConsistency_level() {
      this.consistency_level = null;
    }

    /** Returns true if field consistency_level is set (has been asigned a value) and false otherwise */
    public boolean isSetConsistency_level() {
      return this.consistency_level != null;
    }

    public void setConsistency_levelIsSet(boolean value) {
      if (!value) {
        this.consistency_level = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case KEYSPACE:
        if (value == null) {
          unsetKeyspace();
        } else {
          setKeyspace((String)value);
        }
        break;

      case KEYS:
        if (value == null) {
          unsetKeys();
        } else {
          setKeys((List<byte[]>)value);
        }
        break;

      case COLUMN_PARENT:
        if (value == null) {
          unsetColumn_parent();
        } else {
          setColumn_parent((ColumnParent)value);
        }
        break;

      case PREDICATE:
        if (value == null) {
          unsetPredicate();
        } else {
          setPredicate((SlicePredicate)value);
        }
        break;

      case CONSISTENCY_LEVEL:
        if (value == null) {
          unsetConsistency_level();
        } else {
          setConsistency_level((ConsistencyLevel)value);
        }
        break;

      }
    }

    public void setFieldValue(int fieldID, Object value) {
      setFieldValue(_Fields.findByThriftIdOrThrow(fieldID), value);
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case KEYSPACE:
        return getKeyspace();

      case KEYS:
        return getKeys();

      case COLUMN_PARENT:
        return getColumn_parent();

      case PREDICATE:
        return getPredicate();

      case CONSISTENCY_LEVEL:
        return getConsistency_level();

      }
      throw new IllegalStateException();
    }

    public Object getFieldValue(int fieldId) {
      return getFieldValue(_Fields.findByThriftIdOrThrow(fieldId));
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      switch (field) {
      case KEYSPACE:
        return isSetKeyspace();
      case KEYS:
        return isSetKeys();
      case COLUMN_PARENT:
        return isSetColumn_parent();
      case PREDICATE:
        return isSetPredicate();
      case CONSISTENCY_LEVEL:
        return isSetConsistency_level();
      }
      throw new IllegalStateException();
    }

    public boolean isSet(int fieldID) {
      return isSet(_Fields.findByThriftIdOrThrow(fieldID));
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof multiget_count_args)
        return this.equals((multiget_count_args)that);
      return false;
    }

    public boolean equals(multiget_count_args that) {
      if (that == null)
        return false;

      boolean this_present_keyspace = true && this.isSetKeyspace();
      boolean that_present_keyspace = true && that.isSetKeyspace();
      if (this_present_keyspace || that_present_keyspace) {
        if (!(this_present_keyspace && that_present_keyspace))
          return false;
        if (!this.keyspace.equals(that.keyspace))
          return false;
      }

      boolean this_present_keys = true && this.isSetKeys();
      boolean that_present_keys = true && that.isSetKeys();
      if (this_present_keys || that_present_keys) {
        if (!(this_present_keys && that_present_keys))
          return false;
        if (!this.keys.equals(that.keys))
          return false;
      }

      boolean this_present_column_parent = true && this.isSetColumn_parent();
      boolean that_present_column_parent = true && that.isSetColumn_parent();
      if (this_present_column_parent || that_present_column_parent) {
        if (!(this_present_column_parent && that_present_column_parent))
          return false;
        if (!this.column_parent.equals(that.column_parent))
          return false;
      }

      boolean this_present_predicate = true && this.isSetPredicate();
      boolean that_present_predicate = true && that.isSetPredicate();
      if (this_present_predicate || that_present_predicate) {
        if (!(this_present_predicate && that_present_predicate))
          return false;
        if (!this.predicate.equals(that.predicate))
          return false;
      }

      boolean this_present_consistency_level = true && this.isSetConsistency_level();
      boolean that_present_consistency_level = true && that.isSetConsistency_level();
      if (this_present_consistency_level || that_present_consistency_level) {
        if (!(this_present_consistency_level && that_present_consistency_level))
          return false;
        if (!this.consistency_level.equals(that.consistency_level))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(multiget_count_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      multiget_count_args typedOther = (multiget_count_args)other;

      lastComparison = Boolean.valueOf(isSetKeyspace()).compareTo(typedOther.isSetKeyspace());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetKeyspace()) {        lastComparison = TBaseHelper.compareTo(keyspace, typedOther.keyspace);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetKeys()).compareTo(typedOther.isSetKeys());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetKeys()) {        lastComparison = TBaseHelper.compareTo(keys, typedOther.keys);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetColumn_parent()).compareTo(typedOther.isSetColumn_parent());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetColumn_parent()) {        lastComparison = TBaseHelper.compareTo(column_parent, typedOther.column_parent);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetPredicate()).compareTo(typedOther.isSetPredicate());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetPredicate()) {        lastComparison = TBaseHelper.compareTo(predicate, typedOther.predicate);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetConsistency_level()).compareTo(typedOther.isSetConsistency_level());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetConsistency_level()) {        lastComparison = TBaseHelper.compareTo(consistency_level, typedOther.consistency_level);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 1: // KEYSPACE
            if (field.type == TType.STRING) {
              this.keyspace = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 2: // KEYS
            if (field.type == TType.LIST) {
              {
                TList _list55 = iprot.readListBegin();
                this.keys = new ArrayList<byte[]>(_list55.size);
                for (int _i56 = 0; _i56 < _list55.size; ++_i56)
                {
                  byte[] _elem57;
                  _elem57 = iprot.readBinary();
                  this.keys.add(_elem57);
                }
                iprot.readListEnd();
              }
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 3: // COLUMN_PARENT
            if (field.type == TType.STRUCT) {
              this.column_parent = new ColumnParent();
              this.column_parent.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 4: // PREDICATE
            if (field.type == TType.STRUCT) {
              this.predicate = new SlicePredicate();
              this.predicate.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 5: // CONSISTENCY_LEVEL
            if (field.type == TType.I32) {
              this.consistency_level = ConsistencyLevel.findByValue(iprot.readI32());
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.keyspace != null) {
        oprot.writeFieldBegin(KEYSPACE_FIELD_DESC);
        oprot.writeString(this.keyspace);
        oprot.writeFieldEnd();
      }
      if (this.keys != null) {
        oprot.writeFieldBegin(KEYS_FIELD_DESC);
        {
          oprot.writeListBegin(new TList(TType.STRING, this.keys.size()));
          for (byte[] _iter58 : this.keys)
          {
            oprot.writeBinary(_iter58);
          }
          oprot.writeListEnd();
        }
        oprot.writeFieldEnd();
      }
      if (this.column_parent != null) {
        oprot.writeFieldBegin(COLUMN_PARENT_FIELD_DESC);
        this.column_parent.write(oprot);
        oprot.writeFieldEnd();
      }
      if (this.predicate != null) {
        oprot.writeFieldBegin(PREDICATE_FIELD_DESC);
        this.predicate.write(oprot);
        oprot.writeFieldEnd();
      }
      if (this.consistency_level != null) {
        oprot.writeFieldBegin(CONSISTENCY_LEVEL_FIELD_DESC);
        oprot.writeI32(this.consistency_level.getValue());
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("multiget_count_args(");
      boolean first = true;

      sb.append("keyspace:");
      if (this.keyspace == null) {
        sb.append("null");
      } else {
        sb.append(this.keyspace);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("keys:");
      if (this.keys == null) {
        sb.append("null");
      } else {
        sb.append(this.keys);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("column_parent:");
      if (this.column_parent == null) {
        sb.append("null");
      } else {
        sb.append(this.column_parent);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("predicate:");
      if (this.predicate == null) {
        sb.append("null");
      } else {
        sb.append(this.predicate);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("consistency_level:");
      if (this.consistency_level == null) {
        sb.append("null");
      } else {
        sb.append(this.consistency_level);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      if (keyspace == null) {
        throw new TProtocolException("Required field 'keyspace' was not present! Struct: " + toString());
      }
      if (keys == null) {
        throw new TProtocolException("Required field 'keys' was not present! Struct: " + toString());
      }
      if (column_parent == null) {
        throw new TProtocolException("Required field 'column_parent' was not present! Struct: " + toString());
      }
      if (predicate == null) {
        throw new TProtocolException("Required field 'predicate' was not present! Struct: " + toString());
      }
      if (consistency_level == null) {
        throw new TProtocolException("Required field 'consistency_level' was not present! Struct: " + toString());
      }
    }

  }

  public static class multiget_count_result implements TBase<multiget_count_result._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("multiget_count_result");

    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.MAP, (short)0);
    private static final TField IRE_FIELD_DESC = new TField("ire", TType.STRUCT, (short)1);
    private static final TField UE_FIELD_DESC = new TField("ue", TType.STRUCT, (short)2);
    private static final TField TE_FIELD_DESC = new TField("te", TType.STRUCT, (short)3);

    public Map<byte[],Integer> success;
    public InvalidRequestException ire;
    public UnavailableException ue;
    public TimedOutException te;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      SUCCESS((short)0, "success"),
      IRE((short)1, "ire"),
      UE((short)2, "ue"),
      TE((short)3, "te");

      private static final Map<Integer, _Fields> byId = new HashMap<Integer, _Fields>();
      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byId.put((int)field._thriftId, field);
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        return byId.get(fieldId);
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new EnumMap<_Fields, FieldMetaData>(_Fields.class) {{
      put(_Fields.SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new MapMetaData(TType.MAP, 
              new FieldValueMetaData(TType.STRING), 
              new FieldValueMetaData(TType.I32))));
      put(_Fields.IRE, new FieldMetaData("ire", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
      put(_Fields.UE, new FieldMetaData("ue", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
      put(_Fields.TE, new FieldMetaData("te", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(multiget_count_result.class, metaDataMap);
    }

    public multiget_count_result() {
    }

    public multiget_count_result(
      Map<byte[],Integer> success,
      InvalidRequestException ire,
      UnavailableException ue,
      TimedOutException te)
    {
      this();
      this.success = success;
      this.ire = ire;
      this.ue = ue;
      this.te = te;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public multiget_count_result(multiget_count_result other) {
      if (other.isSetSuccess()) {
        Map<byte[],Integer> __this__success = new HashMap<byte[],Integer>();
        for (Map.Entry<byte[], Integer> other_element : other.success.entrySet()) {

          byte[] other_element_key = other_element.getKey();
          Integer other_element_value = other_element.getValue();

          byte[] __this__success_copy_key = new byte[other_element_key.length];
          System.arraycopy(other_element_key, 0, __this__success_copy_key, 0, other_element_key.length);

          Integer __this__success_copy_value = other_element_value;

          __this__success.put(__this__success_copy_key, __this__success_copy_value);
        }
        this.success = __this__success;
      }
      if (other.isSetIre()) {
        this.ire = new InvalidRequestException(other.ire);
      }
      if (other.isSetUe()) {
        this.ue = new UnavailableException(other.ue);
      }
      if (other.isSetTe()) {
        this.te = new TimedOutException(other.te);
      }
    }

    public multiget_count_result deepCopy() {
      return new multiget_count_result(this);
    }

    @Deprecated
    public multiget_count_result clone() {
      return new multiget_count_result(this);
    }

    public int getSuccessSize() {
      return (this.success == null) ? 0 : this.success.size();
    }

    public void putToSuccess(byte[] key, int val) {
      if (this.success == null) {
        this.success = new HashMap<byte[],Integer>();
      }
      this.success.put(key, val);
    }

    public Map<byte[],Integer> getSuccess() {
      return this.success;
    }

    public multiget_count_result setSuccess(Map<byte[],Integer> success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    /** Returns true if field success is set (has been asigned a value) and false otherwise */
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public InvalidRequestException getIre() {
      return this.ire;
    }

    public multiget_count_result setIre(InvalidRequestException ire) {
      this.ire = ire;
      return this;
    }

    public void unsetIre() {
      this.ire = null;
    }

    /** Returns true if field ire is set (has been asigned a value) and false otherwise */
    public boolean isSetIre() {
      return this.ire != null;
    }

    public void setIreIsSet(boolean value) {
      if (!value) {
        this.ire = null;
      }
    }

    public UnavailableException getUe() {
      return this.ue;
    }

    public multiget_count_result setUe(UnavailableException ue) {
      this.ue = ue;
      return this;
    }

    public void unsetUe() {
      this.ue = null;
    }

    /** Returns true if field ue is set (has been asigned a value) and false otherwise */
    public boolean isSetUe() {
      return this.ue != null;
    }

    public void setUeIsSet(boolean value) {
      if (!value) {
        this.ue = null;
      }
    }

    public TimedOutException getTe() {
      return this.te;
    }

    public multiget_count_result setTe(TimedOutException te) {
      this.te = te;
      return this;
    }

    public void unsetTe() {
      this.te = null;
    }

    /** Returns true if field te is set (has been asigned a value) and false otherwise */
    public boolean isSetTe() {
      return this.te != null;
    }

    public void setTeIsSet(boolean value) {
      if (!value) {
        this.te = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((Map<byte[],Integer>)value);
        }
        break;

      case IRE:
        if (value == null) {
          unsetIre();
        } else {
          setIre((InvalidRequestException)value);
        }
        break;

      case UE:
        if (value == null) {
          unsetUe();
        } else {
          setUe((UnavailableException)value);
        }
        break;

      case TE:
        if (value == null) {
          unsetTe();
        } else {
          setTe((TimedOutException)value);
        }
        break;

      }
    }

    public void setFieldValue(int fieldID, Object value) {
      setFieldValue(_Fields.findByThriftIdOrThrow(fieldID), value);
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case SUCCESS:
        return getSuccess();

      case IRE:
        return getIre();

      case UE:
        return getUe();

      case TE:
        return getTe();

      }
      throw new IllegalStateException();
    }

    public Object getFieldValue(int fieldId) {
      return getFieldValue(_Fields.findByThriftIdOrThrow(fieldId));
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      switch (field) {
      case SUCCESS:
        return isSetSuccess();
      case IRE:
        return isSetIre();
      case UE:
        return isSetUe();
      case TE:
        return isSetTe();
      }
      throw new IllegalStateException();
    }

    public boolean isSet(int fieldID) {
      return isSet(_Fields.findByThriftIdOrThrow(fieldID));
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof multiget_count_result)
        return this.equals((multiget_count_result)that);
      return false;
    }

    public boolean equals(multiget_count_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!this.success.equals(that.success))
          return false;
      }

      boolean this_present_ire = true && this.isSetIre();
      boolean that_present_ire = true && that.isSetIre();
      if (this_present_ire || that_present_ire) {
        if (!(this_present_ire && that_present_ire))
          return false;
        if (!this.ire.equals(that.ire))
          return false;
      }

      boolean this_present_ue = true && this.isSetUe();
      boolean that_present_ue = true && that.isSetUe();
      if (this_present_ue || that_present_ue) {
        if (!(this_present_ue && that_present_ue))
          return false;
        if (!this.ue.equals(that.ue))
          return false;
      }

      boolean this_present_te = true && this.isSetTe();
      boolean that_present_te = true && that.isSetTe();
      if (this_present_te || that_present_te) {
        if (!(this_present_te && that_present_te))
          return false;
        if (!this.te.equals(that.te))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 0: // SUCCESS
            if (field.type == TType.MAP) {
              {
                TMap _map59 = iprot.readMapBegin();
                this.success = new HashMap<byte[],Integer>(2*_map59.size);
                for (int _i60 = 0; _i60 < _map59.size; ++_i60)
                {
                  byte[] _key61;
                  int _val62;
                  _key61 = iprot.readBinary();
                  _val62 = iprot.readI32();
                  this.success.put(_key61, _val62);
                }
                iprot.readMapEnd();
              }
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 1: // IRE
            if (field.type == TType.STRUCT) {
              this.ire = new InvalidRequestException();
              this.ire.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 2: // UE
            if (field.type == TType.STRUCT) {
              this.ue = new UnavailableException();
              this.ue.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 3: // TE
            if (field.type == TType.STRUCT) {
              this.te = new TimedOutException();
              this.te.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        {
          oprot.writeMapBegin(new TMap(TType.STRING, TType.I32, this.success.size()));
          for (Map.Entry<byte[], Integer> _iter63 : this.success.entrySet())
          {
            oprot.writeBinary(_iter63.getKey());
            oprot.writeI32(_iter63.getValue());
          }
          oprot.writeMapEnd();
        }
        oprot.writeFieldEnd();
      } else if (this.isSetIre()) {
        oprot.writeFieldBegin(IRE_FIELD_DESC);
        this.ire.write(oprot);
        oprot.writeFieldEnd();
      } else if (this.isSetUe()) {
        oprot.writeFieldBegin(UE_FIELD_DESC);
        this.ue.write(oprot);
        oprot.writeFieldEnd();
      } else if (this.isSetTe()) {
        oprot.writeFieldBegin(TE_FIELD_DESC);
        this.te.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("multiget_count_result(");
      boolean first = true;

      sb.append("success:");
      if (this.success == null) {
        sb.append("null");
      } else {
        sb.append(this.success);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("ire:");
      if (this.ire == null) {
        sb.append("null");
      } else {
        sb.append(this.ire);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("ue:");
      if (this.ue == null) {
        sb.append("null");
      } else {
        sb.append(this.ue);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("te:");
      if (this.te == null) {
        sb.append("null");
      } else {
        sb.append(this.te);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class get_range_slice_args implements TBase<get_range_slice_args._Fields>, java.io.Serializable, Cloneable, Comparable<get_range_slice_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("get_range_slice_args");

    private static final TField KEYSPACE_FIELD_DESC = new TField("keyspace", TType.STRING, (short)1);
    private static final TField COLUMN_PARENT_FIELD_DESC = new TField("column_parent", TType.STRUCT, (short)2);
    private static final TField PREDICATE_FIELD_DESC = new TField("predicate", TType.STRUCT, (short)3);
    private static final TField START_KEY_FIELD_DESC = new TField("start_key", TType.STRING, (short)4);
    private static final TField FINISH_KEY_FIELD_DESC = new TField("finish_key", TType.STRING, (short)5);
    private static final TField ROW_COUNT_FIELD_DESC = new TField("row_count", TType.I32, (short)6);
    private static final TField CONSISTENCY_LEVEL_FIELD_DESC = new TField("consistency_level", TType.I32, (short)7);

    public String keyspace;
    public ColumnParent column_parent;
    public SlicePredicate predicate;
    public byte[] start_key;
    public byte[] finish_key;
    public int row_count;
    /**
     * 
     * @see ConsistencyLevel
     */
    public ConsistencyLevel consistency_level;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      KEYSPACE((short)1, "keyspace"),
      COLUMN_PARENT((short)2, "column_parent"),
      PREDICATE((short)3, "predicate"),
      START_KEY((short)4, "start_key"),
      FINISH_KEY((short)5, "finish_key"),
      ROW_COUNT((short)6, "row_count"),
      /**
       * 
       * @see ConsistencyLevel
       */
      CONSISTENCY_LEVEL((short)7, "consistency_level");

      private static final Map<Integer, _Fields> byId = new HashMap<Integer, _Fields>();
      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byId.put((int)field._thriftId, field);
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        return byId.get(fieldId);
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments
    private static final int __ROW_COUNT_ISSET_ID = 0;
    private BitSet __isset_bit_vector = new BitSet(1);

    public static final Map<_Fields, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new EnumMap<_Fields, FieldMetaData>(_Fields.class) {{
      put(_Fields.KEYSPACE, new FieldMetaData("keyspace", TFieldRequirementType.REQUIRED, 
          new FieldValueMetaData(TType.STRING)));
      put(_Fields.COLUMN_PARENT, new FieldMetaData("column_parent", TFieldRequirementType.REQUIRED, 
          new StructMetaData(TType.STRUCT, ColumnParent.class)));
      put(_Fields.PREDICATE, new FieldMetaData("predicate", TFieldRequirementType.REQUIRED, 
          new StructMetaData(TType.STRUCT, SlicePredicate.class)));
      put(_Fields.START_KEY, new FieldMetaData("start_key", TFieldRequirementType.REQUIRED, 
          new FieldValueMetaData(TType.STRING)));
      put(_Fields.FINISH_KEY, new FieldMetaData("finish_key", TFieldRequirementType.REQUIRED, 
          new FieldValueMetaData(TType.STRING)));
      put(_Fields.ROW_COUNT, new FieldMetaData("row_count", TFieldRequirementType.REQUIRED, 
          new FieldValueMetaData(TType.I32)));
      put(_Fields.CONSISTENCY_LEVEL, new FieldMetaData("consistency_level", TFieldRequirementType.REQUIRED, 
          new EnumMetaData(TType.ENUM, ConsistencyLevel.class)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(get_range_slice_args.class, metaDataMap);
    }

    public get_range_slice_args() {
      this.row_count = 100;

      this.consistency_level = ConsistencyLevel.ONE;

    }

    public get_range_slice_args(
      String keyspace,
      ColumnParent column_parent,
      SlicePredicate predicate,
      byte[] start_key,
      byte[] finish_key,
      int row_count,
      ConsistencyLevel consistency_level)
    {
      this();
      this.keyspace = keyspace;
      this.column_parent = column_parent;
      this.predicate = predicate;
      this.start_key = start_key;
      this.finish_key = finish_key;
      this.row_count = row_count;
      setRow_countIsSet(true);
      this.consistency_level = consistency_level;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public get_range_slice_args(get_range_slice_args other) {
      __isset_bit_vector.clear();
      __isset_bit_vector.or(other.__isset_bit_vector);
      if (other.isSetKeyspace()) {
        this.keyspace = other.keyspace;
      }
      if (other.isSetColumn_parent()) {
        this.column_parent = new ColumnParent(other.column_parent);
      }
      if (other.isSetPredicate()) {
        this.predicate = new SlicePredicate(other.predicate);
      }
      if (other.isSetStart_key()) {
        this.start_key = new byte[other.start_key.length];
        System.arraycopy(other.start_key, 0, start_key, 0, other.start_key.length);
      }
      if (other.isSetFinish_key()) {
        this.finish_key = new byte[other.finish_key.length];
        System.arraycopy(other.finish_key, 0, finish_key, 0, other.finish_key.length);
      }
      this.row_count = other.row_count;
      if (other.isSetConsistency_level()) {
        this.consistency_level = other.consistency_level;
      }
    }

    public get_range_slice_args deepCopy() {
      return new get_range_slice_args(this);
    }

    @Deprecated
    public get_range_slice_args clone() {
      return new get_range_slice_args(this);
    }

    public String getKeyspace() {
      return this.keyspace;
    }

    public get_range_slice_args setKeyspace(String keyspace) {
      this.keyspace = keyspace;
      return this;
    }

    public void unsetKeyspace() {
      this.keyspace = null;
    }

    /** Returns true if field keyspace is set (has been asigned a value) and false otherwise */
    public boolean isSetKeyspace() {
      return this.keyspace != null;
    }

    public void setKeyspaceIsSet(boolean value) {
      if (!value) {
        this.keyspace = null;
      }
    }

    public ColumnParent getColumn_parent() {
      return this.column_parent;
     }
 
     public get_range_slice_args setColumn_parent(ColumnParent column_parent) {
       this.column_parent = column_parent;
       return this;
     }
 
     public void unsetColumn_parent() {
       this.column_parent = null;
     }
 
     /** Returns true if field column_parent is set (has been asigned a value) and false otherwise */
     public boolean isSetColumn_parent() {
       return this.column_parent != null;
     }
 
     public void setColumn_parentIsSet(boolean value) {
       if (!value) {
         this.column_parent = null;
       }
     }
 
     public SlicePredicate getPredicate() {
       return this.predicate;
     }
 
     public get_range_slice_args setPredicate(SlicePredicate predicate) {
       this.predicate = predicate;
       return this;
     }
 
     public void unsetPredicate() {
       this.predicate = null;
     }
 
     /** Returns true if field predicate is set (has been asigned a value) and false otherwise */
     public boolean isSetPredicate() {
       return this.predicate != null;
     }
 
     public void setPredicateIsSet(boolean value) {
       if (!value) {
         this.predicate = null;
       }
     }
 
     public byte[] getStart_key() {
       return this.start_key;
     }
 
     public get_range_slice_args setStart_key(byte[] start_key) {
       this.start_key = start_key;
       return this;
     }
 
     public void unsetStart_key() {
       this.start_key = null;
     }
 
     /** Returns true if field start_key is set (has been asigned a value) and false otherwise */
     public boolean isSetStart_key() {
       return this.start_key != null;
     }
 
     public void setStart_keyIsSet(boolean value) {
       if (!value) {
         this.start_key = null;
       }
     }
 
     public byte[] getFinish_key() {
       return this.finish_key;
     }
 
     public get_range_slice_args setFinish_key(byte[] finish_key) {
       this.finish_key = finish_key;
       return this;
     }
 
     public void unsetFinish_key() {
       this.finish_key = null;
     }
 
     /** Returns true if field finish_key is set (has been asigned a value) and false otherwise */
     public boolean isSetFinish_key() {
       return this.finish_key != null;
     }
 
     public void setFinish_keyIsSet(boolean value) {
       if (!value) {
         this.finish_key = null;
       }
     }
 
     public int getRow_count() {
       return this.row_count;
     }
 
     public get_range_slice_args setRow_count(int row_count) {
       this.row_count = row_count;
       setRow_countIsSet(true);
       return this;
     }
 
     public void unsetRow_count() {
       __isset_bit_vector.clear(__ROW_COUNT_ISSET_ID);
     }
 
     /** Returns true if field row_count is set (has been asigned a value) and false otherwise */
     public boolean isSetRow_count() {
       return __isset_bit_vector.get(__ROW_COUNT_ISSET_ID);
     }
 
     public void setRow_countIsSet(boolean value) {
       __isset_bit_vector.set(__ROW_COUNT_ISSET_ID, value);
     }
 
     /**
      * 
      * @see ConsistencyLevel
      */
     public ConsistencyLevel getConsistency_level() {
       return this.consistency_level;
     }
 
     /**
      * 
      * @see ConsistencyLevel
      */
     public get_range_slice_args setConsistency_level(ConsistencyLevel consistency_level) {
       this.consistency_level = consistency_level;
       return this;
     }
 
     public void unsetConsistency_level() {
       this.consistency_level = null;
     }
 
     /** Returns true if field consistency_level is set (has been asigned a value) and false otherwise */
     public boolean isSetConsistency_level() {
       return this.consistency_level != null;
     }
 
     public void setConsistency_levelIsSet(boolean value) {
       if (!value) {
         this.consistency_level = null;
       }
     }
 
     public void setFieldValue(_Fields field, Object value) {
       switch (field) {
       case KEYSPACE:
         if (value == null) {
           unsetKeyspace();
         } else {
           setKeyspace((String)value);
         }
         break;
 
       case COLUMN_PARENT:
         if (value == null) {
           unsetColumn_parent();
         } else {
           setColumn_parent((ColumnParent)value);
         }
         break;
 
       case PREDICATE:
         if (value == null) {
           unsetPredicate();
         } else {
           setPredicate((SlicePredicate)value);
         }
         break;
 
       case START_KEY:
         if (value == null) {
           unsetStart_key();
         } else {
           setStart_key((byte[])value);
         }
         break;
 
       case FINISH_KEY:
         if (value == null) {
           unsetFinish_key();
         } else {
           setFinish_key((byte[])value);
         }
         break;
 
       case ROW_COUNT:
         if (value == null) {
           unsetRow_count();
         } else {
           setRow_count((Integer)value);
         }
         break;
 
       case CONSISTENCY_LEVEL:
         if (value == null) {
           unsetConsistency_level();
         } else {
           setConsistency_level((ConsistencyLevel)value);
         }
         break;
 
       }
     }
 
     public void setFieldValue(int fieldID, Object value) {
       setFieldValue(_Fields.findByThriftIdOrThrow(fieldID), value);
     }
 
     public Object getFieldValue(_Fields field) {
       switch (field) {
       case KEYSPACE:
         return getKeyspace();
 
       case COLUMN_PARENT:
         return getColumn_parent();
 
       case PREDICATE:
         return getPredicate();
 
       case START_KEY:
         return getStart_key();
 
       case FINISH_KEY:
         return getFinish_key();
 
       case ROW_COUNT:
         return new Integer(getRow_count());
 
       case CONSISTENCY_LEVEL:
         return getConsistency_level();
 
       }
       throw new IllegalStateException();
     }
 
     public Object getFieldValue(int fieldId) {
       return getFieldValue(_Fields.findByThriftIdOrThrow(fieldId));
     }
 
     /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
     public boolean isSet(_Fields field) {
       switch (field) {
       case KEYSPACE:
         return isSetKeyspace();
       case COLUMN_PARENT:
         return isSetColumn_parent();
       case PREDICATE:
         return isSetPredicate();
       case START_KEY:
         return isSetStart_key();
       case FINISH_KEY:
         return isSetFinish_key();
       case ROW_COUNT:
         return isSetRow_count();
       case CONSISTENCY_LEVEL:
         return isSetConsistency_level();
       }
       throw new IllegalStateException();
     }
 
     public boolean isSet(int fieldID) {
       return isSet(_Fields.findByThriftIdOrThrow(fieldID));
     }
 
     @Override
     public boolean equals(Object that) {
       if (that == null)
         return false;
       if (that instanceof get_range_slice_args)
         return this.equals((get_range_slice_args)that);
       return false;
     }
 
     public boolean equals(get_range_slice_args that) {
       if (that == null)
         return false;
 
       boolean this_present_keyspace = true && this.isSetKeyspace();
       boolean that_present_keyspace = true && that.isSetKeyspace();
       if (this_present_keyspace || that_present_keyspace) {
         if (!(this_present_keyspace && that_present_keyspace))
           return false;
         if (!this.keyspace.equals(that.keyspace))
           return false;
       }
 
       boolean this_present_column_parent = true && this.isSetColumn_parent();
       boolean that_present_column_parent = true && that.isSetColumn_parent();
       if (this_present_column_parent || that_present_column_parent) {
         if (!(this_present_column_parent && that_present_column_parent))
           return false;
         if (!this.column_parent.equals(that.column_parent))
           return false;
       }
 
       boolean this_present_predicate = true && this.isSetPredicate();
       boolean that_present_predicate = true && that.isSetPredicate();
       if (this_present_predicate || that_present_predicate) {
         if (!(this_present_predicate && that_present_predicate))
           return false;
         if (!this.predicate.equals(that.predicate))
           return false;
       }
 
       boolean this_present_start_key = true && this.isSetStart_key();
       boolean that_present_start_key = true && that.isSetStart_key();
       if (this_present_start_key || that_present_start_key) {
         if (!(this_present_start_key && that_present_start_key))
           return false;
         if (!java.util.Arrays.equals(this.start_key, that.start_key))
           return false;
       }
 
       boolean this_present_finish_key = true && this.isSetFinish_key();
       boolean that_present_finish_key = true && that.isSetFinish_key();
       if (this_present_finish_key || that_present_finish_key) {
         if (!(this_present_finish_key && that_present_finish_key))
           return false;
         if (!java.util.Arrays.equals(this.finish_key, that.finish_key))
           return false;
       }
 
       boolean this_present_row_count = true;
       boolean that_present_row_count = true;
       if (this_present_row_count || that_present_row_count) {
         if (!(this_present_row_count && that_present_row_count))
           return false;
         if (this.row_count != that.row_count)
           return false;
       }
 
       boolean this_present_consistency_level = true && this.isSetConsistency_level();
       boolean that_present_consistency_level = true && that.isSetConsistency_level();
       if (this_present_consistency_level || that_present_consistency_level) {
         if (!(this_present_consistency_level && that_present_consistency_level))
           return false;
         if (!this.consistency_level.equals(that.consistency_level))
           return false;
       }
 
       return true;
     }
 
     @Override
     public int hashCode() {
       return 0;
     }
 
     public int compareTo(get_range_slice_args other) {
       if (!getClass().equals(other.getClass())) {
         return getClass().getName().compareTo(other.getClass().getName());
       }
 
       int lastComparison = 0;
       get_range_slice_args typedOther = (get_range_slice_args)other;
 
       lastComparison = Boolean.valueOf(isSetKeyspace()).compareTo(typedOther.isSetKeyspace());
       if (lastComparison != 0) {
         return lastComparison;
       }
       if (isSetKeyspace()) {        lastComparison = TBaseHelper.compareTo(keyspace, typedOther.keyspace);
         if (lastComparison != 0) {
           return lastComparison;
         }
       }
       lastComparison = Boolean.valueOf(isSetColumn_parent()).compareTo(typedOther.isSetColumn_parent());
       if (lastComparison != 0) {
         return lastComparison;
       }
       if (isSetColumn_parent()) {        lastComparison = TBaseHelper.compareTo(column_parent, typedOther.column_parent);
         if (lastComparison != 0) {
           return lastComparison;
         }
       }
       lastComparison = Boolean.valueOf(isSetPredicate()).compareTo(typedOther.isSetPredicate());
       if (lastComparison != 0) {
         return lastComparison;
       }
       if (isSetPredicate()) {        lastComparison = TBaseHelper.compareTo(predicate, typedOther.predicate);
         if (lastComparison != 0) {
           return lastComparison;
         }
       }
       lastComparison = Boolean.valueOf(isSetStart_key()).compareTo(typedOther.isSetStart_key());
       if (lastComparison != 0) {
         return lastComparison;
       }
       if (isSetStart_key()) {        lastComparison = TBaseHelper.compareTo(start_key, typedOther.start_key);
         if (lastComparison != 0) {
           return lastComparison;
         }
       }
       lastComparison = Boolean.valueOf(isSetFinish_key()).compareTo(typedOther.isSetFinish_key());
       if (lastComparison != 0) {
         return lastComparison;
       }
       if (isSetFinish_key()) {        lastComparison = TBaseHelper.compareTo(finish_key, typedOther.finish_key);
         if (lastComparison != 0) {
           return lastComparison;
         }
       }
       lastComparison = Boolean.valueOf(isSetRow_count()).compareTo(typedOther.isSetRow_count());
       if (lastComparison != 0) {
         return lastComparison;
       }
       if (isSetRow_count()) {        lastComparison = TBaseHelper.compareTo(row_count, typedOther.row_count);
         if (lastComparison != 0) {
           return lastComparison;
         }
       }
       lastComparison = Boolean.valueOf(isSetConsistency_level()).compareTo(typedOther.isSetConsistency_level());
       if (lastComparison != 0) {
         return lastComparison;
       }
       if (isSetConsistency_level()) {        lastComparison = TBaseHelper.compareTo(consistency_level, typedOther.consistency_level);
         if (lastComparison != 0) {
           return lastComparison;
         }
       }
       return 0;
     }
 
     public void read(TProtocol iprot) throws TException {
       TField field;
       iprot.readStructBegin();
       while (true)
       {
         field = iprot.readFieldBegin();
         if (field.type == TType.STOP) { 
           break;
         }
         switch (field.id) {
           case 1: // KEYSPACE
             if (field.type == TType.STRING) {
               this.keyspace = iprot.readString();
             } else { 
               TProtocolUtil.skip(iprot, field.type);
             }
             break;
           case 2: // COLUMN_PARENT
             if (field.type == TType.STRUCT) {
               this.column_parent = new ColumnParent();
               this.column_parent.read(iprot);
             } else { 
               TProtocolUtil.skip(iprot, field.type);
             }
             break;
           case 3: // PREDICATE
             if (field.type == TType.STRUCT) {
               this.predicate = new SlicePredicate();
               this.predicate.read(iprot);
             } else { 
               TProtocolUtil.skip(iprot, field.type);
             }
             break;
           case 4: // START_KEY
             if (field.type == TType.STRING) {
               this.start_key = iprot.readBinary();
             } else { 
               TProtocolUtil.skip(iprot, field.type);
             }
             break;
           case 5: // FINISH_KEY
             if (field.type == TType.STRING) {
               this.finish_key = iprot.readBinary();
             } else { 
               TProtocolUtil.skip(iprot, field.type);
             }
             break;
           case 6: // ROW_COUNT
             if (field.type == TType.I32) {
               this.row_count = iprot.readI32();
               setRow_countIsSet(true);
             } else { 
               TProtocolUtil.skip(iprot, field.type);
             }
             break;
           case 7: // CONSISTENCY_LEVEL
             if (field.type == TType.I32) {
               this.consistency_level = ConsistencyLevel.findByValue(iprot.readI32());
             } else { 
               TProtocolUtil.skip(iprot, field.type);
             }
             break;
           default:
             TProtocolUtil.skip(iprot, field.type);
         }
         iprot.readFieldEnd();
       }
       iprot.readStructEnd();
 
       // check for required fields of primitive type, which can't be checked in the validate method
       if (!isSetRow_count()) {
         throw new TProtocolException("Required field 'row_count' was not found in serialized data! Struct: " + toString());
       }
       validate();
     }
 
     public void write(TProtocol oprot) throws TException {
       validate();
 
       oprot.writeStructBegin(STRUCT_DESC);
       if (this.keyspace != null) {
         oprot.writeFieldBegin(KEYSPACE_FIELD_DESC);
         oprot.writeString(this.keyspace);
         oprot.writeFieldEnd();
       }
       if (this.column_parent != null) {
         oprot.writeFieldBegin(COLUMN_PARENT_FIELD_DESC);
         this.column_parent.write(oprot);
         oprot.writeFieldEnd();
       }
       if (this.predicate != null) {
         oprot.writeFieldBegin(PREDICATE_FIELD_DESC);
         this.predicate.write(oprot);
         oprot.writeFieldEnd();
       }
       if (this.start_key != null) {
         oprot.writeFieldBegin(START_KEY_FIELD_DESC);
         oprot.writeBinary(this.start_key);
         oprot.writeFieldEnd();
       }
       if (this.finish_key != null) {
         oprot.writeFieldBegin(FINISH_KEY_FIELD_DESC);
         oprot.writeBinary(this.finish_key);
         oprot.writeFieldEnd();
       }
       oprot.writeFieldBegin(ROW_COUNT_FIELD_DESC);
       oprot.writeI32(this.row_count);
       oprot.writeFieldEnd();
       if (this.consistency_level != null) {
         oprot.writeFieldBegin(CONSISTENCY_LEVEL_FIELD_DESC);
         oprot.writeI32(this.consistency_level.getValue());
         oprot.writeFieldEnd();
       }
       oprot.writeFieldStop();
       oprot.writeStructEnd();
     }
 
     @Override
     public String toString() {
       StringBuilder sb = new StringBuilder("get_range_slice_args(");
       boolean first = true;
 
       sb.append("keyspace:");
       if (this.keyspace == null) {
         sb.append("null");
       } else {
         sb.append(this.keyspace);
       }
       first = false;
       if (!first) sb.append(", ");
       sb.append("column_parent:");
       if (this.column_parent == null) {
         sb.append("null");
       } else {
         sb.append(this.column_parent);
       }
       first = false;
       if (!first) sb.append(", ");
       sb.append("predicate:");
       if (this.predicate == null) {
         sb.append("null");
       } else {
         sb.append(this.predicate);
       }
       first = false;
       if (!first) sb.append(", ");
       sb.append("start_key:");
       if (this.start_key == null) {
         sb.append("null");
       } else {
           int __start_key_size = Math.min(this.start_key.length, 128);
           for (int i = 0; i < __start_key_size; i++) {
             if (i != 0) sb.append(" ");
             sb.append(Integer.toHexString(this.start_key[i]).length() > 1 ? Integer.toHexString(this.start_key[i]).substring(Integer.toHexString(this.start_key[i]).length() - 2).toUpperCase() : "0" + Integer.toHexString(this.start_key[i]).toUpperCase());
           }
           if (this.start_key.length > 128) sb.append(" ...");
       }
       first = false;
       if (!first) sb.append(", ");
       sb.append("finish_key:");
       if (this.finish_key == null) {
         sb.append("null");
       } else {
           int __finish_key_size = Math.min(this.finish_key.length, 128);
           for (int i = 0; i < __finish_key_size; i++) {
             if (i != 0) sb.append(" ");
             sb.append(Integer.toHexString(this.finish_key[i]).length() > 1 ? Integer.toHexString(this.finish_key[i]).substring(Integer.toHexString(this.finish_key[i]).length() - 2).toUpperCase() : "0" + Integer.toHexString(this.finish_key[i]).toUpperCase());
           }
           if (this.finish_key.length > 128) sb.append(" ...");
       }
       first = false;
       if (!first) sb.append(", ");
       sb.append("row_count:");
       sb.append(this.row_count);
       first = false;
       if (!first) sb.append(", ");
       sb.append("consistency_level:");
       if (this.consistency_level == null) {
         sb.append("null");
       } else {
         sb.append(this.consistency_level);
       }
       first = false;
       sb.append(")");
       return sb.toString();
     }
 
     public void validate() throws TException {
       // check for required fields
       if (keyspace == null) {
         throw new TProtocolException("Required field 'keyspace' was not present! Struct: " + toString());
       }
       if (column_parent == null) {
         throw new TProtocolException("Required field 'column_parent' was not present! Struct: " + toString());
       }
       if (predicate == null) {
         throw new TProtocolException("Required field 'predicate' was not present! Struct: " + toString());
       }
       if (start_key == null) {
         throw new TProtocolException("Required field 'start_key' was not present! Struct: " + toString());
       }
       if (finish_key == null) {
         throw new TProtocolException("Required field 'finish_key' was not present! Struct: " + toString());
       }
       // alas, we cannot check 'row_count' because it's a primitive and you chose the non-beans generator.
       if (consistency_level == null) {
         throw new TProtocolException("Required field 'consistency_level' was not present! Struct: " + toString());
       }
     }
 
   }
 
   public static class get_range_slice_result implements TBase<get_range_slice_result._Fields>, java.io.Serializable, Cloneable, Comparable<get_range_slice_result>   {
     private static final TStruct STRUCT_DESC = new TStruct("get_range_slice_result");
 
     private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.LIST, (short)0);
     private static final TField IRE_FIELD_DESC = new TField("ire", TType.STRUCT, (short)1);
     private static final TField UE_FIELD_DESC = new TField("ue", TType.STRUCT, (short)2);
     private static final TField TE_FIELD_DESC = new TField("te", TType.STRUCT, (short)3);
 
     public List<KeySlice> success;
     public InvalidRequestException ire;
     public UnavailableException ue;
     public TimedOutException te;
 
     /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
     public enum _Fields implements TFieldIdEnum {
       SUCCESS((short)0, "success"),
       IRE((short)1, "ire"),
       UE((short)2, "ue"),
       TE((short)3, "te");
 
       private static final Map<Integer, _Fields> byId = new HashMap<Integer, _Fields>();
       private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();
 
       static {
         for (_Fields field : EnumSet.allOf(_Fields.class)) {
           byId.put((int)field._thriftId, field);
           byName.put(field.getFieldName(), field);
         }
       }
 
       /**
        * Find the _Fields constant that matches fieldId, or null if its not found.
        */
       public static _Fields findByThriftId(int fieldId) {
         return byId.get(fieldId);
       }
 
       /**
        * Find the _Fields constant that matches fieldId, throwing an exception
        * if it is not found.
        */
       public static _Fields findByThriftIdOrThrow(int fieldId) {
         _Fields fields = findByThriftId(fieldId);
         if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
         return fields;
       }
 
       /**
        * Find the _Fields constant that matches name, or null if its not found.
        */
       public static _Fields findByName(String name) {
         return byName.get(name);
       }
 
       private final short _thriftId;
       private final String _fieldName;
 
       _Fields(short thriftId, String fieldName) {
         _thriftId = thriftId;
         _fieldName = fieldName;
       }
 
       public short getThriftFieldId() {
         return _thriftId;
       }
 
       public String getFieldName() {
         return _fieldName;
       }
     }
 
     // isset id assignments
 
     public static final Map<_Fields, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new EnumMap<_Fields, FieldMetaData>(_Fields.class) {{
       put(_Fields.SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
           new ListMetaData(TType.LIST, 
               new StructMetaData(TType.STRUCT, KeySlice.class))));
       put(_Fields.IRE, new FieldMetaData("ire", TFieldRequirementType.DEFAULT, 
           new FieldValueMetaData(TType.STRUCT)));
       put(_Fields.UE, new FieldMetaData("ue", TFieldRequirementType.DEFAULT, 
           new FieldValueMetaData(TType.STRUCT)));
       put(_Fields.TE, new FieldMetaData("te", TFieldRequirementType.DEFAULT, 
           new FieldValueMetaData(TType.STRUCT)));
     }});
 
     static {
       FieldMetaData.addStructMetaDataMap(get_range_slice_result.class, metaDataMap);
     }
 
     public get_range_slice_result() {
     }
 
     public get_range_slice_result(
       List<KeySlice> success,
       InvalidRequestException ire,
       UnavailableException ue,
       TimedOutException te)
     {
       this();
       this.success = success;
       this.ire = ire;
       this.ue = ue;
       this.te = te;
     }
 
     /**
      * Performs a deep copy on <i>other</i>.
      */
     public get_range_slice_result(get_range_slice_result other) {
       if (other.isSetSuccess()) {
         List<KeySlice> __this__success = new ArrayList<KeySlice>();
         for (KeySlice other_element : other.success) {
           __this__success.add(new KeySlice(other_element));
         }
         this.success = __this__success;
       }
       if (other.isSetIre()) {
         this.ire = new InvalidRequestException(other.ire);
       }
       if (other.isSetUe()) {
         this.ue = new UnavailableException(other.ue);
       }
       if (other.isSetTe()) {
         this.te = new TimedOutException(other.te);
       }
     }
 
     public get_range_slice_result deepCopy() {
       return new get_range_slice_result(this);
     }
 
     @Deprecated
     public get_range_slice_result clone() {
       return new get_range_slice_result(this);
     }
 
     public int getSuccessSize() {
       return (this.success == null) ? 0 : this.success.size();
     }
 
     public java.util.Iterator<KeySlice> getSuccessIterator() {
       return (this.success == null) ? null : this.success.iterator();
     }
 
     public void addToSuccess(KeySlice elem) {
       if (this.success == null) {
         this.success = new ArrayList<KeySlice>();
       }
       this.success.add(elem);
     }
 
     public List<KeySlice> getSuccess() {
       return this.success;
     }
 
     public get_range_slice_result setSuccess(List<KeySlice> success) {
       this.success = success;
       return this;
     }
 
     public void unsetSuccess() {
       this.success = null;
     }
 
     /** Returns true if field success is set (has been asigned a value) and false otherwise */
     public boolean isSetSuccess() {
       return this.success != null;
     }
 
     public void setSuccessIsSet(boolean value) {
       if (!value) {
         this.success = null;
       }
     }
 
     public InvalidRequestException getIre() {
       return this.ire;
     }
 
     public get_range_slice_result setIre(InvalidRequestException ire) {
       this.ire = ire;
       return this;
     }
 
     public void unsetIre() {
       this.ire = null;
     }
 
     /** Returns true if field ire is set (has been asigned a value) and false otherwise */
     public boolean isSetIre() {
       return this.ire != null;
     }
 
     public void setIreIsSet(boolean value) {
       if (!value) {
         this.ire = null;
       }
     }
 
     public UnavailableException getUe() {
       return this.ue;
     }
 
     public get_range_slice_result setUe(UnavailableException ue) {
       this.ue = ue;
       return this;
     }
 
     public void unsetUe() {
       this.ue = null;
     }
 
     /** Returns true if field ue is set (has been asigned a value) and false otherwise */
     public boolean isSetUe() {
       return this.ue != null;
     }
 
     public void setUeIsSet(boolean value) {
       if (!value) {
         this.ue = null;
       }
     }
 
     public TimedOutException getTe() {
       return this.te;
     }
 
     public get_range_slice_result setTe(TimedOutException te) {
       this.te = te;
       return this;
     }
 
     public void unsetTe() {
       this.te = null;
     }
 
     /** Returns true if field te is set (has been asigned a value) and false otherwise */
     public boolean isSetTe() {
       return this.te != null;
     }
 
     public void setTeIsSet(boolean value) {
       if (!value) {
         this.te = null;
       }
     }
 
     public void setFieldValue(_Fields field, Object value) {
       switch (field) {
       case SUCCESS:
         if (value == null) {
           unsetSuccess();
         } else {
           setSuccess((List<KeySlice>)value);
         }
         break;
 
       case IRE:
         if (value == null) {
           unsetIre();
         } else {
           setIre((InvalidRequestException)value);
         }
         break;
 
       case UE:
         if (value == null) {
           unsetUe();
         } else {
           setUe((UnavailableException)value);
         }
         break;
 
       case TE:
         if (value == null) {
           unsetTe();
         } else {
           setTe((TimedOutException)value);
         }
         break;
 
       }
     }
 
     public void setFieldValue(int fieldID, Object value) {
       setFieldValue(_Fields.findByThriftIdOrThrow(fieldID), value);
     }
 
     public Object getFieldValue(_Fields field) {
       switch (field) {
       case SUCCESS:
         return getSuccess();
 
       case IRE:
         return getIre();
 
       case UE:
         return getUe();
 
       case TE:
         return getTe();
 
       }
       throw new IllegalStateException();
     }
 
     public Object getFieldValue(int fieldId) {
       return getFieldValue(_Fields.findByThriftIdOrThrow(fieldId));
     }
 
     /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
     public boolean isSet(_Fields field) {
       switch (field) {
       case SUCCESS:
         return isSetSuccess();
       case IRE:
         return isSetIre();
       case UE:
         return isSetUe();
       case TE:
         return isSetTe();
       }
       throw new IllegalStateException();
     }
 
     public boolean isSet(int fieldID) {
       return isSet(_Fields.findByThriftIdOrThrow(fieldID));
     }
 
     @Override
     public boolean equals(Object that) {
       if (that == null)
         return false;
       if (that instanceof get_range_slice_result)
         return this.equals((get_range_slice_result)that);
       return false;
     }
 
     public boolean equals(get_range_slice_result that) {
       if (that == null)
         return false;
 
       boolean this_present_success = true && this.isSetSuccess();
       boolean that_present_success = true && that.isSetSuccess();
       if (this_present_success || that_present_success) {
         if (!(this_present_success && that_present_success))
           return false;
         if (!this.success.equals(that.success))
           return false;
       }
 
       boolean this_present_ire = true && this.isSetIre();
       boolean that_present_ire = true && that.isSetIre();
       if (this_present_ire || that_present_ire) {
         if (!(this_present_ire && that_present_ire))
           return false;
         if (!this.ire.equals(that.ire))
           return false;
       }
 
       boolean this_present_ue = true && this.isSetUe();
       boolean that_present_ue = true && that.isSetUe();
       if (this_present_ue || that_present_ue) {
         if (!(this_present_ue && that_present_ue))
           return false;
         if (!this.ue.equals(that.ue))
           return false;
       }
 
       boolean this_present_te = true && this.isSetTe();
       boolean that_present_te = true && that.isSetTe();
       if (this_present_te || that_present_te) {
         if (!(this_present_te && that_present_te))
           return false;
         if (!this.te.equals(that.te))
           return false;
       }
 
       return true;
     }
 
     @Override
     public int hashCode() {
       return 0;
     }
 
     public int compareTo(get_range_slice_result other) {
       if (!getClass().equals(other.getClass())) {
         return getClass().getName().compareTo(other.getClass().getName());
       }
 
       int lastComparison = 0;
       get_range_slice_result typedOther = (get_range_slice_result)other;
 
       lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(typedOther.isSetSuccess());
       if (lastComparison != 0) {
         return lastComparison;
       }
       if (isSetSuccess()) {        lastComparison = TBaseHelper.compareTo(success, typedOther.success);
         if (lastComparison != 0) {
           return lastComparison;
         }
       }
       lastComparison = Boolean.valueOf(isSetIre()).compareTo(typedOther.isSetIre());
       if (lastComparison != 0) {
         return lastComparison;
       }
       if (isSetIre()) {        lastComparison = TBaseHelper.compareTo(ire, typedOther.ire);
         if (lastComparison != 0) {
           return lastComparison;
         }
       }
       lastComparison = Boolean.valueOf(isSetUe()).compareTo(typedOther.isSetUe());
       if (lastComparison != 0) {
         return lastComparison;
       }
       if (isSetUe()) {        lastComparison = TBaseHelper.compareTo(ue, typedOther.ue);
         if (lastComparison != 0) {
           return lastComparison;
         }
       }
       lastComparison = Boolean.valueOf(isSetTe()).compareTo(typedOther.isSetTe());
       if (lastComparison != 0) {
         return lastComparison;
       }
       if (isSetTe()) {        lastComparison = TBaseHelper.compareTo(te, typedOther.te);
         if (lastComparison != 0) {
           return lastComparison;
         }
       }
       return 0;
     }
 
     public void read(TProtocol iprot) throws TException {
       TField field;
       iprot.readStructBegin();
       while (true)
       {
         field = iprot.readFieldBegin();
         if (field.type == TType.STOP) { 
           break;
         }
         switch (field.id) {
           case 0: // SUCCESS
             if (field.type == TType.LIST) {
               {
                TList _list64 = iprot.readListBegin();
                this.success = new ArrayList<KeySlice>(_list64.size);
                for (int _i65 = 0; _i65 < _list64.size; ++_i65)
                {
                  KeySlice _elem66;
                  _elem66 = new KeySlice();
                  _elem66.read(iprot);
                  this.success.add(_elem66);
                 }
                 iprot.readListEnd();
               }
             } else { 
               TProtocolUtil.skip(iprot, field.type);
             }
             break;
           case 1: // IRE
             if (field.type == TType.STRUCT) {
               this.ire = new InvalidRequestException();
               this.ire.read(iprot);
             } else { 
               TProtocolUtil.skip(iprot, field.type);
             }
             break;
           case 2: // UE
             if (field.type == TType.STRUCT) {
               this.ue = new UnavailableException();
               this.ue.read(iprot);
             } else { 
               TProtocolUtil.skip(iprot, field.type);
             }
             break;
           case 3: // TE
             if (field.type == TType.STRUCT) {
               this.te = new TimedOutException();
               this.te.read(iprot);
             } else { 
               TProtocolUtil.skip(iprot, field.type);
             }
             break;
           default:
             TProtocolUtil.skip(iprot, field.type);
         }
         iprot.readFieldEnd();
       }
       iprot.readStructEnd();
 
       // check for required fields of primitive type, which can't be checked in the validate method
       validate();
     }
 
     public void write(TProtocol oprot) throws TException {
       oprot.writeStructBegin(STRUCT_DESC);
 
       if (this.isSetSuccess()) {
         oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
         {
           oprot.writeListBegin(new TList(TType.STRUCT, this.success.size()));
          for (KeySlice _iter67 : this.success)
           {
            _iter67.write(oprot);
           }
           oprot.writeListEnd();
         }
         oprot.writeFieldEnd();
       } else if (this.isSetIre()) {
         oprot.writeFieldBegin(IRE_FIELD_DESC);
         this.ire.write(oprot);
         oprot.writeFieldEnd();
       } else if (this.isSetUe()) {
         oprot.writeFieldBegin(UE_FIELD_DESC);
         this.ue.write(oprot);
         oprot.writeFieldEnd();
       } else if (this.isSetTe()) {
         oprot.writeFieldBegin(TE_FIELD_DESC);
         this.te.write(oprot);
         oprot.writeFieldEnd();
       }
       oprot.writeFieldStop();
       oprot.writeStructEnd();
     }
 
     @Override
     public String toString() {
       StringBuilder sb = new StringBuilder("get_range_slice_result(");
       boolean first = true;
 
       sb.append("success:");
       if (this.success == null) {
         sb.append("null");
       } else {
         sb.append(this.success);
       }
       first = false;
       if (!first) sb.append(", ");
       sb.append("ire:");
       if (this.ire == null) {
         sb.append("null");
       } else {
         sb.append(this.ire);
       }
       first = false;
       if (!first) sb.append(", ");
       sb.append("ue:");
       if (this.ue == null) {
         sb.append("null");
       } else {
         sb.append(this.ue);
       }
       first = false;
       if (!first) sb.append(", ");
       sb.append("te:");
       if (this.te == null) {
         sb.append("null");
       } else {
         sb.append(this.te);
       }
       first = false;
       sb.append(")");
       return sb.toString();
     }
 
     public void validate() throws TException {
       // check for required fields
     }
 
   }
 
   public static class get_range_slices_args implements TBase<get_range_slices_args._Fields>, java.io.Serializable, Cloneable, Comparable<get_range_slices_args>   {
     private static final TStruct STRUCT_DESC = new TStruct("get_range_slices_args");
 
     private static final TField KEYSPACE_FIELD_DESC = new TField("keyspace", TType.STRING, (short)1);
     private static final TField COLUMN_PARENT_FIELD_DESC = new TField("column_parent", TType.STRUCT, (short)2);
     private static final TField PREDICATE_FIELD_DESC = new TField("predicate", TType.STRUCT, (short)3);
     private static final TField RANGE_FIELD_DESC = new TField("range", TType.STRUCT, (short)4);
     private static final TField CONSISTENCY_LEVEL_FIELD_DESC = new TField("consistency_level", TType.I32, (short)5);
 
     public String keyspace;
     public ColumnParent column_parent;
     public SlicePredicate predicate;
     public KeyRange range;
     /**
      * 
      * @see ConsistencyLevel
      */
     public ConsistencyLevel consistency_level;
 
     /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
     public enum _Fields implements TFieldIdEnum {
       KEYSPACE((short)1, "keyspace"),
       COLUMN_PARENT((short)2, "column_parent"),
       PREDICATE((short)3, "predicate"),
       RANGE((short)4, "range"),
       /**
        * 
        * @see ConsistencyLevel
        */
       CONSISTENCY_LEVEL((short)5, "consistency_level");
 
       private static final Map<Integer, _Fields> byId = new HashMap<Integer, _Fields>();
       private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();
 
       static {
         for (_Fields field : EnumSet.allOf(_Fields.class)) {
           byId.put((int)field._thriftId, field);
           byName.put(field.getFieldName(), field);
         }
       }
 
       /**
        * Find the _Fields constant that matches fieldId, or null if its not found.
        */
       public static _Fields findByThriftId(int fieldId) {
         return byId.get(fieldId);
       }
 
       /**
        * Find the _Fields constant that matches fieldId, throwing an exception
        * if it is not found.
        */
       public static _Fields findByThriftIdOrThrow(int fieldId) {
         _Fields fields = findByThriftId(fieldId);
         if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
         return fields;
       }
 
       /**
        * Find the _Fields constant that matches name, or null if its not found.
        */
       public static _Fields findByName(String name) {
         return byName.get(name);
       }
 
       private final short _thriftId;
       private final String _fieldName;
 
       _Fields(short thriftId, String fieldName) {
         _thriftId = thriftId;
         _fieldName = fieldName;
       }
 
       public short getThriftFieldId() {
         return _thriftId;
       }
 
       public String getFieldName() {
         return _fieldName;
       }
     }
 
     // isset id assignments
 
     public static final Map<_Fields, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new EnumMap<_Fields, FieldMetaData>(_Fields.class) {{
       put(_Fields.KEYSPACE, new FieldMetaData("keyspace", TFieldRequirementType.REQUIRED, 
           new FieldValueMetaData(TType.STRING)));
       put(_Fields.COLUMN_PARENT, new FieldMetaData("column_parent", TFieldRequirementType.REQUIRED, 
           new StructMetaData(TType.STRUCT, ColumnParent.class)));
       put(_Fields.PREDICATE, new FieldMetaData("predicate", TFieldRequirementType.REQUIRED, 
           new StructMetaData(TType.STRUCT, SlicePredicate.class)));
       put(_Fields.RANGE, new FieldMetaData("range", TFieldRequirementType.REQUIRED, 
           new StructMetaData(TType.STRUCT, KeyRange.class)));
       put(_Fields.CONSISTENCY_LEVEL, new FieldMetaData("consistency_level", TFieldRequirementType.REQUIRED, 
           new EnumMetaData(TType.ENUM, ConsistencyLevel.class)));
     }});
 
     static {
       FieldMetaData.addStructMetaDataMap(get_range_slices_args.class, metaDataMap);
     }
 
     public get_range_slices_args() {
       this.consistency_level = ConsistencyLevel.ONE;
 
     }
 
     public get_range_slices_args(
       String keyspace,
       ColumnParent column_parent,
       SlicePredicate predicate,
       KeyRange range,
       ConsistencyLevel consistency_level)
     {
       this();
       this.keyspace = keyspace;
       this.column_parent = column_parent;
       this.predicate = predicate;
       this.range = range;
       this.consistency_level = consistency_level;
     }
 
     /**
      * Performs a deep copy on <i>other</i>.
      */
     public get_range_slices_args(get_range_slices_args other) {
       if (other.isSetKeyspace()) {
         this.keyspace = other.keyspace;
       }
       if (other.isSetColumn_parent()) {
         this.column_parent = new ColumnParent(other.column_parent);
       }
       if (other.isSetPredicate()) {
         this.predicate = new SlicePredicate(other.predicate);
       }
       if (other.isSetRange()) {
         this.range = new KeyRange(other.range);
       }
       if (other.isSetConsistency_level()) {
         this.consistency_level = other.consistency_level;
       }
     }
 
     public get_range_slices_args deepCopy() {
       return new get_range_slices_args(this);
     }
 
     @Deprecated
     public get_range_slices_args clone() {
       return new get_range_slices_args(this);
     }
 
     public String getKeyspace() {
       return this.keyspace;
     }
 
     public get_range_slices_args setKeyspace(String keyspace) {
       this.keyspace = keyspace;
       return this;
     }
 
     public void unsetKeyspace() {
       this.keyspace = null;
     }
 
     /** Returns true if field keyspace is set (has been asigned a value) and false otherwise */
     public boolean isSetKeyspace() {
       return this.keyspace != null;
     }
 
     public void setKeyspaceIsSet(boolean value) {
       if (!value) {
         this.keyspace = null;
       }
     }
 
     public ColumnParent getColumn_parent() {
       return this.column_parent;
     }
 
     public get_range_slices_args setColumn_parent(ColumnParent column_parent) {
       this.column_parent = column_parent;
       return this;
     }
 
     public void unsetColumn_parent() {
       this.column_parent = null;
     }
 
     /** Returns true if field column_parent is set (has been asigned a value) and false otherwise */
     public boolean isSetColumn_parent() {
       return this.column_parent != null;
     }
 
     public void setColumn_parentIsSet(boolean value) {
       if (!value) {
         this.column_parent = null;
       }
     }
 
     public SlicePredicate getPredicate() {
       return this.predicate;
     }
 
     public get_range_slices_args setPredicate(SlicePredicate predicate) {
       this.predicate = predicate;
       return this;
     }
 
     public void unsetPredicate() {
       this.predicate = null;
     }
 
     /** Returns true if field predicate is set (has been asigned a value) and false otherwise */
     public boolean isSetPredicate() {
       return this.predicate != null;
     }
 
     public void setPredicateIsSet(boolean value) {
       if (!value) {
         this.predicate = null;
       }
     }
 
     public KeyRange getRange() {
       return this.range;
     }
 
     public get_range_slices_args setRange(KeyRange range) {
       this.range = range;
       return this;
     }
 
     public void unsetRange() {
       this.range = null;
     }
 
     /** Returns true if field range is set (has been asigned a value) and false otherwise */
     public boolean isSetRange() {
       return this.range != null;
     }
 
     public void setRangeIsSet(boolean value) {
       if (!value) {
         this.range = null;
       }
     }
 
     /**
      * 
      * @see ConsistencyLevel
      */
     public ConsistencyLevel getConsistency_level() {
       return this.consistency_level;
     }
 
     /**
      * 
      * @see ConsistencyLevel
      */
     public get_range_slices_args setConsistency_level(ConsistencyLevel consistency_level) {
       this.consistency_level = consistency_level;
       return this;
     }
 
     public void unsetConsistency_level() {
       this.consistency_level = null;
     }
 
     /** Returns true if field consistency_level is set (has been asigned a value) and false otherwise */
     public boolean isSetConsistency_level() {
       return this.consistency_level != null;
     }
 
     public void setConsistency_levelIsSet(boolean value) {
       if (!value) {
         this.consistency_level = null;
       }
     }
 
     public void setFieldValue(_Fields field, Object value) {
       switch (field) {
       case KEYSPACE:
         if (value == null) {
           unsetKeyspace();
         } else {
           setKeyspace((String)value);
         }
         break;
 
       case COLUMN_PARENT:
         if (value == null) {
           unsetColumn_parent();
         } else {
           setColumn_parent((ColumnParent)value);
         }
         break;
 
       case PREDICATE:
         if (value == null) {
           unsetPredicate();
         } else {
           setPredicate((SlicePredicate)value);
         }
         break;
 
       case RANGE:
         if (value == null) {
           unsetRange();
         } else {
           setRange((KeyRange)value);
         }
         break;
 
       case CONSISTENCY_LEVEL:
         if (value == null) {
           unsetConsistency_level();
         } else {
           setConsistency_level((ConsistencyLevel)value);
         }
         break;
 
       }
     }
 
     public void setFieldValue(int fieldID, Object value) {
       setFieldValue(_Fields.findByThriftIdOrThrow(fieldID), value);
     }
 
     public Object getFieldValue(_Fields field) {
       switch (field) {
       case KEYSPACE:
         return getKeyspace();
 
       case COLUMN_PARENT:
         return getColumn_parent();
 
       case PREDICATE:
         return getPredicate();
 
       case RANGE:
         return getRange();
 
       case CONSISTENCY_LEVEL:
         return getConsistency_level();
 
       }
       throw new IllegalStateException();
     }
 
     public Object getFieldValue(int fieldId) {
       return getFieldValue(_Fields.findByThriftIdOrThrow(fieldId));
     }
 
     /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
     public boolean isSet(_Fields field) {
       switch (field) {
       case KEYSPACE:
         return isSetKeyspace();
       case COLUMN_PARENT:
         return isSetColumn_parent();
       case PREDICATE:
         return isSetPredicate();
       case RANGE:
         return isSetRange();
       case CONSISTENCY_LEVEL:
         return isSetConsistency_level();
       }
       throw new IllegalStateException();
     }
 
     public boolean isSet(int fieldID) {
       return isSet(_Fields.findByThriftIdOrThrow(fieldID));
     }
 
     @Override
     public boolean equals(Object that) {
       if (that == null)
         return false;
       if (that instanceof get_range_slices_args)
         return this.equals((get_range_slices_args)that);
       return false;
     }
 
     public boolean equals(get_range_slices_args that) {
       if (that == null)
         return false;
 
       boolean this_present_keyspace = true && this.isSetKeyspace();
       boolean that_present_keyspace = true && that.isSetKeyspace();
       if (this_present_keyspace || that_present_keyspace) {
         if (!(this_present_keyspace && that_present_keyspace))
           return false;
         if (!this.keyspace.equals(that.keyspace))
           return false;
       }
 
       boolean this_present_column_parent = true && this.isSetColumn_parent();
       boolean that_present_column_parent = true && that.isSetColumn_parent();
       if (this_present_column_parent || that_present_column_parent) {
         if (!(this_present_column_parent && that_present_column_parent))
           return false;
         if (!this.column_parent.equals(that.column_parent))
           return false;
       }
 
       boolean this_present_predicate = true && this.isSetPredicate();
       boolean that_present_predicate = true && that.isSetPredicate();
       if (this_present_predicate || that_present_predicate) {
         if (!(this_present_predicate && that_present_predicate))
           return false;
         if (!this.predicate.equals(that.predicate))
           return false;
       }
 
       boolean this_present_range = true && this.isSetRange();
       boolean that_present_range = true && that.isSetRange();
       if (this_present_range || that_present_range) {
         if (!(this_present_range && that_present_range))
           return false;
         if (!this.range.equals(that.range))
           return false;
       }
 
       boolean this_present_consistency_level = true && this.isSetConsistency_level();
       boolean that_present_consistency_level = true && that.isSetConsistency_level();
       if (this_present_consistency_level || that_present_consistency_level) {
         if (!(this_present_consistency_level && that_present_consistency_level))
           return false;
         if (!this.consistency_level.equals(that.consistency_level))
           return false;
       }
 
       return true;
     }
 
     @Override
     public int hashCode() {
       return 0;
     }
 
     public int compareTo(get_range_slices_args other) {
       if (!getClass().equals(other.getClass())) {
         return getClass().getName().compareTo(other.getClass().getName());
       }
 
       int lastComparison = 0;
       get_range_slices_args typedOther = (get_range_slices_args)other;
 
       lastComparison = Boolean.valueOf(isSetKeyspace()).compareTo(typedOther.isSetKeyspace());
       if (lastComparison != 0) {
         return lastComparison;
       }
       if (isSetKeyspace()) {        lastComparison = TBaseHelper.compareTo(keyspace, typedOther.keyspace);
         if (lastComparison != 0) {
           return lastComparison;
         }
       }
       lastComparison = Boolean.valueOf(isSetColumn_parent()).compareTo(typedOther.isSetColumn_parent());
       if (lastComparison != 0) {
         return lastComparison;
       }
       if (isSetColumn_parent()) {        lastComparison = TBaseHelper.compareTo(column_parent, typedOther.column_parent);
         if (lastComparison != 0) {
           return lastComparison;
         }
       }
       lastComparison = Boolean.valueOf(isSetPredicate()).compareTo(typedOther.isSetPredicate());
       if (lastComparison != 0) {
         return lastComparison;
       }
       if (isSetPredicate()) {        lastComparison = TBaseHelper.compareTo(predicate, typedOther.predicate);
         if (lastComparison != 0) {
           return lastComparison;
         }
       }
       lastComparison = Boolean.valueOf(isSetRange()).compareTo(typedOther.isSetRange());
       if (lastComparison != 0) {
         return lastComparison;
       }
       if (isSetRange()) {        lastComparison = TBaseHelper.compareTo(range, typedOther.range);
         if (lastComparison != 0) {
           return lastComparison;
         }
       }
       lastComparison = Boolean.valueOf(isSetConsistency_level()).compareTo(typedOther.isSetConsistency_level());
       if (lastComparison != 0) {
         return lastComparison;
       }
       if (isSetConsistency_level()) {        lastComparison = TBaseHelper.compareTo(consistency_level, typedOther.consistency_level);
         if (lastComparison != 0) {
           return lastComparison;
         }
       }
       return 0;
     }
 
     public void read(TProtocol iprot) throws TException {
       TField field;
       iprot.readStructBegin();
       while (true)
       {
         field = iprot.readFieldBegin();
         if (field.type == TType.STOP) { 
           break;
         }
         switch (field.id) {
           case 1: // KEYSPACE
             if (field.type == TType.STRING) {
               this.keyspace = iprot.readString();
             } else { 
               TProtocolUtil.skip(iprot, field.type);
             }
             break;
           case 2: // COLUMN_PARENT
             if (field.type == TType.STRUCT) {
               this.column_parent = new ColumnParent();
               this.column_parent.read(iprot);
             } else { 
               TProtocolUtil.skip(iprot, field.type);
             }
             break;
           case 3: // PREDICATE
             if (field.type == TType.STRUCT) {
               this.predicate = new SlicePredicate();
               this.predicate.read(iprot);
             } else { 
               TProtocolUtil.skip(iprot, field.type);
             }
             break;
           case 4: // RANGE
             if (field.type == TType.STRUCT) {
               this.range = new KeyRange();
               this.range.read(iprot);
             } else { 
               TProtocolUtil.skip(iprot, field.type);
             }
             break;
           case 5: // CONSISTENCY_LEVEL
             if (field.type == TType.I32) {
               this.consistency_level = ConsistencyLevel.findByValue(iprot.readI32());
             } else { 
               TProtocolUtil.skip(iprot, field.type);
             }
             break;
           default:
             TProtocolUtil.skip(iprot, field.type);
         }
         iprot.readFieldEnd();
       }
       iprot.readStructEnd();
 
       // check for required fields of primitive type, which can't be checked in the validate method
       validate();
     }
 
     public void write(TProtocol oprot) throws TException {
       validate();
 
       oprot.writeStructBegin(STRUCT_DESC);
       if (this.keyspace != null) {
         oprot.writeFieldBegin(KEYSPACE_FIELD_DESC);
         oprot.writeString(this.keyspace);
         oprot.writeFieldEnd();
       }
       if (this.column_parent != null) {
         oprot.writeFieldBegin(COLUMN_PARENT_FIELD_DESC);
         this.column_parent.write(oprot);
         oprot.writeFieldEnd();
       }
       if (this.predicate != null) {
         oprot.writeFieldBegin(PREDICATE_FIELD_DESC);
         this.predicate.write(oprot);
         oprot.writeFieldEnd();
       }
       if (this.range != null) {
         oprot.writeFieldBegin(RANGE_FIELD_DESC);
         this.range.write(oprot);
         oprot.writeFieldEnd();
       }
       if (this.consistency_level != null) {
         oprot.writeFieldBegin(CONSISTENCY_LEVEL_FIELD_DESC);
         oprot.writeI32(this.consistency_level.getValue());
         oprot.writeFieldEnd();
       }
       oprot.writeFieldStop();
       oprot.writeStructEnd();
     }
 
     @Override
     public String toString() {
       StringBuilder sb = new StringBuilder("get_range_slices_args(");
       boolean first = true;
 
       sb.append("keyspace:");
       if (this.keyspace == null) {
         sb.append("null");
       } else {
         sb.append(this.keyspace);
       }
       first = false;
       if (!first) sb.append(", ");
       sb.append("column_parent:");
       if (this.column_parent == null) {
         sb.append("null");
       } else {
         sb.append(this.column_parent);
       }
       first = false;
       if (!first) sb.append(", ");
       sb.append("predicate:");
       if (this.predicate == null) {
         sb.append("null");
       } else {
         sb.append(this.predicate);
       }
       first = false;
       if (!first) sb.append(", ");
       sb.append("range:");
       if (this.range == null) {
         sb.append("null");
       } else {
         sb.append(this.range);
       }
       first = false;
       if (!first) sb.append(", ");
       sb.append("consistency_level:");
       if (this.consistency_level == null) {
         sb.append("null");
       } else {
         sb.append(this.consistency_level);
       }
       first = false;
       sb.append(")");
       return sb.toString();
     }
 
     public void validate() throws TException {
       // check for required fields
       if (keyspace == null) {
         throw new TProtocolException("Required field 'keyspace' was not present! Struct: " + toString());
       }
       if (column_parent == null) {
         throw new TProtocolException("Required field 'column_parent' was not present! Struct: " + toString());
       }
       if (predicate == null) {
         throw new TProtocolException("Required field 'predicate' was not present! Struct: " + toString());
       }
       if (range == null) {
         throw new TProtocolException("Required field 'range' was not present! Struct: " + toString());
       }
       if (consistency_level == null) {
         throw new TProtocolException("Required field 'consistency_level' was not present! Struct: " + toString());
       }
     }
 
   }
 
   public static class get_range_slices_result implements TBase<get_range_slices_result._Fields>, java.io.Serializable, Cloneable, Comparable<get_range_slices_result>   {
     private static final TStruct STRUCT_DESC = new TStruct("get_range_slices_result");
 
     private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.LIST, (short)0);
     private static final TField IRE_FIELD_DESC = new TField("ire", TType.STRUCT, (short)1);
     private static final TField UE_FIELD_DESC = new TField("ue", TType.STRUCT, (short)2);
     private static final TField TE_FIELD_DESC = new TField("te", TType.STRUCT, (short)3);
 
     public List<KeySlice> success;
     public InvalidRequestException ire;
     public UnavailableException ue;
     public TimedOutException te;
 
     /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
     public enum _Fields implements TFieldIdEnum {
       SUCCESS((short)0, "success"),
       IRE((short)1, "ire"),
       UE((short)2, "ue"),
       TE((short)3, "te");
 
       private static final Map<Integer, _Fields> byId = new HashMap<Integer, _Fields>();
       private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();
 
       static {
         for (_Fields field : EnumSet.allOf(_Fields.class)) {
           byId.put((int)field._thriftId, field);
           byName.put(field.getFieldName(), field);
         }
       }
 
       /**
        * Find the _Fields constant that matches fieldId, or null if its not found.
        */
       public static _Fields findByThriftId(int fieldId) {
         return byId.get(fieldId);
       }
 
       /**
        * Find the _Fields constant that matches fieldId, throwing an exception
        * if it is not found.
        */
       public static _Fields findByThriftIdOrThrow(int fieldId) {
         _Fields fields = findByThriftId(fieldId);
         if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
         return fields;
       }
 
       /**
        * Find the _Fields constant that matches name, or null if its not found.
        */
       public static _Fields findByName(String name) {
         return byName.get(name);
       }
 
       private final short _thriftId;
       private final String _fieldName;
 
       _Fields(short thriftId, String fieldName) {
         _thriftId = thriftId;
         _fieldName = fieldName;
       }
 
       public short getThriftFieldId() {
         return _thriftId;
       }
 
       public String getFieldName() {
         return _fieldName;
       }
     }
 
     // isset id assignments
 
     public static final Map<_Fields, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new EnumMap<_Fields, FieldMetaData>(_Fields.class) {{
       put(_Fields.SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
           new ListMetaData(TType.LIST, 
               new StructMetaData(TType.STRUCT, KeySlice.class))));
       put(_Fields.IRE, new FieldMetaData("ire", TFieldRequirementType.DEFAULT, 
           new FieldValueMetaData(TType.STRUCT)));
       put(_Fields.UE, new FieldMetaData("ue", TFieldRequirementType.DEFAULT, 
           new FieldValueMetaData(TType.STRUCT)));
       put(_Fields.TE, new FieldMetaData("te", TFieldRequirementType.DEFAULT, 
           new FieldValueMetaData(TType.STRUCT)));
     }});
 
     static {
       FieldMetaData.addStructMetaDataMap(get_range_slices_result.class, metaDataMap);
     }
 
     public get_range_slices_result() {
     }
 
     public get_range_slices_result(
       List<KeySlice> success,
       InvalidRequestException ire,
       UnavailableException ue,
       TimedOutException te)
     {
       this();
       this.success = success;
       this.ire = ire;
       this.ue = ue;
       this.te = te;
     }
 
     /**
      * Performs a deep copy on <i>other</i>.
      */
     public get_range_slices_result(get_range_slices_result other) {
       if (other.isSetSuccess()) {
         List<KeySlice> __this__success = new ArrayList<KeySlice>();
         for (KeySlice other_element : other.success) {
           __this__success.add(new KeySlice(other_element));
         }
         this.success = __this__success;
       }
       if (other.isSetIre()) {
         this.ire = new InvalidRequestException(other.ire);
       }
       if (other.isSetUe()) {
         this.ue = new UnavailableException(other.ue);
       }
       if (other.isSetTe()) {
         this.te = new TimedOutException(other.te);
       }
     }
 
     public get_range_slices_result deepCopy() {
       return new get_range_slices_result(this);
     }
 
     @Deprecated
     public get_range_slices_result clone() {
       return new get_range_slices_result(this);
     }
 
     public int getSuccessSize() {
       return (this.success == null) ? 0 : this.success.size();
     }
 
     public java.util.Iterator<KeySlice> getSuccessIterator() {
       return (this.success == null) ? null : this.success.iterator();
     }
 
     public void addToSuccess(KeySlice elem) {
       if (this.success == null) {
         this.success = new ArrayList<KeySlice>();
       }
       this.success.add(elem);
     }
 
     public List<KeySlice> getSuccess() {
       return this.success;
     }
 
     public get_range_slices_result setSuccess(List<KeySlice> success) {
       this.success = success;
       return this;
     }
 
     public void unsetSuccess() {
       this.success = null;
     }
 
     /** Returns true if field success is set (has been asigned a value) and false otherwise */
     public boolean isSetSuccess() {
       return this.success != null;
     }
 
     public void setSuccessIsSet(boolean value) {
       if (!value) {
         this.success = null;
       }
     }
 
     public InvalidRequestException getIre() {
       return this.ire;
     }
 
     public get_range_slices_result setIre(InvalidRequestException ire) {
       this.ire = ire;
       return this;
     }
 
     public void unsetIre() {
       this.ire = null;
     }
 
     /** Returns true if field ire is set (has been asigned a value) and false otherwise */
     public boolean isSetIre() {
       return this.ire != null;
     }
 
     public void setIreIsSet(boolean value) {
       if (!value) {
         this.ire = null;
       }
     }
 
     public UnavailableException getUe() {
       return this.ue;
     }
 
     public get_range_slices_result setUe(UnavailableException ue) {
       this.ue = ue;
       return this;
     }
 
     public void unsetUe() {
       this.ue = null;
     }
 
     /** Returns true if field ue is set (has been asigned a value) and false otherwise */
     public boolean isSetUe() {
       return this.ue != null;
     }
 
     public void setUeIsSet(boolean value) {
       if (!value) {
         this.ue = null;
       }
     }
 
     public TimedOutException getTe() {
       return this.te;
     }
 
     public get_range_slices_result setTe(TimedOutException te) {
       this.te = te;
       return this;
     }
 
     public void unsetTe() {
       this.te = null;
     }
 
     /** Returns true if field te is set (has been asigned a value) and false otherwise */
     public boolean isSetTe() {
       return this.te != null;
     }
 
     public void setTeIsSet(boolean value) {
       if (!value) {
         this.te = null;
       }
     }
 
     public void setFieldValue(_Fields field, Object value) {
       switch (field) {
       case SUCCESS:
         if (value == null) {
           unsetSuccess();
         } else {
           setSuccess((List<KeySlice>)value);
         }
         break;
 
       case IRE:
         if (value == null) {
           unsetIre();
         } else {
           setIre((InvalidRequestException)value);
         }
         break;
 
       case UE:
         if (value == null) {
           unsetUe();
         } else {
           setUe((UnavailableException)value);
         }
         break;
 
       case TE:
         if (value == null) {
           unsetTe();
         } else {
           setTe((TimedOutException)value);
         }
         break;
 
       }
     }
 
     public void setFieldValue(int fieldID, Object value) {
       setFieldValue(_Fields.findByThriftIdOrThrow(fieldID), value);
     }
 
     public Object getFieldValue(_Fields field) {
       switch (field) {
       case SUCCESS:
         return getSuccess();
 
       case IRE:
         return getIre();
 
       case UE:
         return getUe();
 
       case TE:
         return getTe();
 
       }
       throw new IllegalStateException();
     }
 
     public Object getFieldValue(int fieldId) {
       return getFieldValue(_Fields.findByThriftIdOrThrow(fieldId));
     }
 
     /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
     public boolean isSet(_Fields field) {
       switch (field) {
       case SUCCESS:
         return isSetSuccess();
       case IRE:
         return isSetIre();
       case UE:
         return isSetUe();
       case TE:
         return isSetTe();
       }
       throw new IllegalStateException();
     }
 
     public boolean isSet(int fieldID) {
       return isSet(_Fields.findByThriftIdOrThrow(fieldID));
     }
 
     @Override
     public boolean equals(Object that) {
       if (that == null)
         return false;
       if (that instanceof get_range_slices_result)
         return this.equals((get_range_slices_result)that);
       return false;
     }
 
     public boolean equals(get_range_slices_result that) {
       if (that == null)
         return false;
 
       boolean this_present_success = true && this.isSetSuccess();
       boolean that_present_success = true && that.isSetSuccess();
       if (this_present_success || that_present_success) {
         if (!(this_present_success && that_present_success))
           return false;
         if (!this.success.equals(that.success))
           return false;
       }
 
       boolean this_present_ire = true && this.isSetIre();
       boolean that_present_ire = true && that.isSetIre();
       if (this_present_ire || that_present_ire) {
         if (!(this_present_ire && that_present_ire))
           return false;
         if (!this.ire.equals(that.ire))
           return false;
       }
 
       boolean this_present_ue = true && this.isSetUe();
       boolean that_present_ue = true && that.isSetUe();
       if (this_present_ue || that_present_ue) {
         if (!(this_present_ue && that_present_ue))
           return false;
         if (!this.ue.equals(that.ue))
           return false;
       }
 
       boolean this_present_te = true && this.isSetTe();
       boolean that_present_te = true && that.isSetTe();
       if (this_present_te || that_present_te) {
         if (!(this_present_te && that_present_te))
           return false;
         if (!this.te.equals(that.te))
           return false;
       }
 
       return true;
     }
 
     @Override
     public int hashCode() {
       return 0;
     }
 
     public int compareTo(get_range_slices_result other) {
       if (!getClass().equals(other.getClass())) {
         return getClass().getName().compareTo(other.getClass().getName());
       }
 
       int lastComparison = 0;
       get_range_slices_result typedOther = (get_range_slices_result)other;
 
       lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(typedOther.isSetSuccess());
       if (lastComparison != 0) {
         return lastComparison;
       }
       if (isSetSuccess()) {        lastComparison = TBaseHelper.compareTo(success, typedOther.success);
         if (lastComparison != 0) {
           return lastComparison;
         }
       }
       lastComparison = Boolean.valueOf(isSetIre()).compareTo(typedOther.isSetIre());
       if (lastComparison != 0) {
         return lastComparison;
       }
       if (isSetIre()) {        lastComparison = TBaseHelper.compareTo(ire, typedOther.ire);
         if (lastComparison != 0) {
           return lastComparison;
         }
       }
       lastComparison = Boolean.valueOf(isSetUe()).compareTo(typedOther.isSetUe());
       if (lastComparison != 0) {
         return lastComparison;
       }
       if (isSetUe()) {        lastComparison = TBaseHelper.compareTo(ue, typedOther.ue);
         if (lastComparison != 0) {
           return lastComparison;
         }
       }
       lastComparison = Boolean.valueOf(isSetTe()).compareTo(typedOther.isSetTe());
       if (lastComparison != 0) {
         return lastComparison;
       }
       if (isSetTe()) {        lastComparison = TBaseHelper.compareTo(te, typedOther.te);
         if (lastComparison != 0) {
           return lastComparison;
         }
       }
       return 0;
     }
 
     public void read(TProtocol iprot) throws TException {
       TField field;
       iprot.readStructBegin();
       while (true)
       {
         field = iprot.readFieldBegin();
         if (field.type == TType.STOP) { 
           break;
         }
         switch (field.id) {
           case 0: // SUCCESS
             if (field.type == TType.LIST) {
               {
                TList _list68 = iprot.readListBegin();
                this.success = new ArrayList<KeySlice>(_list68.size);
                for (int _i69 = 0; _i69 < _list68.size; ++_i69)
                {
                  KeySlice _elem70;
                  _elem70 = new KeySlice();
                  _elem70.read(iprot);
                  this.success.add(_elem70);
                 }
                 iprot.readListEnd();
               }
             } else { 
               TProtocolUtil.skip(iprot, field.type);
             }
             break;
           case 1: // IRE
             if (field.type == TType.STRUCT) {
               this.ire = new InvalidRequestException();
               this.ire.read(iprot);
             } else { 
               TProtocolUtil.skip(iprot, field.type);
             }
             break;
           case 2: // UE
             if (field.type == TType.STRUCT) {
               this.ue = new UnavailableException();
               this.ue.read(iprot);
             } else { 
               TProtocolUtil.skip(iprot, field.type);
             }
             break;
           case 3: // TE
             if (field.type == TType.STRUCT) {
               this.te = new TimedOutException();
               this.te.read(iprot);
             } else { 
               TProtocolUtil.skip(iprot, field.type);
             }
             break;
           default:
             TProtocolUtil.skip(iprot, field.type);
         }
         iprot.readFieldEnd();
       }
       iprot.readStructEnd();
 
       // check for required fields of primitive type, which can't be checked in the validate method
       validate();
     }
 
     public void write(TProtocol oprot) throws TException {
       oprot.writeStructBegin(STRUCT_DESC);
 
       if (this.isSetSuccess()) {
         oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
         {
           oprot.writeListBegin(new TList(TType.STRUCT, this.success.size()));
          for (KeySlice _iter71 : this.success)
           {
            _iter71.write(oprot);
           }
           oprot.writeListEnd();
         }
         oprot.writeFieldEnd();
       } else if (this.isSetIre()) {
         oprot.writeFieldBegin(IRE_FIELD_DESC);
         this.ire.write(oprot);
         oprot.writeFieldEnd();
       } else if (this.isSetUe()) {
         oprot.writeFieldBegin(UE_FIELD_DESC);
         this.ue.write(oprot);
         oprot.writeFieldEnd();
       } else if (this.isSetTe()) {
         oprot.writeFieldBegin(TE_FIELD_DESC);
         this.te.write(oprot);
         oprot.writeFieldEnd();
       }
       oprot.writeFieldStop();
       oprot.writeStructEnd();
     }
 
     @Override
     public String toString() {
       StringBuilder sb = new StringBuilder("get_range_slices_result(");
       boolean first = true;
 
       sb.append("success:");
       if (this.success == null) {
         sb.append("null");
       } else {
         sb.append(this.success);
       }
       first = false;
       if (!first) sb.append(", ");
       sb.append("ire:");
       if (this.ire == null) {
         sb.append("null");
       } else {
         sb.append(this.ire);
       }
       first = false;
       if (!first) sb.append(", ");
       sb.append("ue:");
       if (this.ue == null) {
         sb.append("null");
       } else {
         sb.append(this.ue);
       }
       first = false;
       if (!first) sb.append(", ");
       sb.append("te:");
       if (this.te == null) {
         sb.append("null");
       } else {
         sb.append(this.te);
       }
       first = false;
       sb.append(")");
       return sb.toString();
     }
 
     public void validate() throws TException {
       // check for required fields
     }
 
   }
 
   public static class insert_args implements TBase<insert_args._Fields>, java.io.Serializable, Cloneable, Comparable<insert_args>   {
     private static final TStruct STRUCT_DESC = new TStruct("insert_args");
 
     private static final TField KEYSPACE_FIELD_DESC = new TField("keyspace", TType.STRING, (short)1);
     private static final TField KEY_FIELD_DESC = new TField("key", TType.STRING, (short)2);
     private static final TField COLUMN_PARENT_FIELD_DESC = new TField("column_parent", TType.STRUCT, (short)3);
     private static final TField COLUMN_FIELD_DESC = new TField("column", TType.STRUCT, (short)4);
     private static final TField CONSISTENCY_LEVEL_FIELD_DESC = new TField("consistency_level", TType.I32, (short)5);
 
     public String keyspace;
     public byte[] key;
     public ColumnParent column_parent;
     public Column column;
     /**
      * 
      * @see ConsistencyLevel
      */
     public ConsistencyLevel consistency_level;
 
     /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
     public enum _Fields implements TFieldIdEnum {
       KEYSPACE((short)1, "keyspace"),
       KEY((short)2, "key"),
       COLUMN_PARENT((short)3, "column_parent"),
       COLUMN((short)4, "column"),
       /**
        * 
        * @see ConsistencyLevel
        */
       CONSISTENCY_LEVEL((short)5, "consistency_level");
 
       private static final Map<Integer, _Fields> byId = new HashMap<Integer, _Fields>();
       private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();
 
       static {
         for (_Fields field : EnumSet.allOf(_Fields.class)) {
           byId.put((int)field._thriftId, field);
           byName.put(field.getFieldName(), field);
         }
       }
 
       /**
        * Find the _Fields constant that matches fieldId, or null if its not found.
        */
       public static _Fields findByThriftId(int fieldId) {
         return byId.get(fieldId);
       }
 
       /**
        * Find the _Fields constant that matches fieldId, throwing an exception
        * if it is not found.
        */
       public static _Fields findByThriftIdOrThrow(int fieldId) {
         _Fields fields = findByThriftId(fieldId);
         if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
         return fields;
       }
 
       /**
        * Find the _Fields constant that matches name, or null if its not found.
        */
       public static _Fields findByName(String name) {
         return byName.get(name);
       }
 
       private final short _thriftId;
       private final String _fieldName;
 
       _Fields(short thriftId, String fieldName) {
         _thriftId = thriftId;
         _fieldName = fieldName;
       }
 
       public short getThriftFieldId() {
         return _thriftId;
       }
 
       public String getFieldName() {
         return _fieldName;
       }
     }
 
     // isset id assignments
 
     public static final Map<_Fields, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new EnumMap<_Fields, FieldMetaData>(_Fields.class) {{
       put(_Fields.KEYSPACE, new FieldMetaData("keyspace", TFieldRequirementType.REQUIRED, 
           new FieldValueMetaData(TType.STRING)));
       put(_Fields.KEY, new FieldMetaData("key", TFieldRequirementType.REQUIRED, 
           new FieldValueMetaData(TType.STRING)));
       put(_Fields.COLUMN_PARENT, new FieldMetaData("column_parent", TFieldRequirementType.REQUIRED, 
           new StructMetaData(TType.STRUCT, ColumnParent.class)));
       put(_Fields.COLUMN, new FieldMetaData("column", TFieldRequirementType.REQUIRED, 
           new StructMetaData(TType.STRUCT, Column.class)));
       put(_Fields.CONSISTENCY_LEVEL, new FieldMetaData("consistency_level", TFieldRequirementType.REQUIRED, 
           new EnumMetaData(TType.ENUM, ConsistencyLevel.class)));
     }});
 
     static {
       FieldMetaData.addStructMetaDataMap(insert_args.class, metaDataMap);
     }
 
     public insert_args() {
       this.consistency_level = ConsistencyLevel.ONE;
 
     }
 
     public insert_args(
       String keyspace,
       byte[] key,
       ColumnParent column_parent,
       Column column,
       ConsistencyLevel consistency_level)
     {
       this();
       this.keyspace = keyspace;
       this.key = key;
       this.column_parent = column_parent;
       this.column = column;
       this.consistency_level = consistency_level;
     }
 
     /**
      * Performs a deep copy on <i>other</i>.
      */
     public insert_args(insert_args other) {
       if (other.isSetKeyspace()) {
         this.keyspace = other.keyspace;
       }
       if (other.isSetKey()) {
         this.key = new byte[other.key.length];
         System.arraycopy(other.key, 0, key, 0, other.key.length);
       }
       if (other.isSetColumn_parent()) {
         this.column_parent = new ColumnParent(other.column_parent);
       }
       if (other.isSetColumn()) {
         this.column = new Column(other.column);
       }
       if (other.isSetConsistency_level()) {
         this.consistency_level = other.consistency_level;
       }
     }
 
     public insert_args deepCopy() {
       return new insert_args(this);
     }
 
     @Deprecated
     public insert_args clone() {
       return new insert_args(this);
     }
 
     public String getKeyspace() {
       return this.keyspace;
     }
 
     public insert_args setKeyspace(String keyspace) {
       this.keyspace = keyspace;
       return this;
     }
 
     public void unsetKeyspace() {
       this.keyspace = null;
     }
 
     /** Returns true if field keyspace is set (has been asigned a value) and false otherwise */
     public boolean isSetKeyspace() {
       return this.keyspace != null;
     }
 
     public void setKeyspaceIsSet(boolean value) {
       if (!value) {
         this.keyspace = null;
       }
     }
 
     public byte[] getKey() {
       return this.key;
     }
 
     public insert_args setKey(byte[] key) {
       this.key = key;
       return this;
     }
 
     public void unsetKey() {
       this.key = null;
     }
 
     /** Returns true if field key is set (has been asigned a value) and false otherwise */
     public boolean isSetKey() {
       return this.key != null;
     }
 
     public void setKeyIsSet(boolean value) {
       if (!value) {
         this.key = null;
       }
     }
 
     public ColumnParent getColumn_parent() {
       return this.column_parent;
     }
 
     public insert_args setColumn_parent(ColumnParent column_parent) {
       this.column_parent = column_parent;
       return this;
     }
 
     public void unsetColumn_parent() {
       this.column_parent = null;
     }
 
     /** Returns true if field column_parent is set (has been asigned a value) and false otherwise */
     public boolean isSetColumn_parent() {
       return this.column_parent != null;
     }
 
     public void setColumn_parentIsSet(boolean value) {
       if (!value) {
         this.column_parent = null;
       }
     }
 
     public Column getColumn() {
       return this.column;
     }
 
     public insert_args setColumn(Column column) {
       this.column = column;
       return this;
     }
 
     public void unsetColumn() {
       this.column = null;
     }
 
     /** Returns true if field column is set (has been asigned a value) and false otherwise */
     public boolean isSetColumn() {
       return this.column != null;
     }
 
     public void setColumnIsSet(boolean value) {
       if (!value) {
         this.column = null;
       }
     }
 
     /**
      * 
      * @see ConsistencyLevel
      */
     public ConsistencyLevel getConsistency_level() {
       return this.consistency_level;
     }
 
     /**
      * 
      * @see ConsistencyLevel
      */
     public insert_args setConsistency_level(ConsistencyLevel consistency_level) {
       this.consistency_level = consistency_level;
       return this;
     }
 
     public void unsetConsistency_level() {
       this.consistency_level = null;
     }
 
     /** Returns true if field consistency_level is set (has been asigned a value) and false otherwise */
     public boolean isSetConsistency_level() {
       return this.consistency_level != null;
     }
 
     public void setConsistency_levelIsSet(boolean value) {
       if (!value) {
         this.consistency_level = null;
       }
     }
 
     public void setFieldValue(_Fields field, Object value) {
       switch (field) {
       case KEYSPACE:
         if (value == null) {
           unsetKeyspace();
         } else {
           setKeyspace((String)value);
         }
         break;
 
       case KEY:
         if (value == null) {
           unsetKey();
         } else {
           setKey((byte[])value);
         }
         break;
 
       case COLUMN_PARENT:
         if (value == null) {
           unsetColumn_parent();
         } else {
           setColumn_parent((ColumnParent)value);
         }
         break;
 
       case COLUMN:
         if (value == null) {
           unsetColumn();
         } else {
           setColumn((Column)value);
         }
         break;
 
       case CONSISTENCY_LEVEL:
         if (value == null) {
           unsetConsistency_level();
         } else {
           setConsistency_level((ConsistencyLevel)value);
         }
         break;
 
       }
     }
 
     public void setFieldValue(int fieldID, Object value) {
       setFieldValue(_Fields.findByThriftIdOrThrow(fieldID), value);
     }
 
     public Object getFieldValue(_Fields field) {
       switch (field) {
       case KEYSPACE:
         return getKeyspace();
 
       case KEY:
         return getKey();
 
       case COLUMN_PARENT:
         return getColumn_parent();
 
       case COLUMN:
         return getColumn();
 
       case CONSISTENCY_LEVEL:
         return getConsistency_level();
 
       }
       throw new IllegalStateException();
     }
 
     public Object getFieldValue(int fieldId) {
       return getFieldValue(_Fields.findByThriftIdOrThrow(fieldId));
     }
 
     /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
     public boolean isSet(_Fields field) {
       switch (field) {
       case KEYSPACE:
         return isSetKeyspace();
       case KEY:
         return isSetKey();
       case COLUMN_PARENT:
         return isSetColumn_parent();
       case COLUMN:
         return isSetColumn();
       case CONSISTENCY_LEVEL:
         return isSetConsistency_level();
       }
       throw new IllegalStateException();
     }
 
     public boolean isSet(int fieldID) {
       return isSet(_Fields.findByThriftIdOrThrow(fieldID));
     }
 
     @Override
     public boolean equals(Object that) {
       if (that == null)
         return false;
       if (that instanceof insert_args)
         return this.equals((insert_args)that);
       return false;
     }
 
     public boolean equals(insert_args that) {
       if (that == null)
         return false;
 
       boolean this_present_keyspace = true && this.isSetKeyspace();
       boolean that_present_keyspace = true && that.isSetKeyspace();
       if (this_present_keyspace || that_present_keyspace) {
         if (!(this_present_keyspace && that_present_keyspace))
           return false;
         if (!this.keyspace.equals(that.keyspace))
           return false;
       }
 
       boolean this_present_key = true && this.isSetKey();
       boolean that_present_key = true && that.isSetKey();
       if (this_present_key || that_present_key) {
         if (!(this_present_key && that_present_key))
           return false;
         if (!java.util.Arrays.equals(this.key, that.key))
           return false;
       }
 
       boolean this_present_column_parent = true && this.isSetColumn_parent();
       boolean that_present_column_parent = true && that.isSetColumn_parent();
       if (this_present_column_parent || that_present_column_parent) {
         if (!(this_present_column_parent && that_present_column_parent))
           return false;
         if (!this.column_parent.equals(that.column_parent))
           return false;
       }
 
       boolean this_present_column = true && this.isSetColumn();
       boolean that_present_column = true && that.isSetColumn();
       if (this_present_column || that_present_column) {
         if (!(this_present_column && that_present_column))
           return false;
         if (!this.column.equals(that.column))
           return false;
       }
 
       boolean this_present_consistency_level = true && this.isSetConsistency_level();
       boolean that_present_consistency_level = true && that.isSetConsistency_level();
       if (this_present_consistency_level || that_present_consistency_level) {
         if (!(this_present_consistency_level && that_present_consistency_level))
           return false;
         if (!this.consistency_level.equals(that.consistency_level))
           return false;
       }
 
       return true;
     }
 
     @Override
     public int hashCode() {
       return 0;
     }
 
     public int compareTo(insert_args other) {
       if (!getClass().equals(other.getClass())) {
         return getClass().getName().compareTo(other.getClass().getName());
       }
 
       int lastComparison = 0;
       insert_args typedOther = (insert_args)other;
 
       lastComparison = Boolean.valueOf(isSetKeyspace()).compareTo(typedOther.isSetKeyspace());
       if (lastComparison != 0) {
         return lastComparison;
       }
       if (isSetKeyspace()) {        lastComparison = TBaseHelper.compareTo(keyspace, typedOther.keyspace);
         if (lastComparison != 0) {
           return lastComparison;
         }
       }
       lastComparison = Boolean.valueOf(isSetKey()).compareTo(typedOther.isSetKey());
       if (lastComparison != 0) {
         return lastComparison;
       }
       if (isSetKey()) {        lastComparison = TBaseHelper.compareTo(key, typedOther.key);
         if (lastComparison != 0) {
           return lastComparison;
         }
       }
       lastComparison = Boolean.valueOf(isSetColumn_parent()).compareTo(typedOther.isSetColumn_parent());
       if (lastComparison != 0) {
         return lastComparison;
       }
       if (isSetColumn_parent()) {        lastComparison = TBaseHelper.compareTo(column_parent, typedOther.column_parent);
         if (lastComparison != 0) {
           return lastComparison;
         }
       }
       lastComparison = Boolean.valueOf(isSetColumn()).compareTo(typedOther.isSetColumn());
       if (lastComparison != 0) {
         return lastComparison;
       }
       if (isSetColumn()) {        lastComparison = TBaseHelper.compareTo(column, typedOther.column);
         if (lastComparison != 0) {
           return lastComparison;
         }
       }
       lastComparison = Boolean.valueOf(isSetConsistency_level()).compareTo(typedOther.isSetConsistency_level());
       if (lastComparison != 0) {
         return lastComparison;
       }
       if (isSetConsistency_level()) {        lastComparison = TBaseHelper.compareTo(consistency_level, typedOther.consistency_level);
         if (lastComparison != 0) {
           return lastComparison;
         }
       }
       return 0;
     }
 
     public void read(TProtocol iprot) throws TException {
       TField field;
       iprot.readStructBegin();
       while (true)
       {
         field = iprot.readFieldBegin();
         if (field.type == TType.STOP) { 
           break;
         }
         switch (field.id) {
           case 1: // KEYSPACE
             if (field.type == TType.STRING) {
               this.keyspace = iprot.readString();
             } else { 
               TProtocolUtil.skip(iprot, field.type);
             }
             break;
           case 2: // KEY
             if (field.type == TType.STRING) {
               this.key = iprot.readBinary();
             } else { 
               TProtocolUtil.skip(iprot, field.type);
             }
             break;
           case 3: // COLUMN_PARENT
             if (field.type == TType.STRUCT) {
               this.column_parent = new ColumnParent();
               this.column_parent.read(iprot);
             } else { 
               TProtocolUtil.skip(iprot, field.type);
             }
             break;
           case 4: // COLUMN
             if (field.type == TType.STRUCT) {
               this.column = new Column();
               this.column.read(iprot);
             } else { 
               TProtocolUtil.skip(iprot, field.type);
             }
             break;
           case 5: // CONSISTENCY_LEVEL
             if (field.type == TType.I32) {
               this.consistency_level = ConsistencyLevel.findByValue(iprot.readI32());
             } else { 
               TProtocolUtil.skip(iprot, field.type);
             }
             break;
           default:
             TProtocolUtil.skip(iprot, field.type);
         }
         iprot.readFieldEnd();
       }
       iprot.readStructEnd();
 
       // check for required fields of primitive type, which can't be checked in the validate method
       validate();
     }
 
     public void write(TProtocol oprot) throws TException {
       validate();
 
       oprot.writeStructBegin(STRUCT_DESC);
       if (this.keyspace != null) {
         oprot.writeFieldBegin(KEYSPACE_FIELD_DESC);
         oprot.writeString(this.keyspace);
         oprot.writeFieldEnd();
       }
       if (this.key != null) {
         oprot.writeFieldBegin(KEY_FIELD_DESC);
         oprot.writeBinary(this.key);
         oprot.writeFieldEnd();
       }
       if (this.column_parent != null) {
         oprot.writeFieldBegin(COLUMN_PARENT_FIELD_DESC);
         this.column_parent.write(oprot);
         oprot.writeFieldEnd();
       }
       if (this.column != null) {
         oprot.writeFieldBegin(COLUMN_FIELD_DESC);
         this.column.write(oprot);
         oprot.writeFieldEnd();
       }
       if (this.consistency_level != null) {
         oprot.writeFieldBegin(CONSISTENCY_LEVEL_FIELD_DESC);
         oprot.writeI32(this.consistency_level.getValue());
         oprot.writeFieldEnd();
       }
       oprot.writeFieldStop();
       oprot.writeStructEnd();
     }
 
     @Override
     public String toString() {
       StringBuilder sb = new StringBuilder("insert_args(");
       boolean first = true;
 
       sb.append("keyspace:");
       if (this.keyspace == null) {
         sb.append("null");
       } else {
         sb.append(this.keyspace);
       }
       first = false;
       if (!first) sb.append(", ");
       sb.append("key:");
       if (this.key == null) {
         sb.append("null");
       } else {
           int __key_size = Math.min(this.key.length, 128);
           for (int i = 0; i < __key_size; i++) {
             if (i != 0) sb.append(" ");
             sb.append(Integer.toHexString(this.key[i]).length() > 1 ? Integer.toHexString(this.key[i]).substring(Integer.toHexString(this.key[i]).length() - 2).toUpperCase() : "0" + Integer.toHexString(this.key[i]).toUpperCase());
           }
           if (this.key.length > 128) sb.append(" ...");
       }
       first = false;
       if (!first) sb.append(", ");
       sb.append("column_parent:");
       if (this.column_parent == null) {
         sb.append("null");
       } else {
         sb.append(this.column_parent);
       }
       first = false;
       if (!first) sb.append(", ");
       sb.append("column:");
       if (this.column == null) {
         sb.append("null");
       } else {
         sb.append(this.column);
       }
       first = false;
       if (!first) sb.append(", ");
       sb.append("consistency_level:");
       if (this.consistency_level == null) {
         sb.append("null");
       } else {
         sb.append(this.consistency_level);
       }
       first = false;
       sb.append(")");
       return sb.toString();
     }
 
     public void validate() throws TException {
       // check for required fields
       if (keyspace == null) {
         throw new TProtocolException("Required field 'keyspace' was not present! Struct: " + toString());
       }
       if (key == null) {
         throw new TProtocolException("Required field 'key' was not present! Struct: " + toString());
       }
       if (column_parent == null) {
         throw new TProtocolException("Required field 'column_parent' was not present! Struct: " + toString());
       }
       if (column == null) {
         throw new TProtocolException("Required field 'column' was not present! Struct: " + toString());
       }
       if (consistency_level == null) {
         throw new TProtocolException("Required field 'consistency_level' was not present! Struct: " + toString());
       }
     }
 
   }
 
   public static class insert_result implements TBase<insert_result._Fields>, java.io.Serializable, Cloneable, Comparable<insert_result>   {
     private static final TStruct STRUCT_DESC = new TStruct("insert_result");
 
     private static final TField IRE_FIELD_DESC = new TField("ire", TType.STRUCT, (short)1);
     private static final TField UE_FIELD_DESC = new TField("ue", TType.STRUCT, (short)2);
     private static final TField TE_FIELD_DESC = new TField("te", TType.STRUCT, (short)3);
 
     public InvalidRequestException ire;
     public UnavailableException ue;
     public TimedOutException te;
 
     /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
     public enum _Fields implements TFieldIdEnum {
       IRE((short)1, "ire"),
       UE((short)2, "ue"),
       TE((short)3, "te");
 
       private static final Map<Integer, _Fields> byId = new HashMap<Integer, _Fields>();
       private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();
 
       static {
         for (_Fields field : EnumSet.allOf(_Fields.class)) {
           byId.put((int)field._thriftId, field);
           byName.put(field.getFieldName(), field);
         }
       }
 
       /**
        * Find the _Fields constant that matches fieldId, or null if its not found.
        */
       public static _Fields findByThriftId(int fieldId) {
         return byId.get(fieldId);
       }
 
       /**
        * Find the _Fields constant that matches fieldId, throwing an exception
        * if it is not found.
        */
       public static _Fields findByThriftIdOrThrow(int fieldId) {
         _Fields fields = findByThriftId(fieldId);
         if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
         return fields;
       }
 
       /**
        * Find the _Fields constant that matches name, or null if its not found.
        */
       public static _Fields findByName(String name) {
         return byName.get(name);
       }
 
       private final short _thriftId;
       private final String _fieldName;
 
       _Fields(short thriftId, String fieldName) {
         _thriftId = thriftId;
         _fieldName = fieldName;
       }
 
       public short getThriftFieldId() {
         return _thriftId;
       }
 
       public String getFieldName() {
         return _fieldName;
       }
     }
 
     // isset id assignments
 
     public static final Map<_Fields, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new EnumMap<_Fields, FieldMetaData>(_Fields.class) {{
       put(_Fields.IRE, new FieldMetaData("ire", TFieldRequirementType.DEFAULT, 
           new FieldValueMetaData(TType.STRUCT)));
       put(_Fields.UE, new FieldMetaData("ue", TFieldRequirementType.DEFAULT, 
           new FieldValueMetaData(TType.STRUCT)));
       put(_Fields.TE, new FieldMetaData("te", TFieldRequirementType.DEFAULT, 
           new FieldValueMetaData(TType.STRUCT)));
     }});
 
     static {
       FieldMetaData.addStructMetaDataMap(insert_result.class, metaDataMap);
     }
 
     public insert_result() {
     }
 
     public insert_result(
       InvalidRequestException ire,
       UnavailableException ue,
       TimedOutException te)
     {
       this();
       this.ire = ire;
       this.ue = ue;
       this.te = te;
     }
 
     /**
      * Performs a deep copy on <i>other</i>.
      */
     public insert_result(insert_result other) {
       if (other.isSetIre()) {
         this.ire = new InvalidRequestException(other.ire);
       }
       if (other.isSetUe()) {
         this.ue = new UnavailableException(other.ue);
       }
       if (other.isSetTe()) {
         this.te = new TimedOutException(other.te);
       }
     }
 
     public insert_result deepCopy() {
       return new insert_result(this);
     }
 
     @Deprecated
     public insert_result clone() {
       return new insert_result(this);
     }
 
     public InvalidRequestException getIre() {
       return this.ire;
     }
 
     public insert_result setIre(InvalidRequestException ire) {
       this.ire = ire;
       return this;
     }
 
     public void unsetIre() {
       this.ire = null;
     }
 
     /** Returns true if field ire is set (has been asigned a value) and false otherwise */
     public boolean isSetIre() {
       return this.ire != null;
     }
 
     public void setIreIsSet(boolean value) {
       if (!value) {
         this.ire = null;
       }
     }
 
     public UnavailableException getUe() {
       return this.ue;
     }
 
     public insert_result setUe(UnavailableException ue) {
       this.ue = ue;
       return this;
     }
 
     public void unsetUe() {
       this.ue = null;
     }
 
     /** Returns true if field ue is set (has been asigned a value) and false otherwise */
     public boolean isSetUe() {
       return this.ue != null;
     }
 
     public void setUeIsSet(boolean value) {
       if (!value) {
         this.ue = null;
       }
     }
 
     public TimedOutException getTe() {
       return this.te;
     }
 
     public insert_result setTe(TimedOutException te) {
       this.te = te;
       return this;
     }
 
     public void unsetTe() {
       this.te = null;
     }
 
     /** Returns true if field te is set (has been asigned a value) and false otherwise */
     public boolean isSetTe() {
       return this.te != null;
     }
 
     public void setTeIsSet(boolean value) {
       if (!value) {
         this.te = null;
       }
     }
 
     public void setFieldValue(_Fields field, Object value) {
       switch (field) {
       case IRE:
         if (value == null) {
           unsetIre();
         } else {
           setIre((InvalidRequestException)value);
         }
         break;
 
       case UE:
         if (value == null) {
           unsetUe();
         } else {
           setUe((UnavailableException)value);
         }
         break;
 
       case TE:
         if (value == null) {
           unsetTe();
         } else {
           setTe((TimedOutException)value);
         }
         break;
 
       }
     }
 
     public void setFieldValue(int fieldID, Object value) {
       setFieldValue(_Fields.findByThriftIdOrThrow(fieldID), value);
     }
 
     public Object getFieldValue(_Fields field) {
       switch (field) {
       case IRE:
         return getIre();
 
       case UE:
         return getUe();
 
       case TE:
         return getTe();
 
       }
       throw new IllegalStateException();
     }
 
     public Object getFieldValue(int fieldId) {
       return getFieldValue(_Fields.findByThriftIdOrThrow(fieldId));
     }
 
     /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
     public boolean isSet(_Fields field) {
       switch (field) {
       case IRE:
         return isSetIre();
       case UE:
         return isSetUe();
       case TE:
         return isSetTe();
       }
       throw new IllegalStateException();
     }
 
     public boolean isSet(int fieldID) {
       return isSet(_Fields.findByThriftIdOrThrow(fieldID));
     }
 
     @Override
     public boolean equals(Object that) {
       if (that == null)
         return false;
       if (that instanceof insert_result)
         return this.equals((insert_result)that);
       return false;
     }
 
     public boolean equals(insert_result that) {
       if (that == null)
         return false;
 
       boolean this_present_ire = true && this.isSetIre();
       boolean that_present_ire = true && that.isSetIre();
       if (this_present_ire || that_present_ire) {
         if (!(this_present_ire && that_present_ire))
           return false;
         if (!this.ire.equals(that.ire))
           return false;
       }
 
       boolean this_present_ue = true && this.isSetUe();
       boolean that_present_ue = true && that.isSetUe();
       if (this_present_ue || that_present_ue) {
         if (!(this_present_ue && that_present_ue))
           return false;
         if (!this.ue.equals(that.ue))
           return false;
       }
 
       boolean this_present_te = true && this.isSetTe();
       boolean that_present_te = true && that.isSetTe();
       if (this_present_te || that_present_te) {
         if (!(this_present_te && that_present_te))
           return false;
         if (!this.te.equals(that.te))
           return false;
       }
 
       return true;
     }
 
     @Override
     public int hashCode() {
       return 0;
     }
 
     public int compareTo(insert_result other) {
       if (!getClass().equals(other.getClass())) {
         return getClass().getName().compareTo(other.getClass().getName());
       }
 
       int lastComparison = 0;
       insert_result typedOther = (insert_result)other;
 
       lastComparison = Boolean.valueOf(isSetIre()).compareTo(typedOther.isSetIre());
       if (lastComparison != 0) {
         return lastComparison;
       }
       if (isSetIre()) {        lastComparison = TBaseHelper.compareTo(ire, typedOther.ire);
         if (lastComparison != 0) {
           return lastComparison;
         }
       }
       lastComparison = Boolean.valueOf(isSetUe()).compareTo(typedOther.isSetUe());
       if (lastComparison != 0) {
         return lastComparison;
       }
       if (isSetUe()) {        lastComparison = TBaseHelper.compareTo(ue, typedOther.ue);
         if (lastComparison != 0) {
           return lastComparison;
         }
       }
       lastComparison = Boolean.valueOf(isSetTe()).compareTo(typedOther.isSetTe());
       if (lastComparison != 0) {
         return lastComparison;
       }
       if (isSetTe()) {        lastComparison = TBaseHelper.compareTo(te, typedOther.te);
         if (lastComparison != 0) {
           return lastComparison;
         }
       }
       return 0;
     }
 
     public void read(TProtocol iprot) throws TException {
       TField field;
       iprot.readStructBegin();
       while (true)
       {
         field = iprot.readFieldBegin();
         if (field.type == TType.STOP) { 
           break;
         }
         switch (field.id) {
           case 1: // IRE
             if (field.type == TType.STRUCT) {
               this.ire = new InvalidRequestException();
               this.ire.read(iprot);
             } else { 
               TProtocolUtil.skip(iprot, field.type);
             }
             break;
           case 2: // UE
             if (field.type == TType.STRUCT) {
               this.ue = new UnavailableException();
               this.ue.read(iprot);
             } else { 
               TProtocolUtil.skip(iprot, field.type);
             }
             break;
           case 3: // TE
             if (field.type == TType.STRUCT) {
               this.te = new TimedOutException();
               this.te.read(iprot);
             } else { 
               TProtocolUtil.skip(iprot, field.type);
             }
             break;
           default:
             TProtocolUtil.skip(iprot, field.type);
         }
         iprot.readFieldEnd();
       }
       iprot.readStructEnd();
 
       // check for required fields of primitive type, which can't be checked in the validate method
       validate();
     }
 
     public void write(TProtocol oprot) throws TException {
       oprot.writeStructBegin(STRUCT_DESC);
 
       if (this.isSetIre()) {
         oprot.writeFieldBegin(IRE_FIELD_DESC);
         this.ire.write(oprot);
         oprot.writeFieldEnd();
       } else if (this.isSetUe()) {
         oprot.writeFieldBegin(UE_FIELD_DESC);
         this.ue.write(oprot);
         oprot.writeFieldEnd();
       } else if (this.isSetTe()) {
         oprot.writeFieldBegin(TE_FIELD_DESC);
         this.te.write(oprot);
         oprot.writeFieldEnd();
       }
       oprot.writeFieldStop();
       oprot.writeStructEnd();
     }
 
     @Override
     public String toString() {
       StringBuilder sb = new StringBuilder("insert_result(");
       boolean first = true;
 
       sb.append("ire:");
       if (this.ire == null) {
         sb.append("null");
       } else {
         sb.append(this.ire);
       }
       first = false;
       if (!first) sb.append(", ");
       sb.append("ue:");
       if (this.ue == null) {
         sb.append("null");
       } else {
         sb.append(this.ue);
       }
       first = false;
       if (!first) sb.append(", ");
       sb.append("te:");
       if (this.te == null) {
         sb.append("null");
       } else {
         sb.append(this.te);
       }
       first = false;
       sb.append(")");
       return sb.toString();
     }
 
     public void validate() throws TException {
       // check for required fields
     }
 
   }
 
   public static class batch_insert_args implements TBase<batch_insert_args._Fields>, java.io.Serializable, Cloneable   {
     private static final TStruct STRUCT_DESC = new TStruct("batch_insert_args");
 
     private static final TField KEYSPACE_FIELD_DESC = new TField("keyspace", TType.STRING, (short)1);
     private static final TField KEY_FIELD_DESC = new TField("key", TType.STRING, (short)2);
     private static final TField CFMAP_FIELD_DESC = new TField("cfmap", TType.MAP, (short)3);
     private static final TField CONSISTENCY_LEVEL_FIELD_DESC = new TField("consistency_level", TType.I32, (short)4);
 
     public String keyspace;
     public byte[] key;
     public Map<String,List<ColumnOrSuperColumn>> cfmap;
     /**
      * 
      * @see ConsistencyLevel
      */
     public ConsistencyLevel consistency_level;
 
     /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
     public enum _Fields implements TFieldIdEnum {
       KEYSPACE((short)1, "keyspace"),
       KEY((short)2, "key"),
       CFMAP((short)3, "cfmap"),
       /**
        * 
        * @see ConsistencyLevel
        */
       CONSISTENCY_LEVEL((short)4, "consistency_level");
 
       private static final Map<Integer, _Fields> byId = new HashMap<Integer, _Fields>();
       private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();
 
       static {
         for (_Fields field : EnumSet.allOf(_Fields.class)) {
           byId.put((int)field._thriftId, field);
           byName.put(field.getFieldName(), field);
         }
       }
 
       /**
        * Find the _Fields constant that matches fieldId, or null if its not found.
        */
       public static _Fields findByThriftId(int fieldId) {
         return byId.get(fieldId);
       }
 
       /**
        * Find the _Fields constant that matches fieldId, throwing an exception
        * if it is not found.
        */
       public static _Fields findByThriftIdOrThrow(int fieldId) {
         _Fields fields = findByThriftId(fieldId);
         if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
         return fields;
       }
 
       /**
        * Find the _Fields constant that matches name, or null if its not found.
        */
       public static _Fields findByName(String name) {
         return byName.get(name);
       }
 
       private final short _thriftId;
       private final String _fieldName;
 
       _Fields(short thriftId, String fieldName) {
         _thriftId = thriftId;
         _fieldName = fieldName;
       }
 
       public short getThriftFieldId() {
         return _thriftId;
       }
 
       public String getFieldName() {
         return _fieldName;
       }
     }
 
     // isset id assignments
 
     public static final Map<_Fields, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new EnumMap<_Fields, FieldMetaData>(_Fields.class) {{
       put(_Fields.KEYSPACE, new FieldMetaData("keyspace", TFieldRequirementType.REQUIRED, 
           new FieldValueMetaData(TType.STRING)));
       put(_Fields.KEY, new FieldMetaData("key", TFieldRequirementType.REQUIRED, 
           new FieldValueMetaData(TType.STRING)));
       put(_Fields.CFMAP, new FieldMetaData("cfmap", TFieldRequirementType.REQUIRED, 
           new MapMetaData(TType.MAP, 
               new FieldValueMetaData(TType.STRING), 
               new ListMetaData(TType.LIST, 
                   new StructMetaData(TType.STRUCT, ColumnOrSuperColumn.class)))));
       put(_Fields.CONSISTENCY_LEVEL, new FieldMetaData("consistency_level", TFieldRequirementType.REQUIRED, 
           new EnumMetaData(TType.ENUM, ConsistencyLevel.class)));
     }});
 
     static {
       FieldMetaData.addStructMetaDataMap(batch_insert_args.class, metaDataMap);
     }
 
     public batch_insert_args() {
       this.consistency_level = ConsistencyLevel.ONE;
 
     }
 
     public batch_insert_args(
       String keyspace,
       byte[] key,
       Map<String,List<ColumnOrSuperColumn>> cfmap,
       ConsistencyLevel consistency_level)
     {
       this();
       this.keyspace = keyspace;
       this.key = key;
       this.cfmap = cfmap;
       this.consistency_level = consistency_level;
     }
 
     /**
      * Performs a deep copy on <i>other</i>.
      */
     public batch_insert_args(batch_insert_args other) {
       if (other.isSetKeyspace()) {
         this.keyspace = other.keyspace;
       }
       if (other.isSetKey()) {
         this.key = new byte[other.key.length];
         System.arraycopy(other.key, 0, key, 0, other.key.length);
       }
       if (other.isSetCfmap()) {
         Map<String,List<ColumnOrSuperColumn>> __this__cfmap = new HashMap<String,List<ColumnOrSuperColumn>>();
         for (Map.Entry<String, List<ColumnOrSuperColumn>> other_element : other.cfmap.entrySet()) {
 
           String other_element_key = other_element.getKey();
           List<ColumnOrSuperColumn> other_element_value = other_element.getValue();
 
           String __this__cfmap_copy_key = other_element_key;
 
           List<ColumnOrSuperColumn> __this__cfmap_copy_value = new ArrayList<ColumnOrSuperColumn>();
           for (ColumnOrSuperColumn other_element_value_element : other_element_value) {
             __this__cfmap_copy_value.add(new ColumnOrSuperColumn(other_element_value_element));
           }
 
           __this__cfmap.put(__this__cfmap_copy_key, __this__cfmap_copy_value);
         }
         this.cfmap = __this__cfmap;
       }
       if (other.isSetConsistency_level()) {
         this.consistency_level = other.consistency_level;
       }
     }
 
     public batch_insert_args deepCopy() {
       return new batch_insert_args(this);
     }
 
     @Deprecated
     public batch_insert_args clone() {
       return new batch_insert_args(this);
     }
 
     public String getKeyspace() {
       return this.keyspace;
     }
 
     public batch_insert_args setKeyspace(String keyspace) {
       this.keyspace = keyspace;
       return this;
     }
 
     public void unsetKeyspace() {
       this.keyspace = null;
     }
 
     /** Returns true if field keyspace is set (has been asigned a value) and false otherwise */
     public boolean isSetKeyspace() {
       return this.keyspace != null;
     }
 
     public void setKeyspaceIsSet(boolean value) {
       if (!value) {
         this.keyspace = null;
       }
     }
 
     public byte[] getKey() {
       return this.key;
     }
 
     public batch_insert_args setKey(byte[] key) {
       this.key = key;
       return this;
     }
 
     public void unsetKey() {
       this.key = null;
     }
 
     /** Returns true if field key is set (has been asigned a value) and false otherwise */
     public boolean isSetKey() {
       return this.key != null;
     }
 
     public void setKeyIsSet(boolean value) {
       if (!value) {
         this.key = null;
       }
     }
 
     public int getCfmapSize() {
       return (this.cfmap == null) ? 0 : this.cfmap.size();
     }
 
     public void putToCfmap(String key, List<ColumnOrSuperColumn> val) {
       if (this.cfmap == null) {
         this.cfmap = new HashMap<String,List<ColumnOrSuperColumn>>();
       }
       this.cfmap.put(key, val);
     }
 
     public Map<String,List<ColumnOrSuperColumn>> getCfmap() {
       return this.cfmap;
     }
 
     public batch_insert_args setCfmap(Map<String,List<ColumnOrSuperColumn>> cfmap) {
       this.cfmap = cfmap;
       return this;
     }
 
     public void unsetCfmap() {
       this.cfmap = null;
     }
 
     /** Returns true if field cfmap is set (has been asigned a value) and false otherwise */
     public boolean isSetCfmap() {
       return this.cfmap != null;
     }
 
     public void setCfmapIsSet(boolean value) {
       if (!value) {
         this.cfmap = null;
       }
     }
 
     /**
      * 
      * @see ConsistencyLevel
      */
     public ConsistencyLevel getConsistency_level() {
       return this.consistency_level;
     }
 
     /**
      * 
      * @see ConsistencyLevel
      */
     public batch_insert_args setConsistency_level(ConsistencyLevel consistency_level) {
       this.consistency_level = consistency_level;
       return this;
     }
 
     public void unsetConsistency_level() {
       this.consistency_level = null;
     }
 
     /** Returns true if field consistency_level is set (has been asigned a value) and false otherwise */
     public boolean isSetConsistency_level() {
       return this.consistency_level != null;
     }
 
     public void setConsistency_levelIsSet(boolean value) {
       if (!value) {
         this.consistency_level = null;
       }
     }
 
     public void setFieldValue(_Fields field, Object value) {
       switch (field) {
       case KEYSPACE:
         if (value == null) {
           unsetKeyspace();
         } else {
           setKeyspace((String)value);
         }
         break;
 
       case KEY:
         if (value == null) {
           unsetKey();
         } else {
           setKey((byte[])value);
         }
         break;
 
       case CFMAP:
         if (value == null) {
           unsetCfmap();
         } else {
           setCfmap((Map<String,List<ColumnOrSuperColumn>>)value);
         }
         break;
 
       case CONSISTENCY_LEVEL:
         if (value == null) {
           unsetConsistency_level();
         } else {
           setConsistency_level((ConsistencyLevel)value);
         }
         break;
 
       }
     }
 
     public void setFieldValue(int fieldID, Object value) {
       setFieldValue(_Fields.findByThriftIdOrThrow(fieldID), value);
     }
 
     public Object getFieldValue(_Fields field) {
       switch (field) {
       case KEYSPACE:
         return getKeyspace();
 
       case KEY:
         return getKey();
 
       case CFMAP:
         return getCfmap();
 
       case CONSISTENCY_LEVEL:
         return getConsistency_level();
 
       }
       throw new IllegalStateException();
     }
 
     public Object getFieldValue(int fieldId) {
       return getFieldValue(_Fields.findByThriftIdOrThrow(fieldId));
     }
 
     /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
     public boolean isSet(_Fields field) {
       switch (field) {
       case KEYSPACE:
         return isSetKeyspace();
       case KEY:
         return isSetKey();
       case CFMAP:
         return isSetCfmap();
       case CONSISTENCY_LEVEL:
         return isSetConsistency_level();
       }
       throw new IllegalStateException();
     }
 
     public boolean isSet(int fieldID) {
       return isSet(_Fields.findByThriftIdOrThrow(fieldID));
     }
 
     @Override
     public boolean equals(Object that) {
       if (that == null)
         return false;
       if (that instanceof batch_insert_args)
         return this.equals((batch_insert_args)that);
       return false;
     }
 
     public boolean equals(batch_insert_args that) {
       if (that == null)
         return false;
 
       boolean this_present_keyspace = true && this.isSetKeyspace();
       boolean that_present_keyspace = true && that.isSetKeyspace();
       if (this_present_keyspace || that_present_keyspace) {
         if (!(this_present_keyspace && that_present_keyspace))
           return false;
         if (!this.keyspace.equals(that.keyspace))
           return false;
       }
 
       boolean this_present_key = true && this.isSetKey();
       boolean that_present_key = true && that.isSetKey();
       if (this_present_key || that_present_key) {
         if (!(this_present_key && that_present_key))
           return false;
         if (!java.util.Arrays.equals(this.key, that.key))
           return false;
       }
 
       boolean this_present_cfmap = true && this.isSetCfmap();
       boolean that_present_cfmap = true && that.isSetCfmap();
       if (this_present_cfmap || that_present_cfmap) {
         if (!(this_present_cfmap && that_present_cfmap))
           return false;
         if (!this.cfmap.equals(that.cfmap))
           return false;
       }
 
       boolean this_present_consistency_level = true && this.isSetConsistency_level();
       boolean that_present_consistency_level = true && that.isSetConsistency_level();
       if (this_present_consistency_level || that_present_consistency_level) {
         if (!(this_present_consistency_level && that_present_consistency_level))
           return false;
         if (!this.consistency_level.equals(that.consistency_level))
           return false;
       }
 
       return true;
     }
 
     @Override
     public int hashCode() {
       return 0;
     }
 
     public void read(TProtocol iprot) throws TException {
       TField field;
       iprot.readStructBegin();
       while (true)
       {
         field = iprot.readFieldBegin();
         if (field.type == TType.STOP) { 
           break;
         }
         switch (field.id) {
           case 1: // KEYSPACE
             if (field.type == TType.STRING) {
               this.keyspace = iprot.readString();
             } else { 
               TProtocolUtil.skip(iprot, field.type);
             }
             break;
           case 2: // KEY
             if (field.type == TType.STRING) {
               this.key = iprot.readBinary();
             } else { 
               TProtocolUtil.skip(iprot, field.type);
             }
             break;
           case 3: // CFMAP
             if (field.type == TType.MAP) {
               {
                TMap _map72 = iprot.readMapBegin();
                this.cfmap = new HashMap<String,List<ColumnOrSuperColumn>>(2*_map72.size);
                for (int _i73 = 0; _i73 < _map72.size; ++_i73)
                {
                  String _key74;
                  List<ColumnOrSuperColumn> _val75;
                  _key74 = iprot.readString();
                  {
                    TList _list76 = iprot.readListBegin();
                    _val75 = new ArrayList<ColumnOrSuperColumn>(_list76.size);
                    for (int _i77 = 0; _i77 < _list76.size; ++_i77)
                    {
                      ColumnOrSuperColumn _elem78;
                      _elem78 = new ColumnOrSuperColumn();
                      _elem78.read(iprot);
                      _val75.add(_elem78);
                     }
                     iprot.readListEnd();
                   }
                  this.cfmap.put(_key74, _val75);
                 }
                 iprot.readMapEnd();
               }
             } else { 
               TProtocolUtil.skip(iprot, field.type);
             }
             break;
           case 4: // CONSISTENCY_LEVEL
             if (field.type == TType.I32) {
               this.consistency_level = ConsistencyLevel.findByValue(iprot.readI32());
             } else { 
               TProtocolUtil.skip(iprot, field.type);
             }
             break;
           default:
             TProtocolUtil.skip(iprot, field.type);
         }
         iprot.readFieldEnd();
       }
       iprot.readStructEnd();
 
       // check for required fields of primitive type, which can't be checked in the validate method
       validate();
     }
 
     public void write(TProtocol oprot) throws TException {
       validate();
 
       oprot.writeStructBegin(STRUCT_DESC);
       if (this.keyspace != null) {
         oprot.writeFieldBegin(KEYSPACE_FIELD_DESC);
         oprot.writeString(this.keyspace);
         oprot.writeFieldEnd();
       }
       if (this.key != null) {
         oprot.writeFieldBegin(KEY_FIELD_DESC);
         oprot.writeBinary(this.key);
         oprot.writeFieldEnd();
       }
       if (this.cfmap != null) {
         oprot.writeFieldBegin(CFMAP_FIELD_DESC);
         {
           oprot.writeMapBegin(new TMap(TType.STRING, TType.LIST, this.cfmap.size()));
          for (Map.Entry<String, List<ColumnOrSuperColumn>> _iter79 : this.cfmap.entrySet())
           {
            oprot.writeString(_iter79.getKey());
             {
              oprot.writeListBegin(new TList(TType.STRUCT, _iter79.getValue().size()));
              for (ColumnOrSuperColumn _iter80 : _iter79.getValue())
               {
                _iter80.write(oprot);
               }
               oprot.writeListEnd();
             }
           }
           oprot.writeMapEnd();
         }
         oprot.writeFieldEnd();
       }
       if (this.consistency_level != null) {
         oprot.writeFieldBegin(CONSISTENCY_LEVEL_FIELD_DESC);
         oprot.writeI32(this.consistency_level.getValue());
         oprot.writeFieldEnd();
       }
       oprot.writeFieldStop();
       oprot.writeStructEnd();
     }
 
     @Override
     public String toString() {
       StringBuilder sb = new StringBuilder("batch_insert_args(");
       boolean first = true;
 
       sb.append("keyspace:");
       if (this.keyspace == null) {
         sb.append("null");
       } else {
         sb.append(this.keyspace);
       }
       first = false;
       if (!first) sb.append(", ");
       sb.append("key:");
       if (this.key == null) {
         sb.append("null");
       } else {
           int __key_size = Math.min(this.key.length, 128);
           for (int i = 0; i < __key_size; i++) {
             if (i != 0) sb.append(" ");
             sb.append(Integer.toHexString(this.key[i]).length() > 1 ? Integer.toHexString(this.key[i]).substring(Integer.toHexString(this.key[i]).length() - 2).toUpperCase() : "0" + Integer.toHexString(this.key[i]).toUpperCase());
           }
           if (this.key.length > 128) sb.append(" ...");
       }
       first = false;
       if (!first) sb.append(", ");
       sb.append("cfmap:");
       if (this.cfmap == null) {
         sb.append("null");
       } else {
         sb.append(this.cfmap);
       }
       first = false;
       if (!first) sb.append(", ");
       sb.append("consistency_level:");
       if (this.consistency_level == null) {
         sb.append("null");
       } else {
         sb.append(this.consistency_level);
       }
       first = false;
       sb.append(")");
       return sb.toString();
     }
 
     public void validate() throws TException {
       // check for required fields
       if (keyspace == null) {
         throw new TProtocolException("Required field 'keyspace' was not present! Struct: " + toString());
       }
       if (key == null) {
         throw new TProtocolException("Required field 'key' was not present! Struct: " + toString());
       }
       if (cfmap == null) {
         throw new TProtocolException("Required field 'cfmap' was not present! Struct: " + toString());
       }
       if (consistency_level == null) {
         throw new TProtocolException("Required field 'consistency_level' was not present! Struct: " + toString());
       }
     }
 
   }
 
   public static class batch_insert_result implements TBase<batch_insert_result._Fields>, java.io.Serializable, Cloneable, Comparable<batch_insert_result>   {
     private static final TStruct STRUCT_DESC = new TStruct("batch_insert_result");
 
     private static final TField IRE_FIELD_DESC = new TField("ire", TType.STRUCT, (short)1);
     private static final TField UE_FIELD_DESC = new TField("ue", TType.STRUCT, (short)2);
     private static final TField TE_FIELD_DESC = new TField("te", TType.STRUCT, (short)3);
 
     public InvalidRequestException ire;
     public UnavailableException ue;
     public TimedOutException te;
 
     /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
     public enum _Fields implements TFieldIdEnum {
       IRE((short)1, "ire"),
       UE((short)2, "ue"),
       TE((short)3, "te");
 
       private static final Map<Integer, _Fields> byId = new HashMap<Integer, _Fields>();
       private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();
 
       static {
         for (_Fields field : EnumSet.allOf(_Fields.class)) {
           byId.put((int)field._thriftId, field);
           byName.put(field.getFieldName(), field);
         }
       }
 
       /**
        * Find the _Fields constant that matches fieldId, or null if its not found.
        */
       public static _Fields findByThriftId(int fieldId) {
         return byId.get(fieldId);
       }
 
       /**
        * Find the _Fields constant that matches fieldId, throwing an exception
        * if it is not found.
        */
       public static _Fields findByThriftIdOrThrow(int fieldId) {
         _Fields fields = findByThriftId(fieldId);
         if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
         return fields;
       }
 
       /**
        * Find the _Fields constant that matches name, or null if its not found.
        */
       public static _Fields findByName(String name) {
         return byName.get(name);
       }
 
       private final short _thriftId;
       private final String _fieldName;
 
       _Fields(short thriftId, String fieldName) {
         _thriftId = thriftId;
         _fieldName = fieldName;
       }
 
       public short getThriftFieldId() {
         return _thriftId;
       }
 
       public String getFieldName() {
         return _fieldName;
       }
     }
 
     // isset id assignments
 
     public static final Map<_Fields, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new EnumMap<_Fields, FieldMetaData>(_Fields.class) {{
       put(_Fields.IRE, new FieldMetaData("ire", TFieldRequirementType.DEFAULT, 
           new FieldValueMetaData(TType.STRUCT)));
       put(_Fields.UE, new FieldMetaData("ue", TFieldRequirementType.DEFAULT, 
           new FieldValueMetaData(TType.STRUCT)));
       put(_Fields.TE, new FieldMetaData("te", TFieldRequirementType.DEFAULT, 
           new FieldValueMetaData(TType.STRUCT)));
     }});
 
     static {
       FieldMetaData.addStructMetaDataMap(batch_insert_result.class, metaDataMap);
     }
 
     public batch_insert_result() {
     }
 
     public batch_insert_result(
       InvalidRequestException ire,
       UnavailableException ue,
       TimedOutException te)
     {
       this();
       this.ire = ire;
       this.ue = ue;
       this.te = te;
     }
 
     /**
      * Performs a deep copy on <i>other</i>.
      */
     public batch_insert_result(batch_insert_result other) {
       if (other.isSetIre()) {
         this.ire = new InvalidRequestException(other.ire);
       }
       if (other.isSetUe()) {
         this.ue = new UnavailableException(other.ue);
       }
       if (other.isSetTe()) {
         this.te = new TimedOutException(other.te);
       }
     }
 
     public batch_insert_result deepCopy() {
       return new batch_insert_result(this);
     }
 
     @Deprecated
     public batch_insert_result clone() {
       return new batch_insert_result(this);
     }
 
     public InvalidRequestException getIre() {
       return this.ire;
     }
 
     public batch_insert_result setIre(InvalidRequestException ire) {
       this.ire = ire;
       return this;
     }
 
     public void unsetIre() {
       this.ire = null;
     }
 
     /** Returns true if field ire is set (has been asigned a value) and false otherwise */
     public boolean isSetIre() {
       return this.ire != null;
     }
 
     public void setIreIsSet(boolean value) {
       if (!value) {
         this.ire = null;
       }
     }
 
     public UnavailableException getUe() {
       return this.ue;
     }
 
     public batch_insert_result setUe(UnavailableException ue) {
       this.ue = ue;
       return this;
     }
 
     public void unsetUe() {
       this.ue = null;
     }
 
     /** Returns true if field ue is set (has been asigned a value) and false otherwise */
     public boolean isSetUe() {
       return this.ue != null;
     }
 
     public void setUeIsSet(boolean value) {
       if (!value) {
         this.ue = null;
       }
     }
 
     public TimedOutException getTe() {
       return this.te;
     }
 
     public batch_insert_result setTe(TimedOutException te) {
       this.te = te;
       return this;
     }
 
     public void unsetTe() {
       this.te = null;
     }
 
     /** Returns true if field te is set (has been asigned a value) and false otherwise */
     public boolean isSetTe() {
       return this.te != null;
     }
 
     public void setTeIsSet(boolean value) {
       if (!value) {
         this.te = null;
       }
     }
 
     public void setFieldValue(_Fields field, Object value) {
       switch (field) {
       case IRE:
         if (value == null) {
           unsetIre();
         } else {
           setIre((InvalidRequestException)value);
         }
         break;
 
       case UE:
         if (value == null) {
           unsetUe();
         } else {
           setUe((UnavailableException)value);
         }
         break;
 
       case TE:
         if (value == null) {
           unsetTe();
         } else {
           setTe((TimedOutException)value);
         }
         break;
 
       }
     }
 
     public void setFieldValue(int fieldID, Object value) {
       setFieldValue(_Fields.findByThriftIdOrThrow(fieldID), value);
     }
 
     public Object getFieldValue(_Fields field) {
       switch (field) {
       case IRE:
         return getIre();
 
       case UE:
         return getUe();
 
       case TE:
         return getTe();
 
       }
       throw new IllegalStateException();
     }
 
     public Object getFieldValue(int fieldId) {
       return getFieldValue(_Fields.findByThriftIdOrThrow(fieldId));
     }
 
     /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
     public boolean isSet(_Fields field) {
       switch (field) {
       case IRE:
         return isSetIre();
       case UE:
         return isSetUe();
       case TE:
         return isSetTe();
       }
       throw new IllegalStateException();
     }
 
     public boolean isSet(int fieldID) {
       return isSet(_Fields.findByThriftIdOrThrow(fieldID));
     }
 
     @Override
     public boolean equals(Object that) {
       if (that == null)
         return false;
       if (that instanceof batch_insert_result)
         return this.equals((batch_insert_result)that);
       return false;
     }
 
     public boolean equals(batch_insert_result that) {
       if (that == null)
         return false;
 
       boolean this_present_ire = true && this.isSetIre();
       boolean that_present_ire = true && that.isSetIre();
       if (this_present_ire || that_present_ire) {
         if (!(this_present_ire && that_present_ire))
           return false;
         if (!this.ire.equals(that.ire))
           return false;
       }
 
       boolean this_present_ue = true && this.isSetUe();
       boolean that_present_ue = true && that.isSetUe();
       if (this_present_ue || that_present_ue) {
         if (!(this_present_ue && that_present_ue))
           return false;
         if (!this.ue.equals(that.ue))
           return false;
       }
 
       boolean this_present_te = true && this.isSetTe();
       boolean that_present_te = true && that.isSetTe();
       if (this_present_te || that_present_te) {
         if (!(this_present_te && that_present_te))
           return false;
         if (!this.te.equals(that.te))
           return false;
       }
 
       return true;
     }
 
     @Override
     public int hashCode() {
       return 0;
     }
 
     public int compareTo(batch_insert_result other) {
       if (!getClass().equals(other.getClass())) {
         return getClass().getName().compareTo(other.getClass().getName());
       }
 
       int lastComparison = 0;
       batch_insert_result typedOther = (batch_insert_result)other;
 
       lastComparison = Boolean.valueOf(isSetIre()).compareTo(typedOther.isSetIre());
       if (lastComparison != 0) {
         return lastComparison;
       }
       if (isSetIre()) {        lastComparison = TBaseHelper.compareTo(ire, typedOther.ire);
         if (lastComparison != 0) {
           return lastComparison;
         }
       }
       lastComparison = Boolean.valueOf(isSetUe()).compareTo(typedOther.isSetUe());
       if (lastComparison != 0) {
         return lastComparison;
       }
       if (isSetUe()) {        lastComparison = TBaseHelper.compareTo(ue, typedOther.ue);
         if (lastComparison != 0) {
           return lastComparison;
         }
       }
       lastComparison = Boolean.valueOf(isSetTe()).compareTo(typedOther.isSetTe());
       if (lastComparison != 0) {
         return lastComparison;
       }
       if (isSetTe()) {        lastComparison = TBaseHelper.compareTo(te, typedOther.te);
         if (lastComparison != 0) {
           return lastComparison;
         }
       }
       return 0;
     }
 
     public void read(TProtocol iprot) throws TException {
       TField field;
       iprot.readStructBegin();
       while (true)
       {
         field = iprot.readFieldBegin();
         if (field.type == TType.STOP) { 
           break;
         }
         switch (field.id) {
           case 1: // IRE
             if (field.type == TType.STRUCT) {
               this.ire = new InvalidRequestException();
               this.ire.read(iprot);
             } else { 
               TProtocolUtil.skip(iprot, field.type);
             }
             break;
           case 2: // UE
             if (field.type == TType.STRUCT) {
               this.ue = new UnavailableException();
               this.ue.read(iprot);
             } else { 
               TProtocolUtil.skip(iprot, field.type);
             }
             break;
           case 3: // TE
             if (field.type == TType.STRUCT) {
               this.te = new TimedOutException();
               this.te.read(iprot);
             } else { 
               TProtocolUtil.skip(iprot, field.type);
             }
             break;
           default:
             TProtocolUtil.skip(iprot, field.type);
         }
         iprot.readFieldEnd();
       }
       iprot.readStructEnd();
 
       // check for required fields of primitive type, which can't be checked in the validate method
       validate();
     }
 
     public void write(TProtocol oprot) throws TException {
       oprot.writeStructBegin(STRUCT_DESC);
 
       if (this.isSetIre()) {
         oprot.writeFieldBegin(IRE_FIELD_DESC);
         this.ire.write(oprot);
         oprot.writeFieldEnd();
       } else if (this.isSetUe()) {
         oprot.writeFieldBegin(UE_FIELD_DESC);
         this.ue.write(oprot);
         oprot.writeFieldEnd();
       } else if (this.isSetTe()) {
         oprot.writeFieldBegin(TE_FIELD_DESC);
         this.te.write(oprot);
         oprot.writeFieldEnd();
       }
       oprot.writeFieldStop();
       oprot.writeStructEnd();
     }
 
     @Override
     public String toString() {
       StringBuilder sb = new StringBuilder("batch_insert_result(");
       boolean first = true;
 
       sb.append("ire:");
       if (this.ire == null) {
         sb.append("null");
       } else {
         sb.append(this.ire);
       }
       first = false;
       if (!first) sb.append(", ");
       sb.append("ue:");
       if (this.ue == null) {
         sb.append("null");
       } else {
         sb.append(this.ue);
       }
       first = false;
       if (!first) sb.append(", ");
       sb.append("te:");
       if (this.te == null) {
         sb.append("null");
       } else {
         sb.append(this.te);
       }
       first = false;
       sb.append(")");
       return sb.toString();
     }
 
     public void validate() throws TException {
       // check for required fields
     }
 
   }
 
   public static class remove_args implements TBase<remove_args._Fields>, java.io.Serializable, Cloneable, Comparable<remove_args>   {
     private static final TStruct STRUCT_DESC = new TStruct("remove_args");
 
     private static final TField KEYSPACE_FIELD_DESC = new TField("keyspace", TType.STRING, (short)1);
     private static final TField KEY_FIELD_DESC = new TField("key", TType.STRING, (short)2);
     private static final TField COLUMN_PATH_FIELD_DESC = new TField("column_path", TType.STRUCT, (short)3);
     private static final TField TIMESTAMP_FIELD_DESC = new TField("timestamp", TType.I64, (short)4);
     private static final TField CONSISTENCY_LEVEL_FIELD_DESC = new TField("consistency_level", TType.I32, (short)5);
 
     public String keyspace;
     public byte[] key;
     public ColumnPath column_path;
     public long timestamp;
     /**
      * 
      * @see ConsistencyLevel
      */
     public ConsistencyLevel consistency_level;
 
     /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
     public enum _Fields implements TFieldIdEnum {
       KEYSPACE((short)1, "keyspace"),
       KEY((short)2, "key"),
       COLUMN_PATH((short)3, "column_path"),
       TIMESTAMP((short)4, "timestamp"),
       /**
        * 
        * @see ConsistencyLevel
        */
       CONSISTENCY_LEVEL((short)5, "consistency_level");
 
       private static final Map<Integer, _Fields> byId = new HashMap<Integer, _Fields>();
       private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();
 
       static {
         for (_Fields field : EnumSet.allOf(_Fields.class)) {
           byId.put((int)field._thriftId, field);
           byName.put(field.getFieldName(), field);
         }
       }
 
       /**
        * Find the _Fields constant that matches fieldId, or null if its not found.
        */
       public static _Fields findByThriftId(int fieldId) {
         return byId.get(fieldId);
       }
 
       /**
        * Find the _Fields constant that matches fieldId, throwing an exception
        * if it is not found.
        */
       public static _Fields findByThriftIdOrThrow(int fieldId) {
         _Fields fields = findByThriftId(fieldId);
         if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
         return fields;
       }
 
       /**
        * Find the _Fields constant that matches name, or null if its not found.
        */
       public static _Fields findByName(String name) {
         return byName.get(name);
       }
 
       private final short _thriftId;
       private final String _fieldName;
 
       _Fields(short thriftId, String fieldName) {
         _thriftId = thriftId;
         _fieldName = fieldName;
       }
 
       public short getThriftFieldId() {
         return _thriftId;
       }
 
       public String getFieldName() {
         return _fieldName;
       }
     }
 
     // isset id assignments
     private static final int __TIMESTAMP_ISSET_ID = 0;
     private BitSet __isset_bit_vector = new BitSet(1);
 
     public static final Map<_Fields, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new EnumMap<_Fields, FieldMetaData>(_Fields.class) {{
       put(_Fields.KEYSPACE, new FieldMetaData("keyspace", TFieldRequirementType.REQUIRED, 
           new FieldValueMetaData(TType.STRING)));
       put(_Fields.KEY, new FieldMetaData("key", TFieldRequirementType.REQUIRED, 
           new FieldValueMetaData(TType.STRING)));
       put(_Fields.COLUMN_PATH, new FieldMetaData("column_path", TFieldRequirementType.REQUIRED, 
           new StructMetaData(TType.STRUCT, ColumnPath.class)));
       put(_Fields.TIMESTAMP, new FieldMetaData("timestamp", TFieldRequirementType.REQUIRED, 
           new FieldValueMetaData(TType.I64)));
       put(_Fields.CONSISTENCY_LEVEL, new FieldMetaData("consistency_level", TFieldRequirementType.DEFAULT, 
           new EnumMetaData(TType.ENUM, ConsistencyLevel.class)));
     }});
 
     static {
       FieldMetaData.addStructMetaDataMap(remove_args.class, metaDataMap);
     }
 
     public remove_args() {
       this.consistency_level = ConsistencyLevel.ONE;
 
     }
 
     public remove_args(
       String keyspace,
       byte[] key,
       ColumnPath column_path,
       long timestamp,
       ConsistencyLevel consistency_level)
     {
       this();
       this.keyspace = keyspace;
       this.key = key;
       this.column_path = column_path;
       this.timestamp = timestamp;
       setTimestampIsSet(true);
       this.consistency_level = consistency_level;
     }
 
     /**
      * Performs a deep copy on <i>other</i>.
      */
     public remove_args(remove_args other) {
       __isset_bit_vector.clear();
       __isset_bit_vector.or(other.__isset_bit_vector);
       if (other.isSetKeyspace()) {
         this.keyspace = other.keyspace;
       }
       if (other.isSetKey()) {
         this.key = new byte[other.key.length];
         System.arraycopy(other.key, 0, key, 0, other.key.length);
       }
       if (other.isSetColumn_path()) {
         this.column_path = new ColumnPath(other.column_path);
       }
       this.timestamp = other.timestamp;
       if (other.isSetConsistency_level()) {
         this.consistency_level = other.consistency_level;
       }
     }
 
     public remove_args deepCopy() {
       return new remove_args(this);
     }
 
     @Deprecated
     public remove_args clone() {
       return new remove_args(this);
     }
 
     public String getKeyspace() {
       return this.keyspace;
     }
 
     public remove_args setKeyspace(String keyspace) {
       this.keyspace = keyspace;
       return this;
     }
 
     public void unsetKeyspace() {
       this.keyspace = null;
     }
 
     /** Returns true if field keyspace is set (has been asigned a value) and false otherwise */
     public boolean isSetKeyspace() {
       return this.keyspace != null;
     }
 
     public void setKeyspaceIsSet(boolean value) {
       if (!value) {
         this.keyspace = null;
       }
     }
 
     public byte[] getKey() {
       return this.key;
     }
 
     public remove_args setKey(byte[] key) {
       this.key = key;
       return this;
     }
 
     public void unsetKey() {
       this.key = null;
     }
 
     /** Returns true if field key is set (has been asigned a value) and false otherwise */
     public boolean isSetKey() {
       return this.key != null;
     }
 
     public void setKeyIsSet(boolean value) {
       if (!value) {
         this.key = null;
       }
     }
 
     public ColumnPath getColumn_path() {
       return this.column_path;
     }
 
     public remove_args setColumn_path(ColumnPath column_path) {
       this.column_path = column_path;
       return this;
     }
 
     public void unsetColumn_path() {
       this.column_path = null;
     }
 
     /** Returns true if field column_path is set (has been asigned a value) and false otherwise */
     public boolean isSetColumn_path() {
       return this.column_path != null;
     }
 
     public void setColumn_pathIsSet(boolean value) {
       if (!value) {
         this.column_path = null;
       }
     }
 
     public long getTimestamp() {
       return this.timestamp;
     }
 
     public remove_args setTimestamp(long timestamp) {
       this.timestamp = timestamp;
       setTimestampIsSet(true);
       return this;
     }
 
     public void unsetTimestamp() {
       __isset_bit_vector.clear(__TIMESTAMP_ISSET_ID);
     }
 
     /** Returns true if field timestamp is set (has been asigned a value) and false otherwise */
     public boolean isSetTimestamp() {
       return __isset_bit_vector.get(__TIMESTAMP_ISSET_ID);
     }
 
     public void setTimestampIsSet(boolean value) {
       __isset_bit_vector.set(__TIMESTAMP_ISSET_ID, value);
     }
 
     /**
      * 
      * @see ConsistencyLevel
      */
     public ConsistencyLevel getConsistency_level() {
       return this.consistency_level;
     }
 
     /**
      * 
      * @see ConsistencyLevel
      */
     public remove_args setConsistency_level(ConsistencyLevel consistency_level) {
       this.consistency_level = consistency_level;
       return this;
     }
 
     public void unsetConsistency_level() {
       this.consistency_level = null;
     }
 
     /** Returns true if field consistency_level is set (has been asigned a value) and false otherwise */
     public boolean isSetConsistency_level() {
       return this.consistency_level != null;
     }
 
     public void setConsistency_levelIsSet(boolean value) {
       if (!value) {
         this.consistency_level = null;
       }
     }
 
     public void setFieldValue(_Fields field, Object value) {
       switch (field) {
       case KEYSPACE:
         if (value == null) {
           unsetKeyspace();
         } else {
           setKeyspace((String)value);
         }
         break;
 
       case KEY:
         if (value == null) {
           unsetKey();
         } else {
           setKey((byte[])value);
         }
         break;
 
       case COLUMN_PATH:
         if (value == null) {
           unsetColumn_path();
         } else {
           setColumn_path((ColumnPath)value);
         }
         break;
 
       case TIMESTAMP:
         if (value == null) {
           unsetTimestamp();
         } else {
           setTimestamp((Long)value);
         }
         break;
 
       case CONSISTENCY_LEVEL:
         if (value == null) {
           unsetConsistency_level();
         } else {
           setConsistency_level((ConsistencyLevel)value);
         }
         break;
 
       }
     }
 
     public void setFieldValue(int fieldID, Object value) {
       setFieldValue(_Fields.findByThriftIdOrThrow(fieldID), value);
     }
 
     public Object getFieldValue(_Fields field) {
       switch (field) {
       case KEYSPACE:
         return getKeyspace();
 
       case KEY:
         return getKey();
 
       case COLUMN_PATH:
         return getColumn_path();
 
       case TIMESTAMP:
         return new Long(getTimestamp());
 
       case CONSISTENCY_LEVEL:
         return getConsistency_level();
 
       }
       throw new IllegalStateException();
     }
 
     public Object getFieldValue(int fieldId) {
       return getFieldValue(_Fields.findByThriftIdOrThrow(fieldId));
     }
 
     /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
     public boolean isSet(_Fields field) {
       switch (field) {
       case KEYSPACE:
         return isSetKeyspace();
       case KEY:
         return isSetKey();
       case COLUMN_PATH:
         return isSetColumn_path();
       case TIMESTAMP:
         return isSetTimestamp();
       case CONSISTENCY_LEVEL:
         return isSetConsistency_level();
       }
       throw new IllegalStateException();
     }
 
     public boolean isSet(int fieldID) {
       return isSet(_Fields.findByThriftIdOrThrow(fieldID));
     }
 
     @Override
     public boolean equals(Object that) {
       if (that == null)
         return false;
       if (that instanceof remove_args)
         return this.equals((remove_args)that);
       return false;
     }
 
     public boolean equals(remove_args that) {
       if (that == null)
         return false;
 
       boolean this_present_keyspace = true && this.isSetKeyspace();
       boolean that_present_keyspace = true && that.isSetKeyspace();
       if (this_present_keyspace || that_present_keyspace) {
         if (!(this_present_keyspace && that_present_keyspace))
           return false;
         if (!this.keyspace.equals(that.keyspace))
           return false;
       }
 
       boolean this_present_key = true && this.isSetKey();
       boolean that_present_key = true && that.isSetKey();
       if (this_present_key || that_present_key) {
         if (!(this_present_key && that_present_key))
           return false;
         if (!java.util.Arrays.equals(this.key, that.key))
           return false;
       }
 
       boolean this_present_column_path = true && this.isSetColumn_path();
       boolean that_present_column_path = true && that.isSetColumn_path();
       if (this_present_column_path || that_present_column_path) {
         if (!(this_present_column_path && that_present_column_path))
           return false;
         if (!this.column_path.equals(that.column_path))
           return false;
       }
 
       boolean this_present_timestamp = true;
       boolean that_present_timestamp = true;
       if (this_present_timestamp || that_present_timestamp) {
         if (!(this_present_timestamp && that_present_timestamp))
           return false;
         if (this.timestamp != that.timestamp)
           return false;
       }
 
       boolean this_present_consistency_level = true && this.isSetConsistency_level();
       boolean that_present_consistency_level = true && that.isSetConsistency_level();
       if (this_present_consistency_level || that_present_consistency_level) {
         if (!(this_present_consistency_level && that_present_consistency_level))
           return false;
         if (!this.consistency_level.equals(that.consistency_level))
           return false;
       }
 
       return true;
     }
 
     @Override
     public int hashCode() {
       return 0;
     }
 
     public int compareTo(remove_args other) {
       if (!getClass().equals(other.getClass())) {
         return getClass().getName().compareTo(other.getClass().getName());
       }
 
       int lastComparison = 0;
       remove_args typedOther = (remove_args)other;
 
       lastComparison = Boolean.valueOf(isSetKeyspace()).compareTo(typedOther.isSetKeyspace());
       if (lastComparison != 0) {
         return lastComparison;
       }
       if (isSetKeyspace()) {        lastComparison = TBaseHelper.compareTo(keyspace, typedOther.keyspace);
         if (lastComparison != 0) {
           return lastComparison;
         }
       }
       lastComparison = Boolean.valueOf(isSetKey()).compareTo(typedOther.isSetKey());
       if (lastComparison != 0) {
         return lastComparison;
       }
       if (isSetKey()) {        lastComparison = TBaseHelper.compareTo(key, typedOther.key);
         if (lastComparison != 0) {
           return lastComparison;
         }
       }
       lastComparison = Boolean.valueOf(isSetColumn_path()).compareTo(typedOther.isSetColumn_path());
       if (lastComparison != 0) {
         return lastComparison;
       }
       if (isSetColumn_path()) {        lastComparison = TBaseHelper.compareTo(column_path, typedOther.column_path);
         if (lastComparison != 0) {
           return lastComparison;
         }
       }
       lastComparison = Boolean.valueOf(isSetTimestamp()).compareTo(typedOther.isSetTimestamp());
       if (lastComparison != 0) {
         return lastComparison;
       }
       if (isSetTimestamp()) {        lastComparison = TBaseHelper.compareTo(timestamp, typedOther.timestamp);
         if (lastComparison != 0) {
           return lastComparison;
         }
       }
       lastComparison = Boolean.valueOf(isSetConsistency_level()).compareTo(typedOther.isSetConsistency_level());
       if (lastComparison != 0) {
         return lastComparison;
       }
       if (isSetConsistency_level()) {        lastComparison = TBaseHelper.compareTo(consistency_level, typedOther.consistency_level);
         if (lastComparison != 0) {
           return lastComparison;
         }
       }
       return 0;
     }
 
     public void read(TProtocol iprot) throws TException {
       TField field;
       iprot.readStructBegin();
       while (true)
       {
         field = iprot.readFieldBegin();
         if (field.type == TType.STOP) { 
           break;
         }
         switch (field.id) {
           case 1: // KEYSPACE
             if (field.type == TType.STRING) {
               this.keyspace = iprot.readString();
             } else { 
               TProtocolUtil.skip(iprot, field.type);
             }
             break;
           case 2: // KEY
             if (field.type == TType.STRING) {
               this.key = iprot.readBinary();
             } else { 
               TProtocolUtil.skip(iprot, field.type);
             }
             break;
           case 3: // COLUMN_PATH
             if (field.type == TType.STRUCT) {
               this.column_path = new ColumnPath();
               this.column_path.read(iprot);
             } else { 
               TProtocolUtil.skip(iprot, field.type);
             }
             break;
           case 4: // TIMESTAMP
             if (field.type == TType.I64) {
               this.timestamp = iprot.readI64();
               setTimestampIsSet(true);
             } else { 
               TProtocolUtil.skip(iprot, field.type);
             }
             break;
           case 5: // CONSISTENCY_LEVEL
             if (field.type == TType.I32) {
               this.consistency_level = ConsistencyLevel.findByValue(iprot.readI32());
             } else { 
               TProtocolUtil.skip(iprot, field.type);
             }
             break;
           default:
             TProtocolUtil.skip(iprot, field.type);
         }
         iprot.readFieldEnd();
       }
       iprot.readStructEnd();
 
       // check for required fields of primitive type, which can't be checked in the validate method
       if (!isSetTimestamp()) {
         throw new TProtocolException("Required field 'timestamp' was not found in serialized data! Struct: " + toString());
       }
       validate();
     }
 
     public void write(TProtocol oprot) throws TException {
       validate();
 
       oprot.writeStructBegin(STRUCT_DESC);
       if (this.keyspace != null) {
         oprot.writeFieldBegin(KEYSPACE_FIELD_DESC);
         oprot.writeString(this.keyspace);
         oprot.writeFieldEnd();
       }
       if (this.key != null) {
         oprot.writeFieldBegin(KEY_FIELD_DESC);
         oprot.writeBinary(this.key);
         oprot.writeFieldEnd();
       }
       if (this.column_path != null) {
         oprot.writeFieldBegin(COLUMN_PATH_FIELD_DESC);
         this.column_path.write(oprot);
         oprot.writeFieldEnd();
       }
       oprot.writeFieldBegin(TIMESTAMP_FIELD_DESC);
       oprot.writeI64(this.timestamp);
       oprot.writeFieldEnd();
       if (this.consistency_level != null) {
         oprot.writeFieldBegin(CONSISTENCY_LEVEL_FIELD_DESC);
         oprot.writeI32(this.consistency_level.getValue());
         oprot.writeFieldEnd();
       }
       oprot.writeFieldStop();
       oprot.writeStructEnd();
     }
 
     @Override
     public String toString() {
       StringBuilder sb = new StringBuilder("remove_args(");
       boolean first = true;
 
       sb.append("keyspace:");
       if (this.keyspace == null) {
         sb.append("null");
       } else {
         sb.append(this.keyspace);
       }
       first = false;
       if (!first) sb.append(", ");
       sb.append("key:");
       if (this.key == null) {
         sb.append("null");
       } else {
           int __key_size = Math.min(this.key.length, 128);
           for (int i = 0; i < __key_size; i++) {
             if (i != 0) sb.append(" ");
             sb.append(Integer.toHexString(this.key[i]).length() > 1 ? Integer.toHexString(this.key[i]).substring(Integer.toHexString(this.key[i]).length() - 2).toUpperCase() : "0" + Integer.toHexString(this.key[i]).toUpperCase());
           }
           if (this.key.length > 128) sb.append(" ...");
       }
       first = false;
       if (!first) sb.append(", ");
       sb.append("column_path:");
       if (this.column_path == null) {
         sb.append("null");
       } else {
         sb.append(this.column_path);
       }
       first = false;
       if (!first) sb.append(", ");
       sb.append("timestamp:");
       sb.append(this.timestamp);
       first = false;
       if (!first) sb.append(", ");
       sb.append("consistency_level:");
       if (this.consistency_level == null) {
         sb.append("null");
       } else {
         sb.append(this.consistency_level);
       }
       first = false;
       sb.append(")");
       return sb.toString();
     }
 
     public void validate() throws TException {
       // check for required fields
       if (keyspace == null) {
         throw new TProtocolException("Required field 'keyspace' was not present! Struct: " + toString());
       }
       if (key == null) {
         throw new TProtocolException("Required field 'key' was not present! Struct: " + toString());
       }
       if (column_path == null) {
         throw new TProtocolException("Required field 'column_path' was not present! Struct: " + toString());
       }
       // alas, we cannot check 'timestamp' because it's a primitive and you chose the non-beans generator.
     }
 
   }
 
   public static class remove_result implements TBase<remove_result._Fields>, java.io.Serializable, Cloneable, Comparable<remove_result>   {
     private static final TStruct STRUCT_DESC = new TStruct("remove_result");
 
     private static final TField IRE_FIELD_DESC = new TField("ire", TType.STRUCT, (short)1);
     private static final TField UE_FIELD_DESC = new TField("ue", TType.STRUCT, (short)2);
     private static final TField TE_FIELD_DESC = new TField("te", TType.STRUCT, (short)3);
 
     public InvalidRequestException ire;
     public UnavailableException ue;
     public TimedOutException te;
 
     /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
     public enum _Fields implements TFieldIdEnum {
       IRE((short)1, "ire"),
       UE((short)2, "ue"),
       TE((short)3, "te");
 
       private static final Map<Integer, _Fields> byId = new HashMap<Integer, _Fields>();
       private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();
 
       static {
         for (_Fields field : EnumSet.allOf(_Fields.class)) {
           byId.put((int)field._thriftId, field);
           byName.put(field.getFieldName(), field);
         }
       }
 
       /**
        * Find the _Fields constant that matches fieldId, or null if its not found.
        */
       public static _Fields findByThriftId(int fieldId) {
         return byId.get(fieldId);
       }
 
       /**
        * Find the _Fields constant that matches fieldId, throwing an exception
        * if it is not found.
        */
       public static _Fields findByThriftIdOrThrow(int fieldId) {
         _Fields fields = findByThriftId(fieldId);
         if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
         return fields;
       }
 
       /**
        * Find the _Fields constant that matches name, or null if its not found.
        */
       public static _Fields findByName(String name) {
         return byName.get(name);
       }
 
       private final short _thriftId;
       private final String _fieldName;
 
       _Fields(short thriftId, String fieldName) {
         _thriftId = thriftId;
         _fieldName = fieldName;
       }
 
       public short getThriftFieldId() {
         return _thriftId;
       }
 
       public String getFieldName() {
         return _fieldName;
       }
     }
 
     // isset id assignments
 
     public static final Map<_Fields, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new EnumMap<_Fields, FieldMetaData>(_Fields.class) {{
       put(_Fields.IRE, new FieldMetaData("ire", TFieldRequirementType.DEFAULT, 
           new FieldValueMetaData(TType.STRUCT)));
       put(_Fields.UE, new FieldMetaData("ue", TFieldRequirementType.DEFAULT, 
           new FieldValueMetaData(TType.STRUCT)));
       put(_Fields.TE, new FieldMetaData("te", TFieldRequirementType.DEFAULT, 
           new FieldValueMetaData(TType.STRUCT)));
     }});
 
     static {
       FieldMetaData.addStructMetaDataMap(remove_result.class, metaDataMap);
     }
 
     public remove_result() {
     }
 
     public remove_result(
       InvalidRequestException ire,
       UnavailableException ue,
       TimedOutException te)
     {
       this();
       this.ire = ire;
       this.ue = ue;
       this.te = te;
     }
 
     /**
      * Performs a deep copy on <i>other</i>.
      */
     public remove_result(remove_result other) {
       if (other.isSetIre()) {
         this.ire = new InvalidRequestException(other.ire);
       }
       if (other.isSetUe()) {
         this.ue = new UnavailableException(other.ue);
       }
       if (other.isSetTe()) {
         this.te = new TimedOutException(other.te);
       }
     }
 
     public remove_result deepCopy() {
       return new remove_result(this);
     }
 
     @Deprecated
     public remove_result clone() {
       return new remove_result(this);
     }
 
     public InvalidRequestException getIre() {
       return this.ire;
     }
 
     public remove_result setIre(InvalidRequestException ire) {
       this.ire = ire;
       return this;
     }
 
     public void unsetIre() {
       this.ire = null;
     }
 
     /** Returns true if field ire is set (has been asigned a value) and false otherwise */
     public boolean isSetIre() {
       return this.ire != null;
     }
 
     public void setIreIsSet(boolean value) {
       if (!value) {
         this.ire = null;
       }
     }
 
     public UnavailableException getUe() {
       return this.ue;
     }
 
     public remove_result setUe(UnavailableException ue) {
       this.ue = ue;
       return this;
     }
 
     public void unsetUe() {
       this.ue = null;
     }
 
     /** Returns true if field ue is set (has been asigned a value) and false otherwise */
     public boolean isSetUe() {
       return this.ue != null;
     }
 
     public void setUeIsSet(boolean value) {
       if (!value) {
         this.ue = null;
       }
     }
 
     public TimedOutException getTe() {
       return this.te;
     }
 
     public remove_result setTe(TimedOutException te) {
       this.te = te;
       return this;
     }
 
     public void unsetTe() {
       this.te = null;
     }
 
     /** Returns true if field te is set (has been asigned a value) and false otherwise */
     public boolean isSetTe() {
       return this.te != null;
     }
 
     public void setTeIsSet(boolean value) {
       if (!value) {
         this.te = null;
       }
     }
 
     public void setFieldValue(_Fields field, Object value) {
       switch (field) {
       case IRE:
         if (value == null) {
           unsetIre();
         } else {
           setIre((InvalidRequestException)value);
         }
         break;
 
       case UE:
         if (value == null) {
           unsetUe();
         } else {
           setUe((UnavailableException)value);
         }
         break;
 
       case TE:
         if (value == null) {
           unsetTe();
         } else {
           setTe((TimedOutException)value);
         }
         break;
 
       }
     }
 
     public void setFieldValue(int fieldID, Object value) {
       setFieldValue(_Fields.findByThriftIdOrThrow(fieldID), value);
     }
 
     public Object getFieldValue(_Fields field) {
       switch (field) {
       case IRE:
         return getIre();
 
       case UE:
         return getUe();
 
       case TE:
         return getTe();
 
       }
       throw new IllegalStateException();
     }
 
     public Object getFieldValue(int fieldId) {
       return getFieldValue(_Fields.findByThriftIdOrThrow(fieldId));
     }
 
     /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
     public boolean isSet(_Fields field) {
       switch (field) {
       case IRE:
         return isSetIre();
       case UE:
         return isSetUe();
       case TE:
         return isSetTe();
       }
       throw new IllegalStateException();
     }
 
     public boolean isSet(int fieldID) {
       return isSet(_Fields.findByThriftIdOrThrow(fieldID));
     }
 
     @Override
     public boolean equals(Object that) {
       if (that == null)
         return false;
       if (that instanceof remove_result)
         return this.equals((remove_result)that);
       return false;
     }
 
     public boolean equals(remove_result that) {
       if (that == null)
         return false;
 
       boolean this_present_ire = true && this.isSetIre();
       boolean that_present_ire = true && that.isSetIre();
       if (this_present_ire || that_present_ire) {
         if (!(this_present_ire && that_present_ire))
           return false;
         if (!this.ire.equals(that.ire))
           return false;
       }
 
       boolean this_present_ue = true && this.isSetUe();
       boolean that_present_ue = true && that.isSetUe();
       if (this_present_ue || that_present_ue) {
         if (!(this_present_ue && that_present_ue))
           return false;
         if (!this.ue.equals(that.ue))
           return false;
       }
 
       boolean this_present_te = true && this.isSetTe();
       boolean that_present_te = true && that.isSetTe();
       if (this_present_te || that_present_te) {
         if (!(this_present_te && that_present_te))
           return false;
         if (!this.te.equals(that.te))
           return false;
       }
 
       return true;
     }
 
     @Override
     public int hashCode() {
       return 0;
     }
 
     public int compareTo(remove_result other) {
       if (!getClass().equals(other.getClass())) {
         return getClass().getName().compareTo(other.getClass().getName());
       }
 
       int lastComparison = 0;
       remove_result typedOther = (remove_result)other;
 
       lastComparison = Boolean.valueOf(isSetIre()).compareTo(typedOther.isSetIre());
       if (lastComparison != 0) {
         return lastComparison;
       }
       if (isSetIre()) {        lastComparison = TBaseHelper.compareTo(ire, typedOther.ire);
         if (lastComparison != 0) {
           return lastComparison;
         }
       }
       lastComparison = Boolean.valueOf(isSetUe()).compareTo(typedOther.isSetUe());
       if (lastComparison != 0) {
         return lastComparison;
       }
       if (isSetUe()) {        lastComparison = TBaseHelper.compareTo(ue, typedOther.ue);
         if (lastComparison != 0) {
           return lastComparison;
         }
       }
       lastComparison = Boolean.valueOf(isSetTe()).compareTo(typedOther.isSetTe());
       if (lastComparison != 0) {
         return lastComparison;
       }
       if (isSetTe()) {        lastComparison = TBaseHelper.compareTo(te, typedOther.te);
         if (lastComparison != 0) {
           return lastComparison;
         }
       }
       return 0;
     }
 
     public void read(TProtocol iprot) throws TException {
       TField field;
       iprot.readStructBegin();
       while (true)
       {
         field = iprot.readFieldBegin();
         if (field.type == TType.STOP) { 
           break;
         }
         switch (field.id) {
           case 1: // IRE
             if (field.type == TType.STRUCT) {
               this.ire = new InvalidRequestException();
               this.ire.read(iprot);
             } else { 
               TProtocolUtil.skip(iprot, field.type);
             }
             break;
           case 2: // UE
             if (field.type == TType.STRUCT) {
               this.ue = new UnavailableException();
               this.ue.read(iprot);
             } else { 
               TProtocolUtil.skip(iprot, field.type);
             }
             break;
           case 3: // TE
             if (field.type == TType.STRUCT) {
               this.te = new TimedOutException();
               this.te.read(iprot);
             } else { 
               TProtocolUtil.skip(iprot, field.type);
             }
             break;
           default:
             TProtocolUtil.skip(iprot, field.type);
         }
         iprot.readFieldEnd();
       }
       iprot.readStructEnd();
 
       // check for required fields of primitive type, which can't be checked in the validate method
       validate();
     }
 
     public void write(TProtocol oprot) throws TException {
       oprot.writeStructBegin(STRUCT_DESC);
 
       if (this.isSetIre()) {
         oprot.writeFieldBegin(IRE_FIELD_DESC);
         this.ire.write(oprot);
         oprot.writeFieldEnd();
       } else if (this.isSetUe()) {
         oprot.writeFieldBegin(UE_FIELD_DESC);
         this.ue.write(oprot);
         oprot.writeFieldEnd();
       } else if (this.isSetTe()) {
         oprot.writeFieldBegin(TE_FIELD_DESC);
         this.te.write(oprot);
         oprot.writeFieldEnd();
       }
       oprot.writeFieldStop();
       oprot.writeStructEnd();
     }
 
     @Override
     public String toString() {
       StringBuilder sb = new StringBuilder("remove_result(");
       boolean first = true;
 
       sb.append("ire:");
       if (this.ire == null) {
         sb.append("null");
       } else {
         sb.append(this.ire);
       }
       first = false;
       if (!first) sb.append(", ");
       sb.append("ue:");
       if (this.ue == null) {
         sb.append("null");
       } else {
         sb.append(this.ue);
       }
       first = false;
       if (!first) sb.append(", ");
       sb.append("te:");
       if (this.te == null) {
         sb.append("null");
       } else {
         sb.append(this.te);
       }
       first = false;
       sb.append(")");
       return sb.toString();
     }
 
     public void validate() throws TException {
       // check for required fields
     }
 
   }
 
   public static class batch_mutate_args implements TBase<batch_mutate_args._Fields>, java.io.Serializable, Cloneable   {
     private static final TStruct STRUCT_DESC = new TStruct("batch_mutate_args");
 
     private static final TField KEYSPACE_FIELD_DESC = new TField("keyspace", TType.STRING, (short)1);
     private static final TField MUTATION_MAP_FIELD_DESC = new TField("mutation_map", TType.MAP, (short)2);
     private static final TField CONSISTENCY_LEVEL_FIELD_DESC = new TField("consistency_level", TType.I32, (short)3);
 
     public String keyspace;
     public Map<byte[],Map<String,List<Mutation>>> mutation_map;
     /**
      * 
      * @see ConsistencyLevel
      */
     public ConsistencyLevel consistency_level;
 
     /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
     public enum _Fields implements TFieldIdEnum {
       KEYSPACE((short)1, "keyspace"),
       MUTATION_MAP((short)2, "mutation_map"),
       /**
        * 
        * @see ConsistencyLevel
        */
       CONSISTENCY_LEVEL((short)3, "consistency_level");
 
       private static final Map<Integer, _Fields> byId = new HashMap<Integer, _Fields>();
       private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();
 
       static {
         for (_Fields field : EnumSet.allOf(_Fields.class)) {
           byId.put((int)field._thriftId, field);
           byName.put(field.getFieldName(), field);
         }
       }
 
       /**
        * Find the _Fields constant that matches fieldId, or null if its not found.
        */
       public static _Fields findByThriftId(int fieldId) {
         return byId.get(fieldId);
       }
 
       /**
        * Find the _Fields constant that matches fieldId, throwing an exception
        * if it is not found.
        */
       public static _Fields findByThriftIdOrThrow(int fieldId) {
         _Fields fields = findByThriftId(fieldId);
         if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
         return fields;
       }
 
       /**
        * Find the _Fields constant that matches name, or null if its not found.
        */
       public static _Fields findByName(String name) {
         return byName.get(name);
       }
 
       private final short _thriftId;
       private final String _fieldName;
 
       _Fields(short thriftId, String fieldName) {
         _thriftId = thriftId;
         _fieldName = fieldName;
       }
 
       public short getThriftFieldId() {
         return _thriftId;
       }
 
       public String getFieldName() {
         return _fieldName;
       }
     }
 
     // isset id assignments
 
     public static final Map<_Fields, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new EnumMap<_Fields, FieldMetaData>(_Fields.class) {{
       put(_Fields.KEYSPACE, new FieldMetaData("keyspace", TFieldRequirementType.REQUIRED, 
           new FieldValueMetaData(TType.STRING)));
       put(_Fields.MUTATION_MAP, new FieldMetaData("mutation_map", TFieldRequirementType.REQUIRED, 
           new MapMetaData(TType.MAP, 
               new FieldValueMetaData(TType.STRING), 
               new MapMetaData(TType.MAP, 
                   new FieldValueMetaData(TType.STRING), 
                   new ListMetaData(TType.LIST, 
                       new StructMetaData(TType.STRUCT, Mutation.class))))));
       put(_Fields.CONSISTENCY_LEVEL, new FieldMetaData("consistency_level", TFieldRequirementType.REQUIRED, 
           new EnumMetaData(TType.ENUM, ConsistencyLevel.class)));
     }});
 
     static {
       FieldMetaData.addStructMetaDataMap(batch_mutate_args.class, metaDataMap);
     }
 
     public batch_mutate_args() {
       this.consistency_level = ConsistencyLevel.ONE;
 
     }
 
     public batch_mutate_args(
       String keyspace,
       Map<byte[],Map<String,List<Mutation>>> mutation_map,
       ConsistencyLevel consistency_level)
     {
       this();
       this.keyspace = keyspace;
       this.mutation_map = mutation_map;
       this.consistency_level = consistency_level;
     }
 
     /**
      * Performs a deep copy on <i>other</i>.
      */
     public batch_mutate_args(batch_mutate_args other) {
       if (other.isSetKeyspace()) {
         this.keyspace = other.keyspace;
       }
       if (other.isSetMutation_map()) {
         Map<byte[],Map<String,List<Mutation>>> __this__mutation_map = new HashMap<byte[],Map<String,List<Mutation>>>();
         for (Map.Entry<byte[], Map<String,List<Mutation>>> other_element : other.mutation_map.entrySet()) {
 
           byte[] other_element_key = other_element.getKey();
           Map<String,List<Mutation>> other_element_value = other_element.getValue();
 
           byte[] __this__mutation_map_copy_key = new byte[other_element_key.length];
           System.arraycopy(other_element_key, 0, __this__mutation_map_copy_key, 0, other_element_key.length);
 
           Map<String,List<Mutation>> __this__mutation_map_copy_value = new HashMap<String,List<Mutation>>();
           for (Map.Entry<String, List<Mutation>> other_element_value_element : other_element_value.entrySet()) {
 
             String other_element_value_element_key = other_element_value_element.getKey();
             List<Mutation> other_element_value_element_value = other_element_value_element.getValue();
 
             String __this__mutation_map_copy_value_copy_key = other_element_value_element_key;
 
             List<Mutation> __this__mutation_map_copy_value_copy_value = new ArrayList<Mutation>();
             for (Mutation other_element_value_element_value_element : other_element_value_element_value) {
               __this__mutation_map_copy_value_copy_value.add(new Mutation(other_element_value_element_value_element));
             }
 
             __this__mutation_map_copy_value.put(__this__mutation_map_copy_value_copy_key, __this__mutation_map_copy_value_copy_value);
           }
 
           __this__mutation_map.put(__this__mutation_map_copy_key, __this__mutation_map_copy_value);
         }
         this.mutation_map = __this__mutation_map;
       }
       if (other.isSetConsistency_level()) {
         this.consistency_level = other.consistency_level;
       }
     }
 
     public batch_mutate_args deepCopy() {
       return new batch_mutate_args(this);
     }
 
     @Deprecated
     public batch_mutate_args clone() {
       return new batch_mutate_args(this);
     }
 
     public String getKeyspace() {
       return this.keyspace;
     }
 
     public batch_mutate_args setKeyspace(String keyspace) {
       this.keyspace = keyspace;
       return this;
     }
 
     public void unsetKeyspace() {
       this.keyspace = null;
     }
 
     /** Returns true if field keyspace is set (has been asigned a value) and false otherwise */
     public boolean isSetKeyspace() {
       return this.keyspace != null;
     }
 
     public void setKeyspaceIsSet(boolean value) {
       if (!value) {
         this.keyspace = null;
       }
     }
 
     public int getMutation_mapSize() {
       return (this.mutation_map == null) ? 0 : this.mutation_map.size();
     }
 
     public void putToMutation_map(byte[] key, Map<String,List<Mutation>> val) {
       if (this.mutation_map == null) {
         this.mutation_map = new HashMap<byte[],Map<String,List<Mutation>>>();
       }
       this.mutation_map.put(key, val);
     }
 
     public Map<byte[],Map<String,List<Mutation>>> getMutation_map() {
       return this.mutation_map;
     }
 
     public batch_mutate_args setMutation_map(Map<byte[],Map<String,List<Mutation>>> mutation_map) {
       this.mutation_map = mutation_map;
       return this;
     }
 
     public void unsetMutation_map() {
       this.mutation_map = null;
     }
 
     /** Returns true if field mutation_map is set (has been asigned a value) and false otherwise */
     public boolean isSetMutation_map() {
       return this.mutation_map != null;
     }
 
     public void setMutation_mapIsSet(boolean value) {
       if (!value) {
         this.mutation_map = null;
       }
     }
 
     /**
      * 
      * @see ConsistencyLevel
      */
     public ConsistencyLevel getConsistency_level() {
       return this.consistency_level;
     }
 
     /**
      * 
      * @see ConsistencyLevel
      */
     public batch_mutate_args setConsistency_level(ConsistencyLevel consistency_level) {
       this.consistency_level = consistency_level;
       return this;
     }
 
     public void unsetConsistency_level() {
       this.consistency_level = null;
     }
 
     /** Returns true if field consistency_level is set (has been asigned a value) and false otherwise */
     public boolean isSetConsistency_level() {
       return this.consistency_level != null;
     }
 
     public void setConsistency_levelIsSet(boolean value) {
       if (!value) {
         this.consistency_level = null;
       }
     }
 
     public void setFieldValue(_Fields field, Object value) {
       switch (field) {
       case KEYSPACE:
         if (value == null) {
           unsetKeyspace();
         } else {
           setKeyspace((String)value);
         }
         break;
 
       case MUTATION_MAP:
         if (value == null) {
           unsetMutation_map();
         } else {
           setMutation_map((Map<byte[],Map<String,List<Mutation>>>)value);
         }
         break;
 
       case CONSISTENCY_LEVEL:
         if (value == null) {
           unsetConsistency_level();
         } else {
           setConsistency_level((ConsistencyLevel)value);
         }
         break;
 
       }
     }
 
     public void setFieldValue(int fieldID, Object value) {
       setFieldValue(_Fields.findByThriftIdOrThrow(fieldID), value);
     }
 
     public Object getFieldValue(_Fields field) {
       switch (field) {
       case KEYSPACE:
         return getKeyspace();
 
       case MUTATION_MAP:
         return getMutation_map();
 
       case CONSISTENCY_LEVEL:
         return getConsistency_level();
 
       }
       throw new IllegalStateException();
     }
 
     public Object getFieldValue(int fieldId) {
       return getFieldValue(_Fields.findByThriftIdOrThrow(fieldId));
     }
 
     /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
     public boolean isSet(_Fields field) {
       switch (field) {
       case KEYSPACE:
         return isSetKeyspace();
       case MUTATION_MAP:
         return isSetMutation_map();
       case CONSISTENCY_LEVEL:
         return isSetConsistency_level();
       }
       throw new IllegalStateException();
     }
 
     public boolean isSet(int fieldID) {
       return isSet(_Fields.findByThriftIdOrThrow(fieldID));
     }
 
     @Override
     public boolean equals(Object that) {
       if (that == null)
         return false;
       if (that instanceof batch_mutate_args)
         return this.equals((batch_mutate_args)that);
       return false;
     }
 
     public boolean equals(batch_mutate_args that) {
       if (that == null)
         return false;
 
       boolean this_present_keyspace = true && this.isSetKeyspace();
       boolean that_present_keyspace = true && that.isSetKeyspace();
       if (this_present_keyspace || that_present_keyspace) {
         if (!(this_present_keyspace && that_present_keyspace))
           return false;
         if (!this.keyspace.equals(that.keyspace))
           return false;
       }
 
       boolean this_present_mutation_map = true && this.isSetMutation_map();
       boolean that_present_mutation_map = true && that.isSetMutation_map();
       if (this_present_mutation_map || that_present_mutation_map) {
         if (!(this_present_mutation_map && that_present_mutation_map))
           return false;
         if (!this.mutation_map.equals(that.mutation_map))
           return false;
       }
 
       boolean this_present_consistency_level = true && this.isSetConsistency_level();
       boolean that_present_consistency_level = true && that.isSetConsistency_level();
       if (this_present_consistency_level || that_present_consistency_level) {
         if (!(this_present_consistency_level && that_present_consistency_level))
           return false;
         if (!this.consistency_level.equals(that.consistency_level))
           return false;
       }
 
       return true;
     }
 
     @Override
     public int hashCode() {
       return 0;
     }
 
     public void read(TProtocol iprot) throws TException {
       TField field;
       iprot.readStructBegin();
       while (true)
       {
         field = iprot.readFieldBegin();
         if (field.type == TType.STOP) { 
           break;
         }
         switch (field.id) {
           case 1: // KEYSPACE
             if (field.type == TType.STRING) {
               this.keyspace = iprot.readString();
             } else { 
               TProtocolUtil.skip(iprot, field.type);
             }
             break;
           case 2: // MUTATION_MAP
             if (field.type == TType.MAP) {
               {
                TMap _map81 = iprot.readMapBegin();
                this.mutation_map = new HashMap<byte[],Map<String,List<Mutation>>>(2*_map81.size);
                for (int _i82 = 0; _i82 < _map81.size; ++_i82)
                {
                  byte[] _key83;
                  Map<String,List<Mutation>> _val84;
                  _key83 = iprot.readBinary();
                  {
                    TMap _map85 = iprot.readMapBegin();
                    _val84 = new HashMap<String,List<Mutation>>(2*_map85.size);
                    for (int _i86 = 0; _i86 < _map85.size; ++_i86)
                    {
                      String _key87;
                      List<Mutation> _val88;
                      _key87 = iprot.readString();
                      {
                        TList _list89 = iprot.readListBegin();
                        _val88 = new ArrayList<Mutation>(_list89.size);
                        for (int _i90 = 0; _i90 < _list89.size; ++_i90)
                        {
                          Mutation _elem91;
                          _elem91 = new Mutation();
                          _elem91.read(iprot);
                          _val88.add(_elem91);
                         }
                         iprot.readListEnd();
                       }
                      _val84.put(_key87, _val88);
                     }
                     iprot.readMapEnd();
                   }
                  this.mutation_map.put(_key83, _val84);
                 }
                 iprot.readMapEnd();
               }
             } else { 
               TProtocolUtil.skip(iprot, field.type);
             }
             break;
           case 3: // CONSISTENCY_LEVEL
             if (field.type == TType.I32) {
               this.consistency_level = ConsistencyLevel.findByValue(iprot.readI32());
             } else { 
               TProtocolUtil.skip(iprot, field.type);
             }
             break;
           default:
             TProtocolUtil.skip(iprot, field.type);
         }
         iprot.readFieldEnd();
       }
       iprot.readStructEnd();
 
       // check for required fields of primitive type, which can't be checked in the validate method
       validate();
     }
 
     public void write(TProtocol oprot) throws TException {
       validate();
 
       oprot.writeStructBegin(STRUCT_DESC);
       if (this.keyspace != null) {
         oprot.writeFieldBegin(KEYSPACE_FIELD_DESC);
         oprot.writeString(this.keyspace);
         oprot.writeFieldEnd();
       }
       if (this.mutation_map != null) {
         oprot.writeFieldBegin(MUTATION_MAP_FIELD_DESC);
         {
           oprot.writeMapBegin(new TMap(TType.STRING, TType.MAP, this.mutation_map.size()));
          for (Map.Entry<byte[], Map<String,List<Mutation>>> _iter92 : this.mutation_map.entrySet())
           {
            oprot.writeBinary(_iter92.getKey());
             {
              oprot.writeMapBegin(new TMap(TType.STRING, TType.LIST, _iter92.getValue().size()));
              for (Map.Entry<String, List<Mutation>> _iter93 : _iter92.getValue().entrySet())
               {
                oprot.writeString(_iter93.getKey());
                 {
                  oprot.writeListBegin(new TList(TType.STRUCT, _iter93.getValue().size()));
                  for (Mutation _iter94 : _iter93.getValue())
                   {
                    _iter94.write(oprot);
                   }
                   oprot.writeListEnd();
                 }
               }
               oprot.writeMapEnd();
             }
           }
           oprot.writeMapEnd();
         }
         oprot.writeFieldEnd();
       }
       if (this.consistency_level != null) {
         oprot.writeFieldBegin(CONSISTENCY_LEVEL_FIELD_DESC);
         oprot.writeI32(this.consistency_level.getValue());
         oprot.writeFieldEnd();
       }
       oprot.writeFieldStop();
       oprot.writeStructEnd();
     }
 
     @Override
     public String toString() {
       StringBuilder sb = new StringBuilder("batch_mutate_args(");
       boolean first = true;
 
       sb.append("keyspace:");
       if (this.keyspace == null) {
         sb.append("null");
       } else {
         sb.append(this.keyspace);
       }
       first = false;
       if (!first) sb.append(", ");
       sb.append("mutation_map:");
       if (this.mutation_map == null) {
         sb.append("null");
       } else {
         sb.append(this.mutation_map);
       }
       first = false;
       if (!first) sb.append(", ");
       sb.append("consistency_level:");
       if (this.consistency_level == null) {
         sb.append("null");
       } else {
         sb.append(this.consistency_level);
       }
       first = false;
       sb.append(")");
       return sb.toString();
     }
 
     public void validate() throws TException {
       // check for required fields
       if (keyspace == null) {
         throw new TProtocolException("Required field 'keyspace' was not present! Struct: " + toString());
       }
       if (mutation_map == null) {
         throw new TProtocolException("Required field 'mutation_map' was not present! Struct: " + toString());
       }
       if (consistency_level == null) {
         throw new TProtocolException("Required field 'consistency_level' was not present! Struct: " + toString());
       }
     }
 
   }
 
   public static class batch_mutate_result implements TBase<batch_mutate_result._Fields>, java.io.Serializable, Cloneable, Comparable<batch_mutate_result>   {
     private static final TStruct STRUCT_DESC = new TStruct("batch_mutate_result");
 
     private static final TField IRE_FIELD_DESC = new TField("ire", TType.STRUCT, (short)1);
     private static final TField UE_FIELD_DESC = new TField("ue", TType.STRUCT, (short)2);
     private static final TField TE_FIELD_DESC = new TField("te", TType.STRUCT, (short)3);
 
     public InvalidRequestException ire;
     public UnavailableException ue;
     public TimedOutException te;
 
     /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
     public enum _Fields implements TFieldIdEnum {
       IRE((short)1, "ire"),
       UE((short)2, "ue"),
       TE((short)3, "te");
 
       private static final Map<Integer, _Fields> byId = new HashMap<Integer, _Fields>();
       private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();
 
       static {
         for (_Fields field : EnumSet.allOf(_Fields.class)) {
           byId.put((int)field._thriftId, field);
           byName.put(field.getFieldName(), field);
         }
       }
 
       /**
        * Find the _Fields constant that matches fieldId, or null if its not found.
        */
       public static _Fields findByThriftId(int fieldId) {
         return byId.get(fieldId);
       }
 
       /**
        * Find the _Fields constant that matches fieldId, throwing an exception
        * if it is not found.
        */
       public static _Fields findByThriftIdOrThrow(int fieldId) {
         _Fields fields = findByThriftId(fieldId);
         if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
         return fields;
       }
 
       /**
        * Find the _Fields constant that matches name, or null if its not found.
        */
       public static _Fields findByName(String name) {
         return byName.get(name);
       }
 
       private final short _thriftId;
       private final String _fieldName;
 
       _Fields(short thriftId, String fieldName) {
         _thriftId = thriftId;
         _fieldName = fieldName;
       }
 
       public short getThriftFieldId() {
         return _thriftId;
       }
 
       public String getFieldName() {
         return _fieldName;
       }
     }
 
     // isset id assignments
 
     public static final Map<_Fields, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new EnumMap<_Fields, FieldMetaData>(_Fields.class) {{
       put(_Fields.IRE, new FieldMetaData("ire", TFieldRequirementType.DEFAULT, 
           new FieldValueMetaData(TType.STRUCT)));
       put(_Fields.UE, new FieldMetaData("ue", TFieldRequirementType.DEFAULT, 
           new FieldValueMetaData(TType.STRUCT)));
       put(_Fields.TE, new FieldMetaData("te", TFieldRequirementType.DEFAULT, 
           new FieldValueMetaData(TType.STRUCT)));
     }});
 
     static {
       FieldMetaData.addStructMetaDataMap(batch_mutate_result.class, metaDataMap);
     }
 
     public batch_mutate_result() {
     }
 
     public batch_mutate_result(
       InvalidRequestException ire,
       UnavailableException ue,
       TimedOutException te)
     {
       this();
       this.ire = ire;
       this.ue = ue;
       this.te = te;
     }
 
     /**
      * Performs a deep copy on <i>other</i>.
      */
     public batch_mutate_result(batch_mutate_result other) {
       if (other.isSetIre()) {
         this.ire = new InvalidRequestException(other.ire);
       }
       if (other.isSetUe()) {
         this.ue = new UnavailableException(other.ue);
       }
       if (other.isSetTe()) {
         this.te = new TimedOutException(other.te);
       }
     }
 
     public batch_mutate_result deepCopy() {
       return new batch_mutate_result(this);
     }
 
     @Deprecated
     public batch_mutate_result clone() {
       return new batch_mutate_result(this);
     }
 
     public InvalidRequestException getIre() {
       return this.ire;
     }
 
     public batch_mutate_result setIre(InvalidRequestException ire) {
       this.ire = ire;
       return this;
     }
 
     public void unsetIre() {
       this.ire = null;
     }
 
     /** Returns true if field ire is set (has been asigned a value) and false otherwise */
     public boolean isSetIre() {
       return this.ire != null;
     }
 
     public void setIreIsSet(boolean value) {
       if (!value) {
         this.ire = null;
       }
     }
 
     public UnavailableException getUe() {
       return this.ue;
     }
 
     public batch_mutate_result setUe(UnavailableException ue) {
       this.ue = ue;
       return this;
     }
 
     public void unsetUe() {
       this.ue = null;
     }
 
     /** Returns true if field ue is set (has been asigned a value) and false otherwise */
     public boolean isSetUe() {
       return this.ue != null;
     }
 
     public void setUeIsSet(boolean value) {
       if (!value) {
         this.ue = null;
       }
     }
 
     public TimedOutException getTe() {
       return this.te;
     }
 
     public batch_mutate_result setTe(TimedOutException te) {
       this.te = te;
       return this;
     }
 
     public void unsetTe() {
       this.te = null;
     }
 
     /** Returns true if field te is set (has been asigned a value) and false otherwise */
     public boolean isSetTe() {
       return this.te != null;
     }
 
     public void setTeIsSet(boolean value) {
       if (!value) {
         this.te = null;
       }
     }
 
     public void setFieldValue(_Fields field, Object value) {
       switch (field) {
       case IRE:
         if (value == null) {
           unsetIre();
         } else {
           setIre((InvalidRequestException)value);
         }
         break;
 
       case UE:
         if (value == null) {
           unsetUe();
         } else {
           setUe((UnavailableException)value);
         }
         break;
 
       case TE:
         if (value == null) {
           unsetTe();
         } else {
           setTe((TimedOutException)value);
         }
         break;
 
       }
     }
 
     public void setFieldValue(int fieldID, Object value) {
       setFieldValue(_Fields.findByThriftIdOrThrow(fieldID), value);
     }
 
     public Object getFieldValue(_Fields field) {
       switch (field) {
       case IRE:
         return getIre();
 
       case UE:
         return getUe();
 
       case TE:
         return getTe();
 
       }
       throw new IllegalStateException();
     }
 
     public Object getFieldValue(int fieldId) {
       return getFieldValue(_Fields.findByThriftIdOrThrow(fieldId));
     }
 
     /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
     public boolean isSet(_Fields field) {
       switch (field) {
       case IRE:
         return isSetIre();
       case UE:
         return isSetUe();
       case TE:
         return isSetTe();
       }
       throw new IllegalStateException();
     }
 
     public boolean isSet(int fieldID) {
       return isSet(_Fields.findByThriftIdOrThrow(fieldID));
     }
 
     @Override
     public boolean equals(Object that) {
       if (that == null)
         return false;
       if (that instanceof batch_mutate_result)
         return this.equals((batch_mutate_result)that);
       return false;
     }
 
     public boolean equals(batch_mutate_result that) {
       if (that == null)
         return false;
 
       boolean this_present_ire = true && this.isSetIre();
       boolean that_present_ire = true && that.isSetIre();
       if (this_present_ire || that_present_ire) {
         if (!(this_present_ire && that_present_ire))
           return false;
         if (!this.ire.equals(that.ire))
           return false;
       }
 
       boolean this_present_ue = true && this.isSetUe();
       boolean that_present_ue = true && that.isSetUe();
       if (this_present_ue || that_present_ue) {
         if (!(this_present_ue && that_present_ue))
           return false;
         if (!this.ue.equals(that.ue))
           return false;
       }
 
       boolean this_present_te = true && this.isSetTe();
       boolean that_present_te = true && that.isSetTe();
       if (this_present_te || that_present_te) {
         if (!(this_present_te && that_present_te))
           return false;
         if (!this.te.equals(that.te))
           return false;
       }
 
       return true;
     }
 
     @Override
     public int hashCode() {
       return 0;
     }
 
     public int compareTo(batch_mutate_result other) {
       if (!getClass().equals(other.getClass())) {
         return getClass().getName().compareTo(other.getClass().getName());
       }
 
       int lastComparison = 0;
       batch_mutate_result typedOther = (batch_mutate_result)other;
 
       lastComparison = Boolean.valueOf(isSetIre()).compareTo(typedOther.isSetIre());
       if (lastComparison != 0) {
         return lastComparison;
       }
       if (isSetIre()) {        lastComparison = TBaseHelper.compareTo(ire, typedOther.ire);
         if (lastComparison != 0) {
           return lastComparison;
         }
       }
       lastComparison = Boolean.valueOf(isSetUe()).compareTo(typedOther.isSetUe());
       if (lastComparison != 0) {
         return lastComparison;
       }
       if (isSetUe()) {        lastComparison = TBaseHelper.compareTo(ue, typedOther.ue);
         if (lastComparison != 0) {
           return lastComparison;
         }
       }
       lastComparison = Boolean.valueOf(isSetTe()).compareTo(typedOther.isSetTe());
       if (lastComparison != 0) {
         return lastComparison;
       }
       if (isSetTe()) {        lastComparison = TBaseHelper.compareTo(te, typedOther.te);
         if (lastComparison != 0) {
           return lastComparison;
         }
       }
       return 0;
     }
 
     public void read(TProtocol iprot) throws TException {
       TField field;
       iprot.readStructBegin();
       while (true)
       {
         field = iprot.readFieldBegin();
         if (field.type == TType.STOP) { 
           break;
         }
         switch (field.id) {
           case 1: // IRE
             if (field.type == TType.STRUCT) {
               this.ire = new InvalidRequestException();
               this.ire.read(iprot);
             } else { 
               TProtocolUtil.skip(iprot, field.type);
             }
             break;
           case 2: // UE
             if (field.type == TType.STRUCT) {
               this.ue = new UnavailableException();
               this.ue.read(iprot);
             } else { 
               TProtocolUtil.skip(iprot, field.type);
             }
             break;
           case 3: // TE
             if (field.type == TType.STRUCT) {
               this.te = new TimedOutException();
               this.te.read(iprot);
             } else { 
               TProtocolUtil.skip(iprot, field.type);
             }
             break;
           default:
             TProtocolUtil.skip(iprot, field.type);
         }
         iprot.readFieldEnd();
       }
       iprot.readStructEnd();
 
       // check for required fields of primitive type, which can't be checked in the validate method
       validate();
     }
 
     public void write(TProtocol oprot) throws TException {
       oprot.writeStructBegin(STRUCT_DESC);
 
       if (this.isSetIre()) {
         oprot.writeFieldBegin(IRE_FIELD_DESC);
         this.ire.write(oprot);
         oprot.writeFieldEnd();
       } else if (this.isSetUe()) {
         oprot.writeFieldBegin(UE_FIELD_DESC);
         this.ue.write(oprot);
         oprot.writeFieldEnd();
       } else if (this.isSetTe()) {
         oprot.writeFieldBegin(TE_FIELD_DESC);
         this.te.write(oprot);
         oprot.writeFieldEnd();
       }
       oprot.writeFieldStop();
       oprot.writeStructEnd();
     }
 
     @Override
     public String toString() {
       StringBuilder sb = new StringBuilder("batch_mutate_result(");
       boolean first = true;
 
       sb.append("ire:");
       if (this.ire == null) {
         sb.append("null");
       } else {
         sb.append(this.ire);
       }
       first = false;
       if (!first) sb.append(", ");
       sb.append("ue:");
       if (this.ue == null) {
         sb.append("null");
       } else {
         sb.append(this.ue);
       }
       first = false;
       if (!first) sb.append(", ");
       sb.append("te:");
       if (this.te == null) {
         sb.append("null");
       } else {
         sb.append(this.te);
       }
       first = false;
       sb.append(")");
       return sb.toString();
     }
 
     public void validate() throws TException {
       // check for required fields
     }
 
   }
 
   public static class describe_keyspaces_args implements TBase<describe_keyspaces_args._Fields>, java.io.Serializable, Cloneable, Comparable<describe_keyspaces_args>   {
     private static final TStruct STRUCT_DESC = new TStruct("describe_keyspaces_args");
 
 
 
     /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
     public enum _Fields implements TFieldIdEnum {
 ;
 
       private static final Map<Integer, _Fields> byId = new HashMap<Integer, _Fields>();
       private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();
 
       static {
         for (_Fields field : EnumSet.allOf(_Fields.class)) {
           byId.put((int)field._thriftId, field);
           byName.put(field.getFieldName(), field);
         }
       }
 
       /**
        * Find the _Fields constant that matches fieldId, or null if its not found.
        */
       public static _Fields findByThriftId(int fieldId) {
         return byId.get(fieldId);
       }
 
       /**
        * Find the _Fields constant that matches fieldId, throwing an exception
        * if it is not found.
        */
       public static _Fields findByThriftIdOrThrow(int fieldId) {
         _Fields fields = findByThriftId(fieldId);
         if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
         return fields;
       }
 
       /**
        * Find the _Fields constant that matches name, or null if its not found.
        */
       public static _Fields findByName(String name) {
         return byName.get(name);
       }
 
       private final short _thriftId;
       private final String _fieldName;
 
       _Fields(short thriftId, String fieldName) {
         _thriftId = thriftId;
         _fieldName = fieldName;
       }
 
       public short getThriftFieldId() {
         return _thriftId;
       }
 
       public String getFieldName() {
         return _fieldName;
       }
     }
     public static final Map<_Fields, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new EnumMap<_Fields, FieldMetaData>(_Fields.class) {{
     }});
 
     static {
       FieldMetaData.addStructMetaDataMap(describe_keyspaces_args.class, metaDataMap);
     }
 
     public describe_keyspaces_args() {
     }
 
     /**
      * Performs a deep copy on <i>other</i>.
      */
     public describe_keyspaces_args(describe_keyspaces_args other) {
     }
 
     public describe_keyspaces_args deepCopy() {
       return new describe_keyspaces_args(this);
     }
 
     @Deprecated
     public describe_keyspaces_args clone() {
       return new describe_keyspaces_args(this);
     }
 
     public void setFieldValue(_Fields field, Object value) {
       switch (field) {
       }
     }
 
     public void setFieldValue(int fieldID, Object value) {
       setFieldValue(_Fields.findByThriftIdOrThrow(fieldID), value);
     }
 
     public Object getFieldValue(_Fields field) {
       switch (field) {
       }
       throw new IllegalStateException();
     }
 
     public Object getFieldValue(int fieldId) {
       return getFieldValue(_Fields.findByThriftIdOrThrow(fieldId));
     }
 
     /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
     public boolean isSet(_Fields field) {
       switch (field) {
       }
       throw new IllegalStateException();
     }
 
     public boolean isSet(int fieldID) {
       return isSet(_Fields.findByThriftIdOrThrow(fieldID));
     }
 
     @Override
     public boolean equals(Object that) {
       if (that == null)
         return false;
       if (that instanceof describe_keyspaces_args)
         return this.equals((describe_keyspaces_args)that);
       return false;
     }
 
     public boolean equals(describe_keyspaces_args that) {
       if (that == null)
         return false;
 
       return true;
     }
 
     @Override
     public int hashCode() {
       return 0;
     }
 
     public int compareTo(describe_keyspaces_args other) {
       if (!getClass().equals(other.getClass())) {
         return getClass().getName().compareTo(other.getClass().getName());
       }
 
       int lastComparison = 0;
       describe_keyspaces_args typedOther = (describe_keyspaces_args)other;
 
       return 0;
     }
 
     public void read(TProtocol iprot) throws TException {
       TField field;
       iprot.readStructBegin();
       while (true)
       {
         field = iprot.readFieldBegin();
         if (field.type == TType.STOP) { 
           break;
         }
         switch (field.id) {
           default:
             TProtocolUtil.skip(iprot, field.type);
         }
         iprot.readFieldEnd();
       }
       iprot.readStructEnd();
 
       // check for required fields of primitive type, which can't be checked in the validate method
       validate();
     }
 
     public void write(TProtocol oprot) throws TException {
       validate();
 
       oprot.writeStructBegin(STRUCT_DESC);
       oprot.writeFieldStop();
       oprot.writeStructEnd();
     }
 
     @Override
     public String toString() {
       StringBuilder sb = new StringBuilder("describe_keyspaces_args(");
       boolean first = true;
 
       sb.append(")");
       return sb.toString();
     }
 
     public void validate() throws TException {
       // check for required fields
     }
 
   }
 
   public static class describe_keyspaces_result implements TBase<describe_keyspaces_result._Fields>, java.io.Serializable, Cloneable   {
     private static final TStruct STRUCT_DESC = new TStruct("describe_keyspaces_result");
 
     private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.SET, (short)0);
 
     public Set<String> success;
 
     /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
     public enum _Fields implements TFieldIdEnum {
       SUCCESS((short)0, "success");
 
       private static final Map<Integer, _Fields> byId = new HashMap<Integer, _Fields>();
       private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();
 
       static {
         for (_Fields field : EnumSet.allOf(_Fields.class)) {
           byId.put((int)field._thriftId, field);
           byName.put(field.getFieldName(), field);
         }
       }
 
       /**
        * Find the _Fields constant that matches fieldId, or null if its not found.
        */
       public static _Fields findByThriftId(int fieldId) {
         return byId.get(fieldId);
       }
 
       /**
        * Find the _Fields constant that matches fieldId, throwing an exception
        * if it is not found.
        */
       public static _Fields findByThriftIdOrThrow(int fieldId) {
         _Fields fields = findByThriftId(fieldId);
         if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
         return fields;
       }
 
       /**
        * Find the _Fields constant that matches name, or null if its not found.
        */
       public static _Fields findByName(String name) {
         return byName.get(name);
       }
 
       private final short _thriftId;
       private final String _fieldName;
 
       _Fields(short thriftId, String fieldName) {
         _thriftId = thriftId;
         _fieldName = fieldName;
       }
 
       public short getThriftFieldId() {
         return _thriftId;
       }
 
       public String getFieldName() {
         return _fieldName;
       }
     }
 
     // isset id assignments
 
     public static final Map<_Fields, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new EnumMap<_Fields, FieldMetaData>(_Fields.class) {{
       put(_Fields.SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
           new SetMetaData(TType.SET, 
               new FieldValueMetaData(TType.STRING))));
     }});
 
     static {
       FieldMetaData.addStructMetaDataMap(describe_keyspaces_result.class, metaDataMap);
     }
 
     public describe_keyspaces_result() {
     }
 
     public describe_keyspaces_result(
       Set<String> success)
     {
       this();
       this.success = success;
     }
 
     /**
      * Performs a deep copy on <i>other</i>.
      */
     public describe_keyspaces_result(describe_keyspaces_result other) {
       if (other.isSetSuccess()) {
         Set<String> __this__success = new HashSet<String>();
         for (String other_element : other.success) {
           __this__success.add(other_element);
         }
         this.success = __this__success;
       }
     }
 
     public describe_keyspaces_result deepCopy() {
       return new describe_keyspaces_result(this);
     }
 
     @Deprecated
     public describe_keyspaces_result clone() {
       return new describe_keyspaces_result(this);
     }
 
     public int getSuccessSize() {
       return (this.success == null) ? 0 : this.success.size();
     }
 
     public java.util.Iterator<String> getSuccessIterator() {
       return (this.success == null) ? null : this.success.iterator();
     }
 
     public void addToSuccess(String elem) {
       if (this.success == null) {
         this.success = new HashSet<String>();
       }
       this.success.add(elem);
     }
 
     public Set<String> getSuccess() {
       return this.success;
     }
 
     public describe_keyspaces_result setSuccess(Set<String> success) {
       this.success = success;
       return this;
     }
 
     public void unsetSuccess() {
       this.success = null;
     }
 
     /** Returns true if field success is set (has been asigned a value) and false otherwise */
     public boolean isSetSuccess() {
       return this.success != null;
     }
 
     public void setSuccessIsSet(boolean value) {
       if (!value) {
         this.success = null;
       }
     }
 
     public void setFieldValue(_Fields field, Object value) {
       switch (field) {
       case SUCCESS:
         if (value == null) {
           unsetSuccess();
         } else {
           setSuccess((Set<String>)value);
         }
         break;
 
       }
     }
 
     public void setFieldValue(int fieldID, Object value) {
       setFieldValue(_Fields.findByThriftIdOrThrow(fieldID), value);
     }
 
     public Object getFieldValue(_Fields field) {
       switch (field) {
       case SUCCESS:
         return getSuccess();
 
       }
       throw new IllegalStateException();
     }
 
     public Object getFieldValue(int fieldId) {
       return getFieldValue(_Fields.findByThriftIdOrThrow(fieldId));
     }
 
     /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
     public boolean isSet(_Fields field) {
       switch (field) {
       case SUCCESS:
         return isSetSuccess();
       }
       throw new IllegalStateException();
     }
 
     public boolean isSet(int fieldID) {
       return isSet(_Fields.findByThriftIdOrThrow(fieldID));
     }
 
     @Override
     public boolean equals(Object that) {
       if (that == null)
         return false;
       if (that instanceof describe_keyspaces_result)
         return this.equals((describe_keyspaces_result)that);
       return false;
     }
 
     public boolean equals(describe_keyspaces_result that) {
       if (that == null)
         return false;
 
       boolean this_present_success = true && this.isSetSuccess();
       boolean that_present_success = true && that.isSetSuccess();
       if (this_present_success || that_present_success) {
         if (!(this_present_success && that_present_success))
           return false;
         if (!this.success.equals(that.success))
           return false;
       }
 
       return true;
     }
 
     @Override
     public int hashCode() {
       return 0;
     }
 
     public void read(TProtocol iprot) throws TException {
       TField field;
       iprot.readStructBegin();
       while (true)
       {
         field = iprot.readFieldBegin();
         if (field.type == TType.STOP) { 
           break;
         }
         switch (field.id) {
           case 0: // SUCCESS
             if (field.type == TType.SET) {
               {
                TSet _set95 = iprot.readSetBegin();
                this.success = new HashSet<String>(2*_set95.size);
                for (int _i96 = 0; _i96 < _set95.size; ++_i96)
                {
                  String _elem97;
                  _elem97 = iprot.readString();
                  this.success.add(_elem97);
                 }
                 iprot.readSetEnd();
               }
             } else { 
               TProtocolUtil.skip(iprot, field.type);
             }
             break;
           default:
             TProtocolUtil.skip(iprot, field.type);
         }
         iprot.readFieldEnd();
       }
       iprot.readStructEnd();
 
       // check for required fields of primitive type, which can't be checked in the validate method
       validate();
     }
 
     public void write(TProtocol oprot) throws TException {
       oprot.writeStructBegin(STRUCT_DESC);
 
       if (this.isSetSuccess()) {
         oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
         {
           oprot.writeSetBegin(new TSet(TType.STRING, this.success.size()));
          for (String _iter98 : this.success)
           {
            oprot.writeString(_iter98);
           }
           oprot.writeSetEnd();
         }
         oprot.writeFieldEnd();
       }
       oprot.writeFieldStop();
       oprot.writeStructEnd();
     }
 
     @Override
     public String toString() {
       StringBuilder sb = new StringBuilder("describe_keyspaces_result(");
       boolean first = true;
 
       sb.append("success:");
       if (this.success == null) {
         sb.append("null");
       } else {
         sb.append(this.success);
       }
       first = false;
       sb.append(")");
       return sb.toString();
     }
 
     public void validate() throws TException {
       // check for required fields
     }
 
   }
 
   public static class describe_cluster_name_args implements TBase<describe_cluster_name_args._Fields>, java.io.Serializable, Cloneable, Comparable<describe_cluster_name_args>   {
     private static final TStruct STRUCT_DESC = new TStruct("describe_cluster_name_args");
 
 
 
     /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
     public enum _Fields implements TFieldIdEnum {
 ;
 
       private static final Map<Integer, _Fields> byId = new HashMap<Integer, _Fields>();
       private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();
 
       static {
         for (_Fields field : EnumSet.allOf(_Fields.class)) {
           byId.put((int)field._thriftId, field);
           byName.put(field.getFieldName(), field);
         }
       }
 
       /**
        * Find the _Fields constant that matches fieldId, or null if its not found.
        */
       public static _Fields findByThriftId(int fieldId) {
         return byId.get(fieldId);
       }
 
       /**
        * Find the _Fields constant that matches fieldId, throwing an exception
        * if it is not found.
        */
       public static _Fields findByThriftIdOrThrow(int fieldId) {
         _Fields fields = findByThriftId(fieldId);
         if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
         return fields;
       }
 
       /**
        * Find the _Fields constant that matches name, or null if its not found.
        */
       public static _Fields findByName(String name) {
         return byName.get(name);
       }
 
       private final short _thriftId;
       private final String _fieldName;
 
       _Fields(short thriftId, String fieldName) {
         _thriftId = thriftId;
         _fieldName = fieldName;
       }
 
       public short getThriftFieldId() {
         return _thriftId;
       }
 
       public String getFieldName() {
         return _fieldName;
       }
     }
     public static final Map<_Fields, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new EnumMap<_Fields, FieldMetaData>(_Fields.class) {{
     }});
 
     static {
       FieldMetaData.addStructMetaDataMap(describe_cluster_name_args.class, metaDataMap);
     }
 
     public describe_cluster_name_args() {
     }
 
     /**
      * Performs a deep copy on <i>other</i>.
      */
     public describe_cluster_name_args(describe_cluster_name_args other) {
     }
 
     public describe_cluster_name_args deepCopy() {
       return new describe_cluster_name_args(this);
     }
 
     @Deprecated
     public describe_cluster_name_args clone() {
       return new describe_cluster_name_args(this);
     }
 
     public void setFieldValue(_Fields field, Object value) {
       switch (field) {
       }
     }
 
     public void setFieldValue(int fieldID, Object value) {
       setFieldValue(_Fields.findByThriftIdOrThrow(fieldID), value);
     }
 
     public Object getFieldValue(_Fields field) {
       switch (field) {
       }
       throw new IllegalStateException();
     }
 
     public Object getFieldValue(int fieldId) {
       return getFieldValue(_Fields.findByThriftIdOrThrow(fieldId));
     }
 
     /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
     public boolean isSet(_Fields field) {
       switch (field) {
       }
       throw new IllegalStateException();
     }
 
     public boolean isSet(int fieldID) {
       return isSet(_Fields.findByThriftIdOrThrow(fieldID));
     }
 
     @Override
     public boolean equals(Object that) {
       if (that == null)
         return false;
       if (that instanceof describe_cluster_name_args)
         return this.equals((describe_cluster_name_args)that);
       return false;
     }
 
     public boolean equals(describe_cluster_name_args that) {
       if (that == null)
         return false;
 
       return true;
     }
 
     @Override
     public int hashCode() {
       return 0;
     }
 
     public int compareTo(describe_cluster_name_args other) {
       if (!getClass().equals(other.getClass())) {
         return getClass().getName().compareTo(other.getClass().getName());
       }
 
       int lastComparison = 0;
       describe_cluster_name_args typedOther = (describe_cluster_name_args)other;
 
       return 0;
     }
 
     public void read(TProtocol iprot) throws TException {
       TField field;
       iprot.readStructBegin();
       while (true)
       {
         field = iprot.readFieldBegin();
         if (field.type == TType.STOP) { 
           break;
         }
         switch (field.id) {
           default:
             TProtocolUtil.skip(iprot, field.type);
         }
         iprot.readFieldEnd();
       }
       iprot.readStructEnd();
 
       // check for required fields of primitive type, which can't be checked in the validate method
       validate();
     }
 
     public void write(TProtocol oprot) throws TException {
       validate();
 
       oprot.writeStructBegin(STRUCT_DESC);
       oprot.writeFieldStop();
       oprot.writeStructEnd();
     }
 
     @Override
     public String toString() {
       StringBuilder sb = new StringBuilder("describe_cluster_name_args(");
       boolean first = true;
 
       sb.append(")");
       return sb.toString();
     }
 
     public void validate() throws TException {
       // check for required fields
     }
 
   }
 
   public static class describe_cluster_name_result implements TBase<describe_cluster_name_result._Fields>, java.io.Serializable, Cloneable, Comparable<describe_cluster_name_result>   {
     private static final TStruct STRUCT_DESC = new TStruct("describe_cluster_name_result");
 
     private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRING, (short)0);
 
     public String success;
 
     /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
     public enum _Fields implements TFieldIdEnum {
       SUCCESS((short)0, "success");
 
       private static final Map<Integer, _Fields> byId = new HashMap<Integer, _Fields>();
       private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();
 
       static {
         for (_Fields field : EnumSet.allOf(_Fields.class)) {
           byId.put((int)field._thriftId, field);
           byName.put(field.getFieldName(), field);
         }
       }
 
       /**
        * Find the _Fields constant that matches fieldId, or null if its not found.
        */
       public static _Fields findByThriftId(int fieldId) {
         return byId.get(fieldId);
       }
 
       /**
        * Find the _Fields constant that matches fieldId, throwing an exception
        * if it is not found.
        */
       public static _Fields findByThriftIdOrThrow(int fieldId) {
         _Fields fields = findByThriftId(fieldId);
         if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
         return fields;
       }
 
       /**
        * Find the _Fields constant that matches name, or null if its not found.
        */
       public static _Fields findByName(String name) {
         return byName.get(name);
       }
 
       private final short _thriftId;
       private final String _fieldName;
 
       _Fields(short thriftId, String fieldName) {
         _thriftId = thriftId;
         _fieldName = fieldName;
       }
 
       public short getThriftFieldId() {
         return _thriftId;
       }
 
       public String getFieldName() {
         return _fieldName;
       }
     }
 
     // isset id assignments
 
     public static final Map<_Fields, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new EnumMap<_Fields, FieldMetaData>(_Fields.class) {{
       put(_Fields.SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
           new FieldValueMetaData(TType.STRING)));
     }});
 
     static {
       FieldMetaData.addStructMetaDataMap(describe_cluster_name_result.class, metaDataMap);
     }
 
     public describe_cluster_name_result() {
     }
 
     public describe_cluster_name_result(
       String success)
     {
       this();
       this.success = success;
     }
 
     /**
      * Performs a deep copy on <i>other</i>.
      */
     public describe_cluster_name_result(describe_cluster_name_result other) {
       if (other.isSetSuccess()) {
         this.success = other.success;
       }
     }
 
     public describe_cluster_name_result deepCopy() {
       return new describe_cluster_name_result(this);
     }
 
     @Deprecated
     public describe_cluster_name_result clone() {
       return new describe_cluster_name_result(this);
     }
 
     public String getSuccess() {
       return this.success;
     }
 
     public describe_cluster_name_result setSuccess(String success) {
       this.success = success;
       return this;
     }
 
     public void unsetSuccess() {
       this.success = null;
     }
 
     /** Returns true if field success is set (has been asigned a value) and false otherwise */
     public boolean isSetSuccess() {
       return this.success != null;
     }
 
     public void setSuccessIsSet(boolean value) {
       if (!value) {
         this.success = null;
       }
     }
 
     public void setFieldValue(_Fields field, Object value) {
       switch (field) {
       case SUCCESS:
         if (value == null) {
           unsetSuccess();
         } else {
           setSuccess((String)value);
         }
         break;
 
       }
     }
 
     public void setFieldValue(int fieldID, Object value) {
       setFieldValue(_Fields.findByThriftIdOrThrow(fieldID), value);
     }
 
     public Object getFieldValue(_Fields field) {
       switch (field) {
       case SUCCESS:
         return getSuccess();
 
       }
       throw new IllegalStateException();
     }
 
     public Object getFieldValue(int fieldId) {
       return getFieldValue(_Fields.findByThriftIdOrThrow(fieldId));
     }
 
     /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
     public boolean isSet(_Fields field) {
       switch (field) {
       case SUCCESS:
         return isSetSuccess();
       }
       throw new IllegalStateException();
     }
 
     public boolean isSet(int fieldID) {
       return isSet(_Fields.findByThriftIdOrThrow(fieldID));
     }
 
     @Override
     public boolean equals(Object that) {
       if (that == null)
         return false;
       if (that instanceof describe_cluster_name_result)
         return this.equals((describe_cluster_name_result)that);
       return false;
     }
 
     public boolean equals(describe_cluster_name_result that) {
       if (that == null)
         return false;
 
       boolean this_present_success = true && this.isSetSuccess();
       boolean that_present_success = true && that.isSetSuccess();
       if (this_present_success || that_present_success) {
         if (!(this_present_success && that_present_success))
           return false;
         if (!this.success.equals(that.success))
           return false;
       }
 
       return true;
     }
 
     @Override
     public int hashCode() {
       return 0;
     }
 
     public int compareTo(describe_cluster_name_result other) {
       if (!getClass().equals(other.getClass())) {
         return getClass().getName().compareTo(other.getClass().getName());
       }
 
       int lastComparison = 0;
       describe_cluster_name_result typedOther = (describe_cluster_name_result)other;
 
       lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(typedOther.isSetSuccess());
       if (lastComparison != 0) {
         return lastComparison;
       }
       if (isSetSuccess()) {        lastComparison = TBaseHelper.compareTo(success, typedOther.success);
         if (lastComparison != 0) {
           return lastComparison;
         }
       }
       return 0;
     }
 
     public void read(TProtocol iprot) throws TException {
       TField field;
       iprot.readStructBegin();
       while (true)
       {
         field = iprot.readFieldBegin();
         if (field.type == TType.STOP) { 
           break;
         }
         switch (field.id) {
           case 0: // SUCCESS
             if (field.type == TType.STRING) {
               this.success = iprot.readString();
             } else { 
               TProtocolUtil.skip(iprot, field.type);
             }
             break;
           default:
             TProtocolUtil.skip(iprot, field.type);
         }
         iprot.readFieldEnd();
       }
       iprot.readStructEnd();
 
       // check for required fields of primitive type, which can't be checked in the validate method
       validate();
     }
 
     public void write(TProtocol oprot) throws TException {
       oprot.writeStructBegin(STRUCT_DESC);
 
       if (this.isSetSuccess()) {
         oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
         oprot.writeString(this.success);
         oprot.writeFieldEnd();
       }
       oprot.writeFieldStop();
       oprot.writeStructEnd();
     }
 
     @Override
     public String toString() {
       StringBuilder sb = new StringBuilder("describe_cluster_name_result(");
       boolean first = true;
 
       sb.append("success:");
       if (this.success == null) {
         sb.append("null");
       } else {
         sb.append(this.success);
       }
       first = false;
       sb.append(")");
       return sb.toString();
     }
 
     public void validate() throws TException {
       // check for required fields
     }
 
   }
 
   public static class describe_version_args implements TBase<describe_version_args._Fields>, java.io.Serializable, Cloneable, Comparable<describe_version_args>   {
     private static final TStruct STRUCT_DESC = new TStruct("describe_version_args");
 
 
 
     /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
     public enum _Fields implements TFieldIdEnum {
 ;
 
       private static final Map<Integer, _Fields> byId = new HashMap<Integer, _Fields>();
       private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();
 
       static {
         for (_Fields field : EnumSet.allOf(_Fields.class)) {
           byId.put((int)field._thriftId, field);
           byName.put(field.getFieldName(), field);
         }
       }
 
       /**
        * Find the _Fields constant that matches fieldId, or null if its not found.
        */
       public static _Fields findByThriftId(int fieldId) {
         return byId.get(fieldId);
       }
 
       /**
        * Find the _Fields constant that matches fieldId, throwing an exception
        * if it is not found.
        */
       public static _Fields findByThriftIdOrThrow(int fieldId) {
         _Fields fields = findByThriftId(fieldId);
         if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
         return fields;
       }
 
       /**
        * Find the _Fields constant that matches name, or null if its not found.
        */
       public static _Fields findByName(String name) {
         return byName.get(name);
       }
 
       private final short _thriftId;
       private final String _fieldName;
 
       _Fields(short thriftId, String fieldName) {
         _thriftId = thriftId;
         _fieldName = fieldName;
       }
 
       public short getThriftFieldId() {
         return _thriftId;
       }
 
       public String getFieldName() {
         return _fieldName;
       }
     }
     public static final Map<_Fields, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new EnumMap<_Fields, FieldMetaData>(_Fields.class) {{
     }});
 
     static {
       FieldMetaData.addStructMetaDataMap(describe_version_args.class, metaDataMap);
     }
 
     public describe_version_args() {
     }
 
     /**
      * Performs a deep copy on <i>other</i>.
      */
     public describe_version_args(describe_version_args other) {
     }
 
     public describe_version_args deepCopy() {
       return new describe_version_args(this);
     }
 
     @Deprecated
     public describe_version_args clone() {
       return new describe_version_args(this);
     }
 
     public void setFieldValue(_Fields field, Object value) {
       switch (field) {
       }
     }
 
     public void setFieldValue(int fieldID, Object value) {
       setFieldValue(_Fields.findByThriftIdOrThrow(fieldID), value);
     }
 
     public Object getFieldValue(_Fields field) {
       switch (field) {
       }
       throw new IllegalStateException();
     }
 
     public Object getFieldValue(int fieldId) {
       return getFieldValue(_Fields.findByThriftIdOrThrow(fieldId));
     }
 
     /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
     public boolean isSet(_Fields field) {
       switch (field) {
       }
       throw new IllegalStateException();
     }
 
     public boolean isSet(int fieldID) {
       return isSet(_Fields.findByThriftIdOrThrow(fieldID));
     }
 
     @Override
     public boolean equals(Object that) {
       if (that == null)
         return false;
       if (that instanceof describe_version_args)
         return this.equals((describe_version_args)that);
       return false;
     }
 
     public boolean equals(describe_version_args that) {
       if (that == null)
         return false;
 
       return true;
     }
 
     @Override
     public int hashCode() {
       return 0;
     }
 
     public int compareTo(describe_version_args other) {
       if (!getClass().equals(other.getClass())) {
         return getClass().getName().compareTo(other.getClass().getName());
       }
 
       int lastComparison = 0;
       describe_version_args typedOther = (describe_version_args)other;
 
       return 0;
     }
 
     public void read(TProtocol iprot) throws TException {
       TField field;
       iprot.readStructBegin();
       while (true)
       {
         field = iprot.readFieldBegin();
         if (field.type == TType.STOP) { 
           break;
         }
         switch (field.id) {
           default:
             TProtocolUtil.skip(iprot, field.type);
         }
         iprot.readFieldEnd();
       }
       iprot.readStructEnd();
 
       // check for required fields of primitive type, which can't be checked in the validate method
       validate();
     }
 
     public void write(TProtocol oprot) throws TException {
       validate();
 
       oprot.writeStructBegin(STRUCT_DESC);
       oprot.writeFieldStop();
       oprot.writeStructEnd();
     }
 
     @Override
     public String toString() {
       StringBuilder sb = new StringBuilder("describe_version_args(");
       boolean first = true;
 
       sb.append(")");
       return sb.toString();
     }
 
     public void validate() throws TException {
       // check for required fields
     }
 
   }
 
   public static class describe_version_result implements TBase<describe_version_result._Fields>, java.io.Serializable, Cloneable, Comparable<describe_version_result>   {
     private static final TStruct STRUCT_DESC = new TStruct("describe_version_result");
 
     private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRING, (short)0);
 
     public String success;
 
     /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
     public enum _Fields implements TFieldIdEnum {
       SUCCESS((short)0, "success");
 
       private static final Map<Integer, _Fields> byId = new HashMap<Integer, _Fields>();
       private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();
 
       static {
         for (_Fields field : EnumSet.allOf(_Fields.class)) {
           byId.put((int)field._thriftId, field);
           byName.put(field.getFieldName(), field);
         }
       }
 
       /**
        * Find the _Fields constant that matches fieldId, or null if its not found.
        */
       public static _Fields findByThriftId(int fieldId) {
         return byId.get(fieldId);
       }
 
       /**
        * Find the _Fields constant that matches fieldId, throwing an exception
        * if it is not found.
        */
       public static _Fields findByThriftIdOrThrow(int fieldId) {
         _Fields fields = findByThriftId(fieldId);
         if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
         return fields;
       }
 
       /**
        * Find the _Fields constant that matches name, or null if its not found.
        */
       public static _Fields findByName(String name) {
         return byName.get(name);
       }
 
       private final short _thriftId;
       private final String _fieldName;
 
       _Fields(short thriftId, String fieldName) {
         _thriftId = thriftId;
         _fieldName = fieldName;
       }
 
       public short getThriftFieldId() {
         return _thriftId;
       }
 
       public String getFieldName() {
         return _fieldName;
       }
     }
 
     // isset id assignments
 
     public static final Map<_Fields, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new EnumMap<_Fields, FieldMetaData>(_Fields.class) {{
       put(_Fields.SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
           new FieldValueMetaData(TType.STRING)));
     }});
 
     static {
       FieldMetaData.addStructMetaDataMap(describe_version_result.class, metaDataMap);
     }
 
     public describe_version_result() {
     }
 
     public describe_version_result(
       String success)
     {
       this();
       this.success = success;
     }
 
     /**
      * Performs a deep copy on <i>other</i>.
      */
     public describe_version_result(describe_version_result other) {
       if (other.isSetSuccess()) {
         this.success = other.success;
       }
     }
 
     public describe_version_result deepCopy() {
       return new describe_version_result(this);
     }
 
     @Deprecated
     public describe_version_result clone() {
       return new describe_version_result(this);
     }
 
     public String getSuccess() {
       return this.success;
     }
 
     public describe_version_result setSuccess(String success) {
       this.success = success;
       return this;
     }
 
     public void unsetSuccess() {
       this.success = null;
     }
 
     /** Returns true if field success is set (has been asigned a value) and false otherwise */
     public boolean isSetSuccess() {
       return this.success != null;
     }
 
     public void setSuccessIsSet(boolean value) {
       if (!value) {
         this.success = null;
       }
     }
 
     public void setFieldValue(_Fields field, Object value) {
       switch (field) {
       case SUCCESS:
         if (value == null) {
           unsetSuccess();
         } else {
           setSuccess((String)value);
         }
         break;
 
       }
     }
 
     public void setFieldValue(int fieldID, Object value) {
       setFieldValue(_Fields.findByThriftIdOrThrow(fieldID), value);
     }
 
     public Object getFieldValue(_Fields field) {
       switch (field) {
       case SUCCESS:
         return getSuccess();
 
       }
       throw new IllegalStateException();
     }
 
     public Object getFieldValue(int fieldId) {
       return getFieldValue(_Fields.findByThriftIdOrThrow(fieldId));
     }
 
     /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
     public boolean isSet(_Fields field) {
       switch (field) {
       case SUCCESS:
         return isSetSuccess();
       }
       throw new IllegalStateException();
     }
 
     public boolean isSet(int fieldID) {
       return isSet(_Fields.findByThriftIdOrThrow(fieldID));
     }
 
     @Override
     public boolean equals(Object that) {
       if (that == null)
         return false;
       if (that instanceof describe_version_result)
         return this.equals((describe_version_result)that);
       return false;
     }
 
     public boolean equals(describe_version_result that) {
       if (that == null)
         return false;
 
       boolean this_present_success = true && this.isSetSuccess();
       boolean that_present_success = true && that.isSetSuccess();
       if (this_present_success || that_present_success) {
         if (!(this_present_success && that_present_success))
           return false;
         if (!this.success.equals(that.success))
           return false;
       }
 
       return true;
     }
 
     @Override
     public int hashCode() {
       return 0;
     }
 
     public int compareTo(describe_version_result other) {
       if (!getClass().equals(other.getClass())) {
         return getClass().getName().compareTo(other.getClass().getName());
       }
 
       int lastComparison = 0;
       describe_version_result typedOther = (describe_version_result)other;
 
       lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(typedOther.isSetSuccess());
       if (lastComparison != 0) {
         return lastComparison;
       }
       if (isSetSuccess()) {        lastComparison = TBaseHelper.compareTo(success, typedOther.success);
         if (lastComparison != 0) {
           return lastComparison;
         }
       }
       return 0;
     }
 
     public void read(TProtocol iprot) throws TException {
       TField field;
       iprot.readStructBegin();
       while (true)
       {
         field = iprot.readFieldBegin();
         if (field.type == TType.STOP) { 
           break;
         }
         switch (field.id) {
           case 0: // SUCCESS
             if (field.type == TType.STRING) {
               this.success = iprot.readString();
             } else { 
               TProtocolUtil.skip(iprot, field.type);
             }
             break;
           default:
             TProtocolUtil.skip(iprot, field.type);
         }
         iprot.readFieldEnd();
       }
       iprot.readStructEnd();
 
       // check for required fields of primitive type, which can't be checked in the validate method
       validate();
     }
 
     public void write(TProtocol oprot) throws TException {
       oprot.writeStructBegin(STRUCT_DESC);
 
       if (this.isSetSuccess()) {
         oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
         oprot.writeString(this.success);
         oprot.writeFieldEnd();
       }
       oprot.writeFieldStop();
       oprot.writeStructEnd();
     }
 
     @Override
     public String toString() {
       StringBuilder sb = new StringBuilder("describe_version_result(");
       boolean first = true;
 
       sb.append("success:");
       if (this.success == null) {
         sb.append("null");
       } else {
         sb.append(this.success);
       }
       first = false;
       sb.append(")");
       return sb.toString();
     }
 
     public void validate() throws TException {
       // check for required fields
     }
 
   }
 
   public static class describe_ring_args implements TBase<describe_ring_args._Fields>, java.io.Serializable, Cloneable, Comparable<describe_ring_args>   {
     private static final TStruct STRUCT_DESC = new TStruct("describe_ring_args");
 
     private static final TField KEYSPACE_FIELD_DESC = new TField("keyspace", TType.STRING, (short)1);
 
     public String keyspace;
 
     /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
     public enum _Fields implements TFieldIdEnum {
       KEYSPACE((short)1, "keyspace");
 
       private static final Map<Integer, _Fields> byId = new HashMap<Integer, _Fields>();
       private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();
 
       static {
         for (_Fields field : EnumSet.allOf(_Fields.class)) {
           byId.put((int)field._thriftId, field);
           byName.put(field.getFieldName(), field);
         }
       }
 
       /**
        * Find the _Fields constant that matches fieldId, or null if its not found.
        */
       public static _Fields findByThriftId(int fieldId) {
         return byId.get(fieldId);
       }
 
       /**
        * Find the _Fields constant that matches fieldId, throwing an exception
        * if it is not found.
        */
       public static _Fields findByThriftIdOrThrow(int fieldId) {
         _Fields fields = findByThriftId(fieldId);
         if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
         return fields;
       }
 
       /**
        * Find the _Fields constant that matches name, or null if its not found.
        */
       public static _Fields findByName(String name) {
         return byName.get(name);
       }
 
       private final short _thriftId;
       private final String _fieldName;
 
       _Fields(short thriftId, String fieldName) {
         _thriftId = thriftId;
         _fieldName = fieldName;
       }
 
       public short getThriftFieldId() {
         return _thriftId;
       }
 
       public String getFieldName() {
         return _fieldName;
       }
     }
 
     // isset id assignments
 
     public static final Map<_Fields, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new EnumMap<_Fields, FieldMetaData>(_Fields.class) {{
       put(_Fields.KEYSPACE, new FieldMetaData("keyspace", TFieldRequirementType.REQUIRED, 
           new FieldValueMetaData(TType.STRING)));
     }});
 
     static {
       FieldMetaData.addStructMetaDataMap(describe_ring_args.class, metaDataMap);
     }
 
     public describe_ring_args() {
     }
 
     public describe_ring_args(
       String keyspace)
     {
       this();
       this.keyspace = keyspace;
     }
 
     /**
      * Performs a deep copy on <i>other</i>.
      */
     public describe_ring_args(describe_ring_args other) {
       if (other.isSetKeyspace()) {
         this.keyspace = other.keyspace;
       }
     }
 
     public describe_ring_args deepCopy() {
       return new describe_ring_args(this);
     }
 
     @Deprecated
     public describe_ring_args clone() {
       return new describe_ring_args(this);
     }
 
     public String getKeyspace() {
       return this.keyspace;
     }
 
     public describe_ring_args setKeyspace(String keyspace) {
       this.keyspace = keyspace;
       return this;
     }
 
     public void unsetKeyspace() {
       this.keyspace = null;
     }
 
     /** Returns true if field keyspace is set (has been asigned a value) and false otherwise */
     public boolean isSetKeyspace() {
       return this.keyspace != null;
     }
 
     public void setKeyspaceIsSet(boolean value) {
       if (!value) {
         this.keyspace = null;
       }
     }
 
     public void setFieldValue(_Fields field, Object value) {
       switch (field) {
       case KEYSPACE:
         if (value == null) {
           unsetKeyspace();
         } else {
           setKeyspace((String)value);
         }
         break;
 
       }
     }
 
     public void setFieldValue(int fieldID, Object value) {
       setFieldValue(_Fields.findByThriftIdOrThrow(fieldID), value);
     }
 
     public Object getFieldValue(_Fields field) {
       switch (field) {
       case KEYSPACE:
         return getKeyspace();
 
       }
       throw new IllegalStateException();
     }
 
     public Object getFieldValue(int fieldId) {
       return getFieldValue(_Fields.findByThriftIdOrThrow(fieldId));
     }
 
     /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
     public boolean isSet(_Fields field) {
       switch (field) {
       case KEYSPACE:
         return isSetKeyspace();
       }
       throw new IllegalStateException();
     }
 
     public boolean isSet(int fieldID) {
       return isSet(_Fields.findByThriftIdOrThrow(fieldID));
     }
 
     @Override
     public boolean equals(Object that) {
       if (that == null)
         return false;
       if (that instanceof describe_ring_args)
         return this.equals((describe_ring_args)that);
       return false;
     }
 
     public boolean equals(describe_ring_args that) {
       if (that == null)
         return false;
 
       boolean this_present_keyspace = true && this.isSetKeyspace();
       boolean that_present_keyspace = true && that.isSetKeyspace();
       if (this_present_keyspace || that_present_keyspace) {
         if (!(this_present_keyspace && that_present_keyspace))
           return false;
         if (!this.keyspace.equals(that.keyspace))
           return false;
       }
 
       return true;
     }
 
     @Override
     public int hashCode() {
       return 0;
     }
 
     public int compareTo(describe_ring_args other) {
       if (!getClass().equals(other.getClass())) {
         return getClass().getName().compareTo(other.getClass().getName());
       }
 
       int lastComparison = 0;
       describe_ring_args typedOther = (describe_ring_args)other;
 
       lastComparison = Boolean.valueOf(isSetKeyspace()).compareTo(typedOther.isSetKeyspace());
       if (lastComparison != 0) {
         return lastComparison;
       }
       if (isSetKeyspace()) {        lastComparison = TBaseHelper.compareTo(keyspace, typedOther.keyspace);
         if (lastComparison != 0) {
           return lastComparison;
         }
       }
       return 0;
     }
 
     public void read(TProtocol iprot) throws TException {
       TField field;
       iprot.readStructBegin();
       while (true)
       {
         field = iprot.readFieldBegin();
         if (field.type == TType.STOP) { 
           break;
         }
         switch (field.id) {
           case 1: // KEYSPACE
             if (field.type == TType.STRING) {
               this.keyspace = iprot.readString();
             } else { 
               TProtocolUtil.skip(iprot, field.type);
             }
             break;
           default:
             TProtocolUtil.skip(iprot, field.type);
         }
         iprot.readFieldEnd();
       }
       iprot.readStructEnd();
 
       // check for required fields of primitive type, which can't be checked in the validate method
       validate();
     }
 
     public void write(TProtocol oprot) throws TException {
       validate();
 
       oprot.writeStructBegin(STRUCT_DESC);
       if (this.keyspace != null) {
         oprot.writeFieldBegin(KEYSPACE_FIELD_DESC);
         oprot.writeString(this.keyspace);
         oprot.writeFieldEnd();
       }
       oprot.writeFieldStop();
       oprot.writeStructEnd();
     }
 
     @Override
     public String toString() {
       StringBuilder sb = new StringBuilder("describe_ring_args(");
       boolean first = true;
 
       sb.append("keyspace:");
       if (this.keyspace == null) {
         sb.append("null");
       } else {
         sb.append(this.keyspace);
       }
       first = false;
       sb.append(")");
       return sb.toString();
     }
 
     public void validate() throws TException {
       // check for required fields
       if (keyspace == null) {
         throw new TProtocolException("Required field 'keyspace' was not present! Struct: " + toString());
       }
     }
 
   }
 
   public static class describe_ring_result implements TBase<describe_ring_result._Fields>, java.io.Serializable, Cloneable, Comparable<describe_ring_result>   {
     private static final TStruct STRUCT_DESC = new TStruct("describe_ring_result");
 
     private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.LIST, (short)0);
 
     public List<TokenRange> success;
 
     /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
     public enum _Fields implements TFieldIdEnum {
       SUCCESS((short)0, "success");
 
       private static final Map<Integer, _Fields> byId = new HashMap<Integer, _Fields>();
       private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();
 
       static {
         for (_Fields field : EnumSet.allOf(_Fields.class)) {
           byId.put((int)field._thriftId, field);
           byName.put(field.getFieldName(), field);
         }
       }
 
       /**
        * Find the _Fields constant that matches fieldId, or null if its not found.
        */
       public static _Fields findByThriftId(int fieldId) {
         return byId.get(fieldId);
       }
 
       /**
        * Find the _Fields constant that matches fieldId, throwing an exception
        * if it is not found.
        */
       public static _Fields findByThriftIdOrThrow(int fieldId) {
         _Fields fields = findByThriftId(fieldId);
         if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
         return fields;
       }
 
       /**
        * Find the _Fields constant that matches name, or null if its not found.
        */
       public static _Fields findByName(String name) {
         return byName.get(name);
       }
 
       private final short _thriftId;
       private final String _fieldName;
 
       _Fields(short thriftId, String fieldName) {
         _thriftId = thriftId;
         _fieldName = fieldName;
       }
 
       public short getThriftFieldId() {
         return _thriftId;
       }
 
       public String getFieldName() {
         return _fieldName;
       }
     }
 
     // isset id assignments
 
     public static final Map<_Fields, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new EnumMap<_Fields, FieldMetaData>(_Fields.class) {{
       put(_Fields.SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
           new ListMetaData(TType.LIST, 
               new StructMetaData(TType.STRUCT, TokenRange.class))));
     }});
 
     static {
       FieldMetaData.addStructMetaDataMap(describe_ring_result.class, metaDataMap);
     }
 
     public describe_ring_result() {
     }
 
     public describe_ring_result(
       List<TokenRange> success)
     {
       this();
       this.success = success;
     }
 
     /**
      * Performs a deep copy on <i>other</i>.
      */
     public describe_ring_result(describe_ring_result other) {
       if (other.isSetSuccess()) {
         List<TokenRange> __this__success = new ArrayList<TokenRange>();
         for (TokenRange other_element : other.success) {
           __this__success.add(new TokenRange(other_element));
         }
         this.success = __this__success;
       }
     }
 
     public describe_ring_result deepCopy() {
       return new describe_ring_result(this);
     }
 
     @Deprecated
     public describe_ring_result clone() {
       return new describe_ring_result(this);
     }
 
     public int getSuccessSize() {
       return (this.success == null) ? 0 : this.success.size();
     }
 
     public java.util.Iterator<TokenRange> getSuccessIterator() {
       return (this.success == null) ? null : this.success.iterator();
     }
 
     public void addToSuccess(TokenRange elem) {
       if (this.success == null) {
         this.success = new ArrayList<TokenRange>();
       }
       this.success.add(elem);
     }
 
     public List<TokenRange> getSuccess() {
       return this.success;
     }
 
     public describe_ring_result setSuccess(List<TokenRange> success) {
       this.success = success;
       return this;
     }
 
     public void unsetSuccess() {
       this.success = null;
     }
 
     /** Returns true if field success is set (has been asigned a value) and false otherwise */
     public boolean isSetSuccess() {
       return this.success != null;
     }
 
     public void setSuccessIsSet(boolean value) {
       if (!value) {
         this.success = null;
       }
     }
 
     public void setFieldValue(_Fields field, Object value) {
       switch (field) {
       case SUCCESS:
         if (value == null) {
           unsetSuccess();
         } else {
           setSuccess((List<TokenRange>)value);
         }
         break;
 
       }
     }
 
     public void setFieldValue(int fieldID, Object value) {
       setFieldValue(_Fields.findByThriftIdOrThrow(fieldID), value);
     }
 
     public Object getFieldValue(_Fields field) {
       switch (field) {
       case SUCCESS:
         return getSuccess();
 
       }
       throw new IllegalStateException();
     }
 
     public Object getFieldValue(int fieldId) {
       return getFieldValue(_Fields.findByThriftIdOrThrow(fieldId));
     }
 
     /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
     public boolean isSet(_Fields field) {
       switch (field) {
       case SUCCESS:
         return isSetSuccess();
       }
       throw new IllegalStateException();
     }
 
     public boolean isSet(int fieldID) {
       return isSet(_Fields.findByThriftIdOrThrow(fieldID));
     }
 
     @Override
     public boolean equals(Object that) {
       if (that == null)
         return false;
       if (that instanceof describe_ring_result)
         return this.equals((describe_ring_result)that);
       return false;
     }
 
     public boolean equals(describe_ring_result that) {
       if (that == null)
         return false;
 
       boolean this_present_success = true && this.isSetSuccess();
       boolean that_present_success = true && that.isSetSuccess();
       if (this_present_success || that_present_success) {
         if (!(this_present_success && that_present_success))
           return false;
         if (!this.success.equals(that.success))
           return false;
       }
 
       return true;
     }
 
     @Override
     public int hashCode() {
       return 0;
     }
 
     public int compareTo(describe_ring_result other) {
       if (!getClass().equals(other.getClass())) {
         return getClass().getName().compareTo(other.getClass().getName());
       }
 
       int lastComparison = 0;
       describe_ring_result typedOther = (describe_ring_result)other;
 
       lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(typedOther.isSetSuccess());
       if (lastComparison != 0) {
         return lastComparison;
       }
       if (isSetSuccess()) {        lastComparison = TBaseHelper.compareTo(success, typedOther.success);
         if (lastComparison != 0) {
           return lastComparison;
         }
       }
       return 0;
     }
 
     public void read(TProtocol iprot) throws TException {
       TField field;
       iprot.readStructBegin();
       while (true)
       {
         field = iprot.readFieldBegin();
         if (field.type == TType.STOP) { 
           break;
         }
         switch (field.id) {
           case 0: // SUCCESS
             if (field.type == TType.LIST) {
               {
                TList _list99 = iprot.readListBegin();
                this.success = new ArrayList<TokenRange>(_list99.size);
                for (int _i100 = 0; _i100 < _list99.size; ++_i100)
                {
                  TokenRange _elem101;
                  _elem101 = new TokenRange();
                  _elem101.read(iprot);
                  this.success.add(_elem101);
                 }
                 iprot.readListEnd();
               }
             } else { 
               TProtocolUtil.skip(iprot, field.type);
             }
             break;
           default:
             TProtocolUtil.skip(iprot, field.type);
         }
         iprot.readFieldEnd();
       }
       iprot.readStructEnd();
 
       // check for required fields of primitive type, which can't be checked in the validate method
       validate();
     }
 
     public void write(TProtocol oprot) throws TException {
       oprot.writeStructBegin(STRUCT_DESC);
 
       if (this.isSetSuccess()) {
         oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
         {
           oprot.writeListBegin(new TList(TType.STRUCT, this.success.size()));
          for (TokenRange _iter102 : this.success)
           {
            _iter102.write(oprot);
           }
           oprot.writeListEnd();
         }
         oprot.writeFieldEnd();
       }
       oprot.writeFieldStop();
       oprot.writeStructEnd();
     }
 
     @Override
     public String toString() {
       StringBuilder sb = new StringBuilder("describe_ring_result(");
       boolean first = true;
 
       sb.append("success:");
       if (this.success == null) {
         sb.append("null");
       } else {
         sb.append(this.success);
       }
       first = false;
       sb.append(")");
       return sb.toString();
     }
 
     public void validate() throws TException {
       // check for required fields
     }
 
   }
 
   public static class describe_keyspace_args implements TBase<describe_keyspace_args._Fields>, java.io.Serializable, Cloneable, Comparable<describe_keyspace_args>   {
     private static final TStruct STRUCT_DESC = new TStruct("describe_keyspace_args");
 
     private static final TField KEYSPACE_FIELD_DESC = new TField("keyspace", TType.STRING, (short)1);
 
     public String keyspace;
 
     /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
     public enum _Fields implements TFieldIdEnum {
       KEYSPACE((short)1, "keyspace");
 
       private static final Map<Integer, _Fields> byId = new HashMap<Integer, _Fields>();
       private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();
 
       static {
         for (_Fields field : EnumSet.allOf(_Fields.class)) {
           byId.put((int)field._thriftId, field);
           byName.put(field.getFieldName(), field);
         }
       }
 
       /**
        * Find the _Fields constant that matches fieldId, or null if its not found.
        */
       public static _Fields findByThriftId(int fieldId) {
         return byId.get(fieldId);
       }
 
       /**
        * Find the _Fields constant that matches fieldId, throwing an exception
        * if it is not found.
        */
       public static _Fields findByThriftIdOrThrow(int fieldId) {
         _Fields fields = findByThriftId(fieldId);
         if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
         return fields;
       }
 
       /**
        * Find the _Fields constant that matches name, or null if its not found.
        */
       public static _Fields findByName(String name) {
         return byName.get(name);
       }
 
       private final short _thriftId;
       private final String _fieldName;
 
       _Fields(short thriftId, String fieldName) {
         _thriftId = thriftId;
         _fieldName = fieldName;
       }
 
       public short getThriftFieldId() {
         return _thriftId;
       }
 
       public String getFieldName() {
         return _fieldName;
       }
     }
 
     // isset id assignments
 
     public static final Map<_Fields, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new EnumMap<_Fields, FieldMetaData>(_Fields.class) {{
       put(_Fields.KEYSPACE, new FieldMetaData("keyspace", TFieldRequirementType.REQUIRED, 
           new FieldValueMetaData(TType.STRING)));
     }});
 
     static {
       FieldMetaData.addStructMetaDataMap(describe_keyspace_args.class, metaDataMap);
     }
 
     public describe_keyspace_args() {
     }
 
     public describe_keyspace_args(
       String keyspace)
     {
       this();
       this.keyspace = keyspace;
     }
 
     /**
      * Performs a deep copy on <i>other</i>.
      */
     public describe_keyspace_args(describe_keyspace_args other) {
       if (other.isSetKeyspace()) {
         this.keyspace = other.keyspace;
       }
     }
 
     public describe_keyspace_args deepCopy() {
       return new describe_keyspace_args(this);
     }
 
     @Deprecated
     public describe_keyspace_args clone() {
       return new describe_keyspace_args(this);
     }
 
     public String getKeyspace() {
       return this.keyspace;
     }
 
     public describe_keyspace_args setKeyspace(String keyspace) {
       this.keyspace = keyspace;
       return this;
     }
 
     public void unsetKeyspace() {
       this.keyspace = null;
     }
 
     /** Returns true if field keyspace is set (has been asigned a value) and false otherwise */
     public boolean isSetKeyspace() {
       return this.keyspace != null;
     }
 
     public void setKeyspaceIsSet(boolean value) {
       if (!value) {
         this.keyspace = null;
       }
     }
 
     public void setFieldValue(_Fields field, Object value) {
       switch (field) {
       case KEYSPACE:
         if (value == null) {
           unsetKeyspace();
         } else {
           setKeyspace((String)value);
         }
         break;
 
       }
     }
 
     public void setFieldValue(int fieldID, Object value) {
       setFieldValue(_Fields.findByThriftIdOrThrow(fieldID), value);
     }
 
     public Object getFieldValue(_Fields field) {
       switch (field) {
       case KEYSPACE:
         return getKeyspace();
 
       }
       throw new IllegalStateException();
     }
 
     public Object getFieldValue(int fieldId) {
       return getFieldValue(_Fields.findByThriftIdOrThrow(fieldId));
     }
 
     /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
     public boolean isSet(_Fields field) {
       switch (field) {
       case KEYSPACE:
         return isSetKeyspace();
       }
       throw new IllegalStateException();
     }
 
     public boolean isSet(int fieldID) {
       return isSet(_Fields.findByThriftIdOrThrow(fieldID));
     }
 
     @Override
     public boolean equals(Object that) {
       if (that == null)
         return false;
       if (that instanceof describe_keyspace_args)
         return this.equals((describe_keyspace_args)that);
       return false;
     }
 
     public boolean equals(describe_keyspace_args that) {
       if (that == null)
         return false;
 
       boolean this_present_keyspace = true && this.isSetKeyspace();
       boolean that_present_keyspace = true && that.isSetKeyspace();
       if (this_present_keyspace || that_present_keyspace) {
         if (!(this_present_keyspace && that_present_keyspace))
           return false;
         if (!this.keyspace.equals(that.keyspace))
           return false;
       }
 
       return true;
     }
 
     @Override
     public int hashCode() {
       return 0;
     }
 
     public int compareTo(describe_keyspace_args other) {
       if (!getClass().equals(other.getClass())) {
         return getClass().getName().compareTo(other.getClass().getName());
       }
 
       int lastComparison = 0;
       describe_keyspace_args typedOther = (describe_keyspace_args)other;
 
       lastComparison = Boolean.valueOf(isSetKeyspace()).compareTo(typedOther.isSetKeyspace());
       if (lastComparison != 0) {
         return lastComparison;
       }
       if (isSetKeyspace()) {        lastComparison = TBaseHelper.compareTo(keyspace, typedOther.keyspace);
         if (lastComparison != 0) {
           return lastComparison;
         }
       }
       return 0;
     }
 
     public void read(TProtocol iprot) throws TException {
       TField field;
       iprot.readStructBegin();
       while (true)
       {
         field = iprot.readFieldBegin();
         if (field.type == TType.STOP) { 
           break;
         }
         switch (field.id) {
           case 1: // KEYSPACE
             if (field.type == TType.STRING) {
               this.keyspace = iprot.readString();
             } else { 
               TProtocolUtil.skip(iprot, field.type);
             }
             break;
           default:
             TProtocolUtil.skip(iprot, field.type);
         }
         iprot.readFieldEnd();
       }
       iprot.readStructEnd();
 
       // check for required fields of primitive type, which can't be checked in the validate method
       validate();
     }
 
     public void write(TProtocol oprot) throws TException {
       validate();
 
       oprot.writeStructBegin(STRUCT_DESC);
       if (this.keyspace != null) {
         oprot.writeFieldBegin(KEYSPACE_FIELD_DESC);
         oprot.writeString(this.keyspace);
         oprot.writeFieldEnd();
       }
       oprot.writeFieldStop();
       oprot.writeStructEnd();
     }
 
     @Override
     public String toString() {
       StringBuilder sb = new StringBuilder("describe_keyspace_args(");
       boolean first = true;
 
       sb.append("keyspace:");
       if (this.keyspace == null) {
         sb.append("null");
       } else {
         sb.append(this.keyspace);
       }
       first = false;
       sb.append(")");
       return sb.toString();
     }
 
     public void validate() throws TException {
       // check for required fields
       if (keyspace == null) {
         throw new TProtocolException("Required field 'keyspace' was not present! Struct: " + toString());
       }
     }
 
   }
 
   public static class describe_keyspace_result implements TBase<describe_keyspace_result._Fields>, java.io.Serializable, Cloneable   {
     private static final TStruct STRUCT_DESC = new TStruct("describe_keyspace_result");
 
     private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.MAP, (short)0);
     private static final TField NFE_FIELD_DESC = new TField("nfe", TType.STRUCT, (short)1);
 
     public Map<String,Map<String,String>> success;
     public NotFoundException nfe;
 
     /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
     public enum _Fields implements TFieldIdEnum {
       SUCCESS((short)0, "success"),
       NFE((short)1, "nfe");
 
       private static final Map<Integer, _Fields> byId = new HashMap<Integer, _Fields>();
       private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();
 
       static {
         for (_Fields field : EnumSet.allOf(_Fields.class)) {
           byId.put((int)field._thriftId, field);
           byName.put(field.getFieldName(), field);
         }
       }
 
       /**
        * Find the _Fields constant that matches fieldId, or null if its not found.
        */
       public static _Fields findByThriftId(int fieldId) {
         return byId.get(fieldId);
       }
 
       /**
        * Find the _Fields constant that matches fieldId, throwing an exception
        * if it is not found.
        */
       public static _Fields findByThriftIdOrThrow(int fieldId) {
         _Fields fields = findByThriftId(fieldId);
         if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
         return fields;
       }
 
       /**
        * Find the _Fields constant that matches name, or null if its not found.
        */
       public static _Fields findByName(String name) {
         return byName.get(name);
       }
 
       private final short _thriftId;
       private final String _fieldName;
 
       _Fields(short thriftId, String fieldName) {
         _thriftId = thriftId;
         _fieldName = fieldName;
       }
 
       public short getThriftFieldId() {
         return _thriftId;
       }
 
       public String getFieldName() {
         return _fieldName;
       }
     }
 
     // isset id assignments
 
     public static final Map<_Fields, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new EnumMap<_Fields, FieldMetaData>(_Fields.class) {{
       put(_Fields.SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
           new MapMetaData(TType.MAP, 
               new FieldValueMetaData(TType.STRING), 
               new MapMetaData(TType.MAP, 
                   new FieldValueMetaData(TType.STRING), 
                   new FieldValueMetaData(TType.STRING)))));
       put(_Fields.NFE, new FieldMetaData("nfe", TFieldRequirementType.DEFAULT, 
           new FieldValueMetaData(TType.STRUCT)));
     }});
 
     static {
       FieldMetaData.addStructMetaDataMap(describe_keyspace_result.class, metaDataMap);
     }
 
     public describe_keyspace_result() {
     }
 
     public describe_keyspace_result(
       Map<String,Map<String,String>> success,
       NotFoundException nfe)
     {
       this();
       this.success = success;
       this.nfe = nfe;
     }
 
     /**
      * Performs a deep copy on <i>other</i>.
      */
     public describe_keyspace_result(describe_keyspace_result other) {
       if (other.isSetSuccess()) {
         Map<String,Map<String,String>> __this__success = new HashMap<String,Map<String,String>>();
         for (Map.Entry<String, Map<String,String>> other_element : other.success.entrySet()) {
 
           String other_element_key = other_element.getKey();
           Map<String,String> other_element_value = other_element.getValue();
 
           String __this__success_copy_key = other_element_key;
 
           Map<String,String> __this__success_copy_value = new HashMap<String,String>();
           for (Map.Entry<String, String> other_element_value_element : other_element_value.entrySet()) {
 
             String other_element_value_element_key = other_element_value_element.getKey();
             String other_element_value_element_value = other_element_value_element.getValue();
 
             String __this__success_copy_value_copy_key = other_element_value_element_key;
 
             String __this__success_copy_value_copy_value = other_element_value_element_value;
 
             __this__success_copy_value.put(__this__success_copy_value_copy_key, __this__success_copy_value_copy_value);
           }
 
           __this__success.put(__this__success_copy_key, __this__success_copy_value);
         }
         this.success = __this__success;
       }
       if (other.isSetNfe()) {
         this.nfe = new NotFoundException(other.nfe);
       }
     }
 
     public describe_keyspace_result deepCopy() {
       return new describe_keyspace_result(this);
     }
 
     @Deprecated
     public describe_keyspace_result clone() {
       return new describe_keyspace_result(this);
     }
 
     public int getSuccessSize() {
       return (this.success == null) ? 0 : this.success.size();
     }
 
     public void putToSuccess(String key, Map<String,String> val) {
       if (this.success == null) {
         this.success = new HashMap<String,Map<String,String>>();
       }
       this.success.put(key, val);
     }
 
     public Map<String,Map<String,String>> getSuccess() {
       return this.success;
     }
 
     public describe_keyspace_result setSuccess(Map<String,Map<String,String>> success) {
       this.success = success;
       return this;
     }
 
     public void unsetSuccess() {
       this.success = null;
     }
 
     /** Returns true if field success is set (has been asigned a value) and false otherwise */
     public boolean isSetSuccess() {
       return this.success != null;
     }
 
     public void setSuccessIsSet(boolean value) {
       if (!value) {
         this.success = null;
       }
     }
 
     public NotFoundException getNfe() {
       return this.nfe;
     }
 
     public describe_keyspace_result setNfe(NotFoundException nfe) {
       this.nfe = nfe;
       return this;
     }
 
     public void unsetNfe() {
       this.nfe = null;
     }
 
     /** Returns true if field nfe is set (has been asigned a value) and false otherwise */
     public boolean isSetNfe() {
       return this.nfe != null;
     }
 
     public void setNfeIsSet(boolean value) {
       if (!value) {
         this.nfe = null;
       }
     }
 
     public void setFieldValue(_Fields field, Object value) {
       switch (field) {
       case SUCCESS:
         if (value == null) {
           unsetSuccess();
         } else {
           setSuccess((Map<String,Map<String,String>>)value);
         }
         break;
 
       case NFE:
         if (value == null) {
           unsetNfe();
         } else {
           setNfe((NotFoundException)value);
         }
         break;
 
       }
     }
 
     public void setFieldValue(int fieldID, Object value) {
       setFieldValue(_Fields.findByThriftIdOrThrow(fieldID), value);
     }
 
     public Object getFieldValue(_Fields field) {
       switch (field) {
       case SUCCESS:
         return getSuccess();
 
       case NFE:
         return getNfe();
 
       }
       throw new IllegalStateException();
     }
 
     public Object getFieldValue(int fieldId) {
       return getFieldValue(_Fields.findByThriftIdOrThrow(fieldId));
     }
 
     /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
     public boolean isSet(_Fields field) {
       switch (field) {
       case SUCCESS:
         return isSetSuccess();
       case NFE:
         return isSetNfe();
       }
       throw new IllegalStateException();
     }
 
     public boolean isSet(int fieldID) {
       return isSet(_Fields.findByThriftIdOrThrow(fieldID));
     }
 
     @Override
     public boolean equals(Object that) {
       if (that == null)
         return false;
       if (that instanceof describe_keyspace_result)
         return this.equals((describe_keyspace_result)that);
       return false;
     }
 
     public boolean equals(describe_keyspace_result that) {
       if (that == null)
         return false;
 
       boolean this_present_success = true && this.isSetSuccess();
       boolean that_present_success = true && that.isSetSuccess();
       if (this_present_success || that_present_success) {
         if (!(this_present_success && that_present_success))
           return false;
         if (!this.success.equals(that.success))
           return false;
       }
 
       boolean this_present_nfe = true && this.isSetNfe();
       boolean that_present_nfe = true && that.isSetNfe();
       if (this_present_nfe || that_present_nfe) {
         if (!(this_present_nfe && that_present_nfe))
           return false;
         if (!this.nfe.equals(that.nfe))
           return false;
       }
 
       return true;
     }
 
     @Override
     public int hashCode() {
       return 0;
     }
 
     public void read(TProtocol iprot) throws TException {
       TField field;
       iprot.readStructBegin();
       while (true)
       {
         field = iprot.readFieldBegin();
         if (field.type == TType.STOP) { 
           break;
         }
         switch (field.id) {
           case 0: // SUCCESS
             if (field.type == TType.MAP) {
               {
                TMap _map103 = iprot.readMapBegin();
                this.success = new HashMap<String,Map<String,String>>(2*_map103.size);
                for (int _i104 = 0; _i104 < _map103.size; ++_i104)
                {
                  String _key105;
                  Map<String,String> _val106;
                  _key105 = iprot.readString();
                  {
                    TMap _map107 = iprot.readMapBegin();
                    _val106 = new HashMap<String,String>(2*_map107.size);
                    for (int _i108 = 0; _i108 < _map107.size; ++_i108)
                    {
                      String _key109;
                      String _val110;
                      _key109 = iprot.readString();
                      _val110 = iprot.readString();
                      _val106.put(_key109, _val110);
                     }
                     iprot.readMapEnd();
                   }
                  this.success.put(_key105, _val106);
                 }
                 iprot.readMapEnd();
               }
             } else { 
               TProtocolUtil.skip(iprot, field.type);
             }
             break;
           case 1: // NFE
             if (field.type == TType.STRUCT) {
               this.nfe = new NotFoundException();
               this.nfe.read(iprot);
             } else { 
               TProtocolUtil.skip(iprot, field.type);
             }
             break;
           default:
             TProtocolUtil.skip(iprot, field.type);
         }
         iprot.readFieldEnd();
       }
       iprot.readStructEnd();
 
       // check for required fields of primitive type, which can't be checked in the validate method
       validate();
     }
 
     public void write(TProtocol oprot) throws TException {
       oprot.writeStructBegin(STRUCT_DESC);
 
       if (this.isSetSuccess()) {
         oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
         {
           oprot.writeMapBegin(new TMap(TType.STRING, TType.MAP, this.success.size()));
          for (Map.Entry<String, Map<String,String>> _iter111 : this.success.entrySet())
           {
            oprot.writeString(_iter111.getKey());
             {
              oprot.writeMapBegin(new TMap(TType.STRING, TType.STRING, _iter111.getValue().size()));
              for (Map.Entry<String, String> _iter112 : _iter111.getValue().entrySet())
               {
                oprot.writeString(_iter112.getKey());
                oprot.writeString(_iter112.getValue());
               }
               oprot.writeMapEnd();
             }
           }
           oprot.writeMapEnd();
         }
         oprot.writeFieldEnd();
       } else if (this.isSetNfe()) {
         oprot.writeFieldBegin(NFE_FIELD_DESC);
         this.nfe.write(oprot);
         oprot.writeFieldEnd();
       }
       oprot.writeFieldStop();
       oprot.writeStructEnd();
     }
 
     @Override
     public String toString() {
       StringBuilder sb = new StringBuilder("describe_keyspace_result(");
       boolean first = true;
 
       sb.append("success:");
       if (this.success == null) {
         sb.append("null");
       } else {
         sb.append(this.success);
       }
       first = false;
       if (!first) sb.append(", ");
       sb.append("nfe:");
       if (this.nfe == null) {
         sb.append("null");
       } else {
         sb.append(this.nfe);
       }
       first = false;
       sb.append(")");
       return sb.toString();
     }
 
     public void validate() throws TException {
       // check for required fields
     }
 
   }
 
   public static class describe_splits_args implements TBase<describe_splits_args._Fields>, java.io.Serializable, Cloneable, Comparable<describe_splits_args>   {
     private static final TStruct STRUCT_DESC = new TStruct("describe_splits_args");
 
     private static final TField START_TOKEN_FIELD_DESC = new TField("start_token", TType.STRING, (short)1);
     private static final TField END_TOKEN_FIELD_DESC = new TField("end_token", TType.STRING, (short)2);
     private static final TField KEYS_PER_SPLIT_FIELD_DESC = new TField("keys_per_split", TType.I32, (short)3);
 
     public String start_token;
     public String end_token;
     public int keys_per_split;
 
     /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
     public enum _Fields implements TFieldIdEnum {
       START_TOKEN((short)1, "start_token"),
       END_TOKEN((short)2, "end_token"),
       KEYS_PER_SPLIT((short)3, "keys_per_split");
 
       private static final Map<Integer, _Fields> byId = new HashMap<Integer, _Fields>();
       private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();
 
       static {
         for (_Fields field : EnumSet.allOf(_Fields.class)) {
           byId.put((int)field._thriftId, field);
           byName.put(field.getFieldName(), field);
         }
       }
 
       /**
        * Find the _Fields constant that matches fieldId, or null if its not found.
        */
       public static _Fields findByThriftId(int fieldId) {
         return byId.get(fieldId);
       }
 
       /**
        * Find the _Fields constant that matches fieldId, throwing an exception
        * if it is not found.
        */
       public static _Fields findByThriftIdOrThrow(int fieldId) {
         _Fields fields = findByThriftId(fieldId);
         if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
         return fields;
       }
 
       /**
        * Find the _Fields constant that matches name, or null if its not found.
        */
       public static _Fields findByName(String name) {
         return byName.get(name);
       }
 
       private final short _thriftId;
       private final String _fieldName;
 
       _Fields(short thriftId, String fieldName) {
         _thriftId = thriftId;
         _fieldName = fieldName;
       }
 
       public short getThriftFieldId() {
         return _thriftId;
       }
 
       public String getFieldName() {
         return _fieldName;
       }
     }
 
     // isset id assignments
     private static final int __KEYS_PER_SPLIT_ISSET_ID = 0;
     private BitSet __isset_bit_vector = new BitSet(1);
 
     public static final Map<_Fields, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new EnumMap<_Fields, FieldMetaData>(_Fields.class) {{
       put(_Fields.START_TOKEN, new FieldMetaData("start_token", TFieldRequirementType.REQUIRED, 
           new FieldValueMetaData(TType.STRING)));
       put(_Fields.END_TOKEN, new FieldMetaData("end_token", TFieldRequirementType.REQUIRED, 
           new FieldValueMetaData(TType.STRING)));
       put(_Fields.KEYS_PER_SPLIT, new FieldMetaData("keys_per_split", TFieldRequirementType.REQUIRED, 
           new FieldValueMetaData(TType.I32)));
     }});
 
     static {
       FieldMetaData.addStructMetaDataMap(describe_splits_args.class, metaDataMap);
     }
 
     public describe_splits_args() {
     }
 
     public describe_splits_args(
       String start_token,
       String end_token,
       int keys_per_split)
     {
       this();
       this.start_token = start_token;
       this.end_token = end_token;
       this.keys_per_split = keys_per_split;
       setKeys_per_splitIsSet(true);
     }
 
     /**
      * Performs a deep copy on <i>other</i>.
      */
     public describe_splits_args(describe_splits_args other) {
       __isset_bit_vector.clear();
       __isset_bit_vector.or(other.__isset_bit_vector);
       if (other.isSetStart_token()) {
         this.start_token = other.start_token;
       }
       if (other.isSetEnd_token()) {
         this.end_token = other.end_token;
       }
       this.keys_per_split = other.keys_per_split;
     }
 
     public describe_splits_args deepCopy() {
       return new describe_splits_args(this);
     }
 
     @Deprecated
     public describe_splits_args clone() {
       return new describe_splits_args(this);
     }
 
     public String getStart_token() {
       return this.start_token;
     }
 
     public describe_splits_args setStart_token(String start_token) {
       this.start_token = start_token;
       return this;
     }
 
     public void unsetStart_token() {
       this.start_token = null;
     }
 
     /** Returns true if field start_token is set (has been asigned a value) and false otherwise */
     public boolean isSetStart_token() {
       return this.start_token != null;
     }
 
     public void setStart_tokenIsSet(boolean value) {
       if (!value) {
         this.start_token = null;
       }
     }
 
     public String getEnd_token() {
       return this.end_token;
     }
 
     public describe_splits_args setEnd_token(String end_token) {
       this.end_token = end_token;
       return this;
     }
 
     public void unsetEnd_token() {
       this.end_token = null;
     }
 
     /** Returns true if field end_token is set (has been asigned a value) and false otherwise */
     public boolean isSetEnd_token() {
       return this.end_token != null;
     }
 
     public void setEnd_tokenIsSet(boolean value) {
       if (!value) {
         this.end_token = null;
       }
     }
 
     public int getKeys_per_split() {
       return this.keys_per_split;
     }
 
     public describe_splits_args setKeys_per_split(int keys_per_split) {
       this.keys_per_split = keys_per_split;
       setKeys_per_splitIsSet(true);
       return this;
     }
 
     public void unsetKeys_per_split() {
       __isset_bit_vector.clear(__KEYS_PER_SPLIT_ISSET_ID);
     }
 
     /** Returns true if field keys_per_split is set (has been asigned a value) and false otherwise */
     public boolean isSetKeys_per_split() {
       return __isset_bit_vector.get(__KEYS_PER_SPLIT_ISSET_ID);
     }
 
     public void setKeys_per_splitIsSet(boolean value) {
       __isset_bit_vector.set(__KEYS_PER_SPLIT_ISSET_ID, value);
     }
 
     public void setFieldValue(_Fields field, Object value) {
       switch (field) {
       case START_TOKEN:
         if (value == null) {
           unsetStart_token();
         } else {
           setStart_token((String)value);
         }
         break;
 
       case END_TOKEN:
         if (value == null) {
           unsetEnd_token();
         } else {
           setEnd_token((String)value);
         }
         break;
 
       case KEYS_PER_SPLIT:
         if (value == null) {
           unsetKeys_per_split();
         } else {
           setKeys_per_split((Integer)value);
         }
         break;
 
       }
     }
 
     public void setFieldValue(int fieldID, Object value) {
       setFieldValue(_Fields.findByThriftIdOrThrow(fieldID), value);
     }
 
     public Object getFieldValue(_Fields field) {
       switch (field) {
       case START_TOKEN:
         return getStart_token();
 
       case END_TOKEN:
         return getEnd_token();
 
       case KEYS_PER_SPLIT:
         return new Integer(getKeys_per_split());
 
       }
       throw new IllegalStateException();
     }
 
     public Object getFieldValue(int fieldId) {
       return getFieldValue(_Fields.findByThriftIdOrThrow(fieldId));
     }
 
     /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
     public boolean isSet(_Fields field) {
       switch (field) {
       case START_TOKEN:
         return isSetStart_token();
       case END_TOKEN:
         return isSetEnd_token();
       case KEYS_PER_SPLIT:
         return isSetKeys_per_split();
       }
       throw new IllegalStateException();
     }
 
     public boolean isSet(int fieldID) {
       return isSet(_Fields.findByThriftIdOrThrow(fieldID));
     }
 
     @Override
     public boolean equals(Object that) {
       if (that == null)
         return false;
       if (that instanceof describe_splits_args)
         return this.equals((describe_splits_args)that);
       return false;
     }
 
     public boolean equals(describe_splits_args that) {
       if (that == null)
         return false;
 
       boolean this_present_start_token = true && this.isSetStart_token();
       boolean that_present_start_token = true && that.isSetStart_token();
       if (this_present_start_token || that_present_start_token) {
         if (!(this_present_start_token && that_present_start_token))
           return false;
         if (!this.start_token.equals(that.start_token))
           return false;
       }
 
       boolean this_present_end_token = true && this.isSetEnd_token();
       boolean that_present_end_token = true && that.isSetEnd_token();
       if (this_present_end_token || that_present_end_token) {
         if (!(this_present_end_token && that_present_end_token))
           return false;
         if (!this.end_token.equals(that.end_token))
           return false;
       }
 
       boolean this_present_keys_per_split = true;
       boolean that_present_keys_per_split = true;
       if (this_present_keys_per_split || that_present_keys_per_split) {
         if (!(this_present_keys_per_split && that_present_keys_per_split))
           return false;
         if (this.keys_per_split != that.keys_per_split)
           return false;
       }
 
       return true;
     }
 
     @Override
     public int hashCode() {
       return 0;
     }
 
     public int compareTo(describe_splits_args other) {
       if (!getClass().equals(other.getClass())) {
         return getClass().getName().compareTo(other.getClass().getName());
       }
 
       int lastComparison = 0;
       describe_splits_args typedOther = (describe_splits_args)other;
 
       lastComparison = Boolean.valueOf(isSetStart_token()).compareTo(typedOther.isSetStart_token());
       if (lastComparison != 0) {
         return lastComparison;
       }
       if (isSetStart_token()) {        lastComparison = TBaseHelper.compareTo(start_token, typedOther.start_token);
         if (lastComparison != 0) {
           return lastComparison;
         }
       }
       lastComparison = Boolean.valueOf(isSetEnd_token()).compareTo(typedOther.isSetEnd_token());
       if (lastComparison != 0) {
         return lastComparison;
       }
       if (isSetEnd_token()) {        lastComparison = TBaseHelper.compareTo(end_token, typedOther.end_token);
         if (lastComparison != 0) {
           return lastComparison;
         }
       }
       lastComparison = Boolean.valueOf(isSetKeys_per_split()).compareTo(typedOther.isSetKeys_per_split());
       if (lastComparison != 0) {
         return lastComparison;
       }
       if (isSetKeys_per_split()) {        lastComparison = TBaseHelper.compareTo(keys_per_split, typedOther.keys_per_split);
         if (lastComparison != 0) {
           return lastComparison;
         }
       }
       return 0;
     }
 
     public void read(TProtocol iprot) throws TException {
       TField field;
       iprot.readStructBegin();
       while (true)
       {
         field = iprot.readFieldBegin();
         if (field.type == TType.STOP) { 
           break;
         }
         switch (field.id) {
           case 1: // START_TOKEN
             if (field.type == TType.STRING) {
               this.start_token = iprot.readString();
             } else { 
               TProtocolUtil.skip(iprot, field.type);
             }
             break;
           case 2: // END_TOKEN
             if (field.type == TType.STRING) {
               this.end_token = iprot.readString();
             } else { 
               TProtocolUtil.skip(iprot, field.type);
             }
             break;
           case 3: // KEYS_PER_SPLIT
             if (field.type == TType.I32) {
               this.keys_per_split = iprot.readI32();
               setKeys_per_splitIsSet(true);
             } else { 
               TProtocolUtil.skip(iprot, field.type);
             }
             break;
           default:
             TProtocolUtil.skip(iprot, field.type);
         }
         iprot.readFieldEnd();
       }
       iprot.readStructEnd();
 
       // check for required fields of primitive type, which can't be checked in the validate method
       if (!isSetKeys_per_split()) {
         throw new TProtocolException("Required field 'keys_per_split' was not found in serialized data! Struct: " + toString());
       }
       validate();
     }
 
     public void write(TProtocol oprot) throws TException {
       validate();
 
       oprot.writeStructBegin(STRUCT_DESC);
       if (this.start_token != null) {
         oprot.writeFieldBegin(START_TOKEN_FIELD_DESC);
         oprot.writeString(this.start_token);
         oprot.writeFieldEnd();
       }
       if (this.end_token != null) {
         oprot.writeFieldBegin(END_TOKEN_FIELD_DESC);
         oprot.writeString(this.end_token);
         oprot.writeFieldEnd();
       }
       oprot.writeFieldBegin(KEYS_PER_SPLIT_FIELD_DESC);
       oprot.writeI32(this.keys_per_split);
       oprot.writeFieldEnd();
       oprot.writeFieldStop();
       oprot.writeStructEnd();
     }
 
     @Override
     public String toString() {
       StringBuilder sb = new StringBuilder("describe_splits_args(");
       boolean first = true;
 
       sb.append("start_token:");
       if (this.start_token == null) {
         sb.append("null");
       } else {
         sb.append(this.start_token);
       }
       first = false;
       if (!first) sb.append(", ");
       sb.append("end_token:");
       if (this.end_token == null) {
         sb.append("null");
       } else {
         sb.append(this.end_token);
       }
       first = false;
       if (!first) sb.append(", ");
       sb.append("keys_per_split:");
       sb.append(this.keys_per_split);
       first = false;
       sb.append(")");
       return sb.toString();
     }
 
     public void validate() throws TException {
       // check for required fields
       if (start_token == null) {
         throw new TProtocolException("Required field 'start_token' was not present! Struct: " + toString());
       }
       if (end_token == null) {
         throw new TProtocolException("Required field 'end_token' was not present! Struct: " + toString());
       }
       // alas, we cannot check 'keys_per_split' because it's a primitive and you chose the non-beans generator.
     }
 
   }
 
   public static class describe_splits_result implements TBase<describe_splits_result._Fields>, java.io.Serializable, Cloneable, Comparable<describe_splits_result>   {
     private static final TStruct STRUCT_DESC = new TStruct("describe_splits_result");
 
     private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.LIST, (short)0);
 
     public List<String> success;
 
     /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
     public enum _Fields implements TFieldIdEnum {
       SUCCESS((short)0, "success");
 
       private static final Map<Integer, _Fields> byId = new HashMap<Integer, _Fields>();
       private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();
 
       static {
         for (_Fields field : EnumSet.allOf(_Fields.class)) {
           byId.put((int)field._thriftId, field);
           byName.put(field.getFieldName(), field);
         }
       }
 
       /**
        * Find the _Fields constant that matches fieldId, or null if its not found.
        */
       public static _Fields findByThriftId(int fieldId) {
         return byId.get(fieldId);
       }
 
       /**
        * Find the _Fields constant that matches fieldId, throwing an exception
        * if it is not found.
        */
       public static _Fields findByThriftIdOrThrow(int fieldId) {
         _Fields fields = findByThriftId(fieldId);
         if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
         return fields;
       }
 
       /**
        * Find the _Fields constant that matches name, or null if its not found.
        */
       public static _Fields findByName(String name) {
         return byName.get(name);
       }
 
       private final short _thriftId;
       private final String _fieldName;
 
       _Fields(short thriftId, String fieldName) {
         _thriftId = thriftId;
         _fieldName = fieldName;
       }
 
       public short getThriftFieldId() {
         return _thriftId;
       }
 
       public String getFieldName() {
         return _fieldName;
       }
     }
 
     // isset id assignments
 
     public static final Map<_Fields, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new EnumMap<_Fields, FieldMetaData>(_Fields.class) {{
       put(_Fields.SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
           new ListMetaData(TType.LIST, 
               new FieldValueMetaData(TType.STRING))));
     }});
 
     static {
       FieldMetaData.addStructMetaDataMap(describe_splits_result.class, metaDataMap);
     }
 
     public describe_splits_result() {
     }
 
     public describe_splits_result(
       List<String> success)
     {
       this();
       this.success = success;
     }
 
     /**
      * Performs a deep copy on <i>other</i>.
      */
     public describe_splits_result(describe_splits_result other) {
       if (other.isSetSuccess()) {
         List<String> __this__success = new ArrayList<String>();
         for (String other_element : other.success) {
           __this__success.add(other_element);
         }
         this.success = __this__success;
       }
     }
 
     public describe_splits_result deepCopy() {
       return new describe_splits_result(this);
     }
 
     @Deprecated
     public describe_splits_result clone() {
       return new describe_splits_result(this);
     }
 
     public int getSuccessSize() {
       return (this.success == null) ? 0 : this.success.size();
     }
 
     public java.util.Iterator<String> getSuccessIterator() {
       return (this.success == null) ? null : this.success.iterator();
     }
 
     public void addToSuccess(String elem) {
       if (this.success == null) {
         this.success = new ArrayList<String>();
       }
       this.success.add(elem);
     }
 
     public List<String> getSuccess() {
       return this.success;
     }
 
     public describe_splits_result setSuccess(List<String> success) {
       this.success = success;
       return this;
     }
 
     public void unsetSuccess() {
       this.success = null;
     }
 
     /** Returns true if field success is set (has been asigned a value) and false otherwise */
     public boolean isSetSuccess() {
       return this.success != null;
     }
 
     public void setSuccessIsSet(boolean value) {
       if (!value) {
         this.success = null;
       }
     }
 
     public void setFieldValue(_Fields field, Object value) {
       switch (field) {
       case SUCCESS:
         if (value == null) {
           unsetSuccess();
         } else {
           setSuccess((List<String>)value);
         }
         break;
 
       }
     }
 
     public void setFieldValue(int fieldID, Object value) {
       setFieldValue(_Fields.findByThriftIdOrThrow(fieldID), value);
     }
 
     public Object getFieldValue(_Fields field) {
       switch (field) {
       case SUCCESS:
         return getSuccess();
 
       }
       throw new IllegalStateException();
     }
 
     public Object getFieldValue(int fieldId) {
       return getFieldValue(_Fields.findByThriftIdOrThrow(fieldId));
     }
 
     /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
     public boolean isSet(_Fields field) {
       switch (field) {
       case SUCCESS:
         return isSetSuccess();
       }
       throw new IllegalStateException();
     }
 
     public boolean isSet(int fieldID) {
       return isSet(_Fields.findByThriftIdOrThrow(fieldID));
     }
 
     @Override
     public boolean equals(Object that) {
       if (that == null)
         return false;
       if (that instanceof describe_splits_result)
         return this.equals((describe_splits_result)that);
       return false;
     }
 
     public boolean equals(describe_splits_result that) {
       if (that == null)
         return false;
 
       boolean this_present_success = true && this.isSetSuccess();
       boolean that_present_success = true && that.isSetSuccess();
       if (this_present_success || that_present_success) {
         if (!(this_present_success && that_present_success))
           return false;
         if (!this.success.equals(that.success))
           return false;
       }
 
       return true;
     }
 
     @Override
     public int hashCode() {
       return 0;
     }
 
     public int compareTo(describe_splits_result other) {
       if (!getClass().equals(other.getClass())) {
         return getClass().getName().compareTo(other.getClass().getName());
       }
 
       int lastComparison = 0;
       describe_splits_result typedOther = (describe_splits_result)other;
 
       lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(typedOther.isSetSuccess());
       if (lastComparison != 0) {
         return lastComparison;
       }
       if (isSetSuccess()) {        lastComparison = TBaseHelper.compareTo(success, typedOther.success);
         if (lastComparison != 0) {
           return lastComparison;
         }
       }
       return 0;
     }
 
     public void read(TProtocol iprot) throws TException {
       TField field;
       iprot.readStructBegin();
       while (true)
       {
         field = iprot.readFieldBegin();
         if (field.type == TType.STOP) { 
           break;
         }
         switch (field.id) {
           case 0: // SUCCESS
             if (field.type == TType.LIST) {
               {
                TList _list113 = iprot.readListBegin();
                this.success = new ArrayList<String>(_list113.size);
                for (int _i114 = 0; _i114 < _list113.size; ++_i114)
                {
                  String _elem115;
                  _elem115 = iprot.readString();
                  this.success.add(_elem115);
                 }
                 iprot.readListEnd();
               }
             } else { 
               TProtocolUtil.skip(iprot, field.type);
             }
             break;
           default:
             TProtocolUtil.skip(iprot, field.type);
         }
         iprot.readFieldEnd();
       }
       iprot.readStructEnd();
 
       // check for required fields of primitive type, which can't be checked in the validate method
       validate();
     }
 
     public void write(TProtocol oprot) throws TException {
       oprot.writeStructBegin(STRUCT_DESC);
 
       if (this.isSetSuccess()) {
         oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
         {
           oprot.writeListBegin(new TList(TType.STRING, this.success.size()));
          for (String _iter116 : this.success)
           {
            oprot.writeString(_iter116);
           }
           oprot.writeListEnd();
         }
         oprot.writeFieldEnd();
       }
       oprot.writeFieldStop();
       oprot.writeStructEnd();
     }
 
     @Override
     public String toString() {
       StringBuilder sb = new StringBuilder("describe_splits_result(");
       boolean first = true;
 
       sb.append("success:");
       if (this.success == null) {
         sb.append("null");
       } else {
         sb.append(this.success);
       }
       first = false;
       sb.append(")");
       return sb.toString();
     }
 
     public void validate() throws TException {
       // check for required fields
     }
 
   }
 
   public static class system_add_column_family_args implements TBase<system_add_column_family_args._Fields>, java.io.Serializable, Cloneable, Comparable<system_add_column_family_args>   {
     private static final TStruct STRUCT_DESC = new TStruct("system_add_column_family_args");
 
     private static final TField CF_DEF_FIELD_DESC = new TField("cf_def", TType.STRUCT, (short)1);
 
     public CfDef cf_def;
 
     /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
     public enum _Fields implements TFieldIdEnum {
       CF_DEF((short)1, "cf_def");
 
       private static final Map<Integer, _Fields> byId = new HashMap<Integer, _Fields>();
       private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();
 
       static {
         for (_Fields field : EnumSet.allOf(_Fields.class)) {
           byId.put((int)field._thriftId, field);
           byName.put(field.getFieldName(), field);
         }
       }
 
       /**
        * Find the _Fields constant that matches fieldId, or null if its not found.
        */
       public static _Fields findByThriftId(int fieldId) {
         return byId.get(fieldId);
       }
 
       /**
        * Find the _Fields constant that matches fieldId, throwing an exception
        * if it is not found.
        */
       public static _Fields findByThriftIdOrThrow(int fieldId) {
         _Fields fields = findByThriftId(fieldId);
         if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
         return fields;
       }
 
       /**
        * Find the _Fields constant that matches name, or null if its not found.
        */
       public static _Fields findByName(String name) {
         return byName.get(name);
       }
 
       private final short _thriftId;
       private final String _fieldName;
 
       _Fields(short thriftId, String fieldName) {
         _thriftId = thriftId;
         _fieldName = fieldName;
       }
 
       public short getThriftFieldId() {
         return _thriftId;
       }
 
       public String getFieldName() {
         return _fieldName;
       }
     }
 
     // isset id assignments
 
     public static final Map<_Fields, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new EnumMap<_Fields, FieldMetaData>(_Fields.class) {{
       put(_Fields.CF_DEF, new FieldMetaData("cf_def", TFieldRequirementType.REQUIRED, 
           new StructMetaData(TType.STRUCT, CfDef.class)));
     }});
 
     static {
       FieldMetaData.addStructMetaDataMap(system_add_column_family_args.class, metaDataMap);
     }
 
     public system_add_column_family_args() {
     }
 
     public system_add_column_family_args(
       CfDef cf_def)
     {
       this();
       this.cf_def = cf_def;
     }
 
     /**
      * Performs a deep copy on <i>other</i>.
      */
     public system_add_column_family_args(system_add_column_family_args other) {
       if (other.isSetCf_def()) {
         this.cf_def = new CfDef(other.cf_def);
       }
     }
 
     public system_add_column_family_args deepCopy() {
       return new system_add_column_family_args(this);
     }
 
     @Deprecated
     public system_add_column_family_args clone() {
       return new system_add_column_family_args(this);
     }
 
     public CfDef getCf_def() {
       return this.cf_def;
     }
 
     public system_add_column_family_args setCf_def(CfDef cf_def) {
       this.cf_def = cf_def;
       return this;
     }
 
     public void unsetCf_def() {
       this.cf_def = null;
     }
 
     /** Returns true if field cf_def is set (has been asigned a value) and false otherwise */
     public boolean isSetCf_def() {
       return this.cf_def != null;
     }
 
     public void setCf_defIsSet(boolean value) {
       if (!value) {
         this.cf_def = null;
       }
     }
 
     public void setFieldValue(_Fields field, Object value) {
       switch (field) {
       case CF_DEF:
         if (value == null) {
           unsetCf_def();
         } else {
           setCf_def((CfDef)value);
         }
         break;
 
       }
     }
 
     public void setFieldValue(int fieldID, Object value) {
       setFieldValue(_Fields.findByThriftIdOrThrow(fieldID), value);
     }
 
     public Object getFieldValue(_Fields field) {
       switch (field) {
       case CF_DEF:
         return getCf_def();
 
       }
       throw new IllegalStateException();
     }
 
     public Object getFieldValue(int fieldId) {
       return getFieldValue(_Fields.findByThriftIdOrThrow(fieldId));
     }
 
     /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
     public boolean isSet(_Fields field) {
       switch (field) {
       case CF_DEF:
         return isSetCf_def();
       }
       throw new IllegalStateException();
     }
 
     public boolean isSet(int fieldID) {
       return isSet(_Fields.findByThriftIdOrThrow(fieldID));
     }
 
     @Override
     public boolean equals(Object that) {
       if (that == null)
         return false;
       if (that instanceof system_add_column_family_args)
         return this.equals((system_add_column_family_args)that);
       return false;
     }
 
     public boolean equals(system_add_column_family_args that) {
       if (that == null)
         return false;
 
       boolean this_present_cf_def = true && this.isSetCf_def();
       boolean that_present_cf_def = true && that.isSetCf_def();
       if (this_present_cf_def || that_present_cf_def) {
         if (!(this_present_cf_def && that_present_cf_def))
           return false;
         if (!this.cf_def.equals(that.cf_def))
           return false;
       }
 
       return true;
     }
 
     @Override
     public int hashCode() {
       return 0;
     }
 
     public int compareTo(system_add_column_family_args other) {
       if (!getClass().equals(other.getClass())) {
         return getClass().getName().compareTo(other.getClass().getName());
       }
 
       int lastComparison = 0;
       system_add_column_family_args typedOther = (system_add_column_family_args)other;
 
       lastComparison = Boolean.valueOf(isSetCf_def()).compareTo(typedOther.isSetCf_def());
       if (lastComparison != 0) {
         return lastComparison;
       }
       if (isSetCf_def()) {        lastComparison = TBaseHelper.compareTo(cf_def, typedOther.cf_def);
         if (lastComparison != 0) {
           return lastComparison;
         }
       }
       return 0;
     }
 
     public void read(TProtocol iprot) throws TException {
       TField field;
       iprot.readStructBegin();
       while (true)
       {
         field = iprot.readFieldBegin();
         if (field.type == TType.STOP) { 
           break;
         }
         switch (field.id) {
           case 1: // CF_DEF
             if (field.type == TType.STRUCT) {
               this.cf_def = new CfDef();
               this.cf_def.read(iprot);
             } else { 
               TProtocolUtil.skip(iprot, field.type);
             }
             break;
           default:
             TProtocolUtil.skip(iprot, field.type);
         }
         iprot.readFieldEnd();
       }
       iprot.readStructEnd();
 
       // check for required fields of primitive type, which can't be checked in the validate method
       validate();
     }
 
     public void write(TProtocol oprot) throws TException {
       validate();
 
       oprot.writeStructBegin(STRUCT_DESC);
       if (this.cf_def != null) {
         oprot.writeFieldBegin(CF_DEF_FIELD_DESC);
         this.cf_def.write(oprot);
         oprot.writeFieldEnd();
       }
       oprot.writeFieldStop();
       oprot.writeStructEnd();
     }
 
     @Override
     public String toString() {
       StringBuilder sb = new StringBuilder("system_add_column_family_args(");
       boolean first = true;
 
       sb.append("cf_def:");
       if (this.cf_def == null) {
         sb.append("null");
       } else {
         sb.append(this.cf_def);
       }
       first = false;
       sb.append(")");
       return sb.toString();
     }
 
     public void validate() throws TException {
       // check for required fields
       if (cf_def == null) {
         throw new TProtocolException("Required field 'cf_def' was not present! Struct: " + toString());
       }
     }
 
   }
 
   public static class system_add_column_family_result implements TBase<system_add_column_family_result._Fields>, java.io.Serializable, Cloneable, Comparable<system_add_column_family_result>   {
     private static final TStruct STRUCT_DESC = new TStruct("system_add_column_family_result");
 
     private static final TField IRE_FIELD_DESC = new TField("ire", TType.STRUCT, (short)1);
 
     public InvalidRequestException ire;
 
     /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
     public enum _Fields implements TFieldIdEnum {
       IRE((short)1, "ire");
 
       private static final Map<Integer, _Fields> byId = new HashMap<Integer, _Fields>();
       private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();
 
       static {
         for (_Fields field : EnumSet.allOf(_Fields.class)) {
           byId.put((int)field._thriftId, field);
           byName.put(field.getFieldName(), field);
         }
       }
 
       /**
        * Find the _Fields constant that matches fieldId, or null if its not found.
        */
       public static _Fields findByThriftId(int fieldId) {
         return byId.get(fieldId);
       }
 
       /**
        * Find the _Fields constant that matches fieldId, throwing an exception
        * if it is not found.
        */
       public static _Fields findByThriftIdOrThrow(int fieldId) {
         _Fields fields = findByThriftId(fieldId);
         if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
         return fields;
       }
 
       /**
        * Find the _Fields constant that matches name, or null if its not found.
        */
       public static _Fields findByName(String name) {
         return byName.get(name);
       }
 
       private final short _thriftId;
       private final String _fieldName;
 
       _Fields(short thriftId, String fieldName) {
         _thriftId = thriftId;
         _fieldName = fieldName;
       }
 
       public short getThriftFieldId() {
         return _thriftId;
       }
 
       public String getFieldName() {
         return _fieldName;
       }
     }
 
     // isset id assignments
 
     public static final Map<_Fields, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new EnumMap<_Fields, FieldMetaData>(_Fields.class) {{
       put(_Fields.IRE, new FieldMetaData("ire", TFieldRequirementType.DEFAULT, 
           new FieldValueMetaData(TType.STRUCT)));
     }});
 
     static {
       FieldMetaData.addStructMetaDataMap(system_add_column_family_result.class, metaDataMap);
     }
 
     public system_add_column_family_result() {
     }
 
     public system_add_column_family_result(
       InvalidRequestException ire)
     {
       this();
       this.ire = ire;
     }
 
     /**
      * Performs a deep copy on <i>other</i>.
      */
     public system_add_column_family_result(system_add_column_family_result other) {
       if (other.isSetIre()) {
         this.ire = new InvalidRequestException(other.ire);
       }
     }
 
     public system_add_column_family_result deepCopy() {
       return new system_add_column_family_result(this);
     }
 
     @Deprecated
     public system_add_column_family_result clone() {
       return new system_add_column_family_result(this);
     }
 
     public InvalidRequestException getIre() {
       return this.ire;
     }
 
     public system_add_column_family_result setIre(InvalidRequestException ire) {
       this.ire = ire;
       return this;
     }
 
     public void unsetIre() {
       this.ire = null;
     }
 
     /** Returns true if field ire is set (has been asigned a value) and false otherwise */
     public boolean isSetIre() {
       return this.ire != null;
     }
 
     public void setIreIsSet(boolean value) {
       if (!value) {
         this.ire = null;
       }
     }
 
     public void setFieldValue(_Fields field, Object value) {
       switch (field) {
       case IRE:
         if (value == null) {
           unsetIre();
         } else {
           setIre((InvalidRequestException)value);
         }
         break;
 
       }
     }
 
     public void setFieldValue(int fieldID, Object value) {
       setFieldValue(_Fields.findByThriftIdOrThrow(fieldID), value);
     }
 
     public Object getFieldValue(_Fields field) {
       switch (field) {
       case IRE:
         return getIre();
 
       }
       throw new IllegalStateException();
     }
 
     public Object getFieldValue(int fieldId) {
       return getFieldValue(_Fields.findByThriftIdOrThrow(fieldId));
     }
 
     /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
     public boolean isSet(_Fields field) {
       switch (field) {
       case IRE:
         return isSetIre();
       }
       throw new IllegalStateException();
     }
 
     public boolean isSet(int fieldID) {
       return isSet(_Fields.findByThriftIdOrThrow(fieldID));
     }
 
     @Override
     public boolean equals(Object that) {
       if (that == null)
         return false;
       if (that instanceof system_add_column_family_result)
         return this.equals((system_add_column_family_result)that);
       return false;
     }
 
     public boolean equals(system_add_column_family_result that) {
       if (that == null)
         return false;
 
       boolean this_present_ire = true && this.isSetIre();
       boolean that_present_ire = true && that.isSetIre();
       if (this_present_ire || that_present_ire) {
         if (!(this_present_ire && that_present_ire))
           return false;
         if (!this.ire.equals(that.ire))
           return false;
       }
 
       return true;
     }
 
     @Override
     public int hashCode() {
       return 0;
     }
 
     public int compareTo(system_add_column_family_result other) {
       if (!getClass().equals(other.getClass())) {
         return getClass().getName().compareTo(other.getClass().getName());
       }
 
       int lastComparison = 0;
       system_add_column_family_result typedOther = (system_add_column_family_result)other;
 
       lastComparison = Boolean.valueOf(isSetIre()).compareTo(typedOther.isSetIre());
       if (lastComparison != 0) {
         return lastComparison;
       }
       if (isSetIre()) {        lastComparison = TBaseHelper.compareTo(ire, typedOther.ire);
         if (lastComparison != 0) {
           return lastComparison;
         }
       }
       return 0;
     }
 
     public void read(TProtocol iprot) throws TException {
       TField field;
       iprot.readStructBegin();
       while (true)
       {
         field = iprot.readFieldBegin();
         if (field.type == TType.STOP) { 
           break;
         }
         switch (field.id) {
           case 1: // IRE
             if (field.type == TType.STRUCT) {
               this.ire = new InvalidRequestException();
               this.ire.read(iprot);
             } else { 
               TProtocolUtil.skip(iprot, field.type);
             }
             break;
           default:
             TProtocolUtil.skip(iprot, field.type);
         }
         iprot.readFieldEnd();
       }
       iprot.readStructEnd();
 
       // check for required fields of primitive type, which can't be checked in the validate method
       validate();
     }
 
     public void write(TProtocol oprot) throws TException {
       oprot.writeStructBegin(STRUCT_DESC);
 
       if (this.isSetIre()) {
         oprot.writeFieldBegin(IRE_FIELD_DESC);
         this.ire.write(oprot);
         oprot.writeFieldEnd();
       }
       oprot.writeFieldStop();
       oprot.writeStructEnd();
     }
 
     @Override
     public String toString() {
       StringBuilder sb = new StringBuilder("system_add_column_family_result(");
       boolean first = true;
 
       sb.append("ire:");
       if (this.ire == null) {
         sb.append("null");
       } else {
         sb.append(this.ire);
       }
       first = false;
       sb.append(")");
       return sb.toString();
     }
 
     public void validate() throws TException {
       // check for required fields
     }
 
   }
 
   public static class system_drop_column_family_args implements TBase<system_drop_column_family_args._Fields>, java.io.Serializable, Cloneable, Comparable<system_drop_column_family_args>   {
     private static final TStruct STRUCT_DESC = new TStruct("system_drop_column_family_args");
 
     private static final TField KEYSPACE_FIELD_DESC = new TField("keyspace", TType.STRING, (short)1);
     private static final TField COLUMN_FAMILY_FIELD_DESC = new TField("column_family", TType.STRING, (short)2);
 
     public String keyspace;
     public String column_family;
 
     /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
     public enum _Fields implements TFieldIdEnum {
       KEYSPACE((short)1, "keyspace"),
       COLUMN_FAMILY((short)2, "column_family");
 
       private static final Map<Integer, _Fields> byId = new HashMap<Integer, _Fields>();
       private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();
 
       static {
         for (_Fields field : EnumSet.allOf(_Fields.class)) {
           byId.put((int)field._thriftId, field);
           byName.put(field.getFieldName(), field);
         }
       }
 
       /**
        * Find the _Fields constant that matches fieldId, or null if its not found.
        */
       public static _Fields findByThriftId(int fieldId) {
         return byId.get(fieldId);
       }
 
       /**
        * Find the _Fields constant that matches fieldId, throwing an exception
        * if it is not found.
        */
       public static _Fields findByThriftIdOrThrow(int fieldId) {
         _Fields fields = findByThriftId(fieldId);
         if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
         return fields;
       }
 
       /**
        * Find the _Fields constant that matches name, or null if its not found.
        */
       public static _Fields findByName(String name) {
         return byName.get(name);
       }
 
       private final short _thriftId;
       private final String _fieldName;
 
       _Fields(short thriftId, String fieldName) {
         _thriftId = thriftId;
         _fieldName = fieldName;
       }
 
       public short getThriftFieldId() {
         return _thriftId;
       }
 
       public String getFieldName() {
         return _fieldName;
       }
     }
 
     // isset id assignments
 
     public static final Map<_Fields, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new EnumMap<_Fields, FieldMetaData>(_Fields.class) {{
       put(_Fields.KEYSPACE, new FieldMetaData("keyspace", TFieldRequirementType.REQUIRED, 
           new FieldValueMetaData(TType.STRING)));
       put(_Fields.COLUMN_FAMILY, new FieldMetaData("column_family", TFieldRequirementType.REQUIRED, 
           new FieldValueMetaData(TType.STRING)));
     }});
 
     static {
       FieldMetaData.addStructMetaDataMap(system_drop_column_family_args.class, metaDataMap);
     }
 
     public system_drop_column_family_args() {
     }
 
     public system_drop_column_family_args(
       String keyspace,
       String column_family)
     {
       this();
       this.keyspace = keyspace;
       this.column_family = column_family;
     }
 
     /**
      * Performs a deep copy on <i>other</i>.
      */
     public system_drop_column_family_args(system_drop_column_family_args other) {
       if (other.isSetKeyspace()) {
         this.keyspace = other.keyspace;
       }
       if (other.isSetColumn_family()) {
         this.column_family = other.column_family;
       }
     }
 
     public system_drop_column_family_args deepCopy() {
       return new system_drop_column_family_args(this);
     }
 
     @Deprecated
     public system_drop_column_family_args clone() {
       return new system_drop_column_family_args(this);
     }
 
     public String getKeyspace() {
       return this.keyspace;
     }
 
     public system_drop_column_family_args setKeyspace(String keyspace) {
       this.keyspace = keyspace;
       return this;
     }
 
     public void unsetKeyspace() {
       this.keyspace = null;
     }
 
     /** Returns true if field keyspace is set (has been asigned a value) and false otherwise */
     public boolean isSetKeyspace() {
       return this.keyspace != null;
     }
 
     public void setKeyspaceIsSet(boolean value) {
       if (!value) {
         this.keyspace = null;
       }
     }
 
     public String getColumn_family() {
       return this.column_family;
     }
 
     public system_drop_column_family_args setColumn_family(String column_family) {
       this.column_family = column_family;
       return this;
     }
 
     public void unsetColumn_family() {
       this.column_family = null;
     }
 
     /** Returns true if field column_family is set (has been asigned a value) and false otherwise */
     public boolean isSetColumn_family() {
       return this.column_family != null;
     }
 
     public void setColumn_familyIsSet(boolean value) {
       if (!value) {
         this.column_family = null;
       }
     }
 
     public void setFieldValue(_Fields field, Object value) {
       switch (field) {
       case KEYSPACE:
         if (value == null) {
           unsetKeyspace();
         } else {
           setKeyspace((String)value);
         }
         break;
 
       case COLUMN_FAMILY:
         if (value == null) {
           unsetColumn_family();
         } else {
           setColumn_family((String)value);
         }
         break;
 
       }
     }
 
     public void setFieldValue(int fieldID, Object value) {
       setFieldValue(_Fields.findByThriftIdOrThrow(fieldID), value);
     }
 
     public Object getFieldValue(_Fields field) {
       switch (field) {
       case KEYSPACE:
         return getKeyspace();
 
       case COLUMN_FAMILY:
         return getColumn_family();
 
       }
       throw new IllegalStateException();
     }
 
     public Object getFieldValue(int fieldId) {
       return getFieldValue(_Fields.findByThriftIdOrThrow(fieldId));
     }
 
     /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
     public boolean isSet(_Fields field) {
       switch (field) {
       case KEYSPACE:
         return isSetKeyspace();
       case COLUMN_FAMILY:
         return isSetColumn_family();
       }
       throw new IllegalStateException();
     }
 
     public boolean isSet(int fieldID) {
       return isSet(_Fields.findByThriftIdOrThrow(fieldID));
     }
 
     @Override
     public boolean equals(Object that) {
       if (that == null)
         return false;
       if (that instanceof system_drop_column_family_args)
         return this.equals((system_drop_column_family_args)that);
       return false;
     }
 
     public boolean equals(system_drop_column_family_args that) {
       if (that == null)
         return false;
 
       boolean this_present_keyspace = true && this.isSetKeyspace();
       boolean that_present_keyspace = true && that.isSetKeyspace();
       if (this_present_keyspace || that_present_keyspace) {
         if (!(this_present_keyspace && that_present_keyspace))
           return false;
         if (!this.keyspace.equals(that.keyspace))
           return false;
       }
 
       boolean this_present_column_family = true && this.isSetColumn_family();
       boolean that_present_column_family = true && that.isSetColumn_family();
       if (this_present_column_family || that_present_column_family) {
         if (!(this_present_column_family && that_present_column_family))
           return false;
         if (!this.column_family.equals(that.column_family))
           return false;
       }
 
       return true;
     }
 
     @Override
     public int hashCode() {
       return 0;
     }
 
     public int compareTo(system_drop_column_family_args other) {
       if (!getClass().equals(other.getClass())) {
         return getClass().getName().compareTo(other.getClass().getName());
       }
 
       int lastComparison = 0;
       system_drop_column_family_args typedOther = (system_drop_column_family_args)other;
 
       lastComparison = Boolean.valueOf(isSetKeyspace()).compareTo(typedOther.isSetKeyspace());
       if (lastComparison != 0) {
         return lastComparison;
       }
       if (isSetKeyspace()) {        lastComparison = TBaseHelper.compareTo(keyspace, typedOther.keyspace);
         if (lastComparison != 0) {
           return lastComparison;
         }
       }
       lastComparison = Boolean.valueOf(isSetColumn_family()).compareTo(typedOther.isSetColumn_family());
       if (lastComparison != 0) {
         return lastComparison;
       }
       if (isSetColumn_family()) {        lastComparison = TBaseHelper.compareTo(column_family, typedOther.column_family);
         if (lastComparison != 0) {
           return lastComparison;
         }
       }
       return 0;
     }
 
     public void read(TProtocol iprot) throws TException {
       TField field;
       iprot.readStructBegin();
       while (true)
       {
         field = iprot.readFieldBegin();
         if (field.type == TType.STOP) { 
           break;
         }
         switch (field.id) {
           case 1: // KEYSPACE
             if (field.type == TType.STRING) {
               this.keyspace = iprot.readString();
             } else { 
               TProtocolUtil.skip(iprot, field.type);
             }
             break;
           case 2: // COLUMN_FAMILY
             if (field.type == TType.STRING) {
               this.column_family = iprot.readString();
             } else { 
               TProtocolUtil.skip(iprot, field.type);
             }
             break;
           default:
             TProtocolUtil.skip(iprot, field.type);
         }
         iprot.readFieldEnd();
       }
       iprot.readStructEnd();
 
       // check for required fields of primitive type, which can't be checked in the validate method
       validate();
     }
 
     public void write(TProtocol oprot) throws TException {
       validate();
 
       oprot.writeStructBegin(STRUCT_DESC);
       if (this.keyspace != null) {
         oprot.writeFieldBegin(KEYSPACE_FIELD_DESC);
         oprot.writeString(this.keyspace);
         oprot.writeFieldEnd();
       }
       if (this.column_family != null) {
         oprot.writeFieldBegin(COLUMN_FAMILY_FIELD_DESC);
         oprot.writeString(this.column_family);
         oprot.writeFieldEnd();
       }
       oprot.writeFieldStop();
       oprot.writeStructEnd();
     }
 
     @Override
     public String toString() {
       StringBuilder sb = new StringBuilder("system_drop_column_family_args(");
       boolean first = true;
 
       sb.append("keyspace:");
       if (this.keyspace == null) {
         sb.append("null");
       } else {
         sb.append(this.keyspace);
       }
       first = false;
       if (!first) sb.append(", ");
       sb.append("column_family:");
       if (this.column_family == null) {
         sb.append("null");
       } else {
         sb.append(this.column_family);
       }
       first = false;
       sb.append(")");
       return sb.toString();
     }
 
     public void validate() throws TException {
       // check for required fields
       if (keyspace == null) {
         throw new TProtocolException("Required field 'keyspace' was not present! Struct: " + toString());
       }
       if (column_family == null) {
         throw new TProtocolException("Required field 'column_family' was not present! Struct: " + toString());
       }
     }
 
   }
 
   public static class system_drop_column_family_result implements TBase<system_drop_column_family_result._Fields>, java.io.Serializable, Cloneable, Comparable<system_drop_column_family_result>   {
     private static final TStruct STRUCT_DESC = new TStruct("system_drop_column_family_result");
 
     private static final TField IRE_FIELD_DESC = new TField("ire", TType.STRUCT, (short)1);
 
     public InvalidRequestException ire;
 
     /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
     public enum _Fields implements TFieldIdEnum {
       IRE((short)1, "ire");
 
       private static final Map<Integer, _Fields> byId = new HashMap<Integer, _Fields>();
       private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();
 
       static {
         for (_Fields field : EnumSet.allOf(_Fields.class)) {
           byId.put((int)field._thriftId, field);
           byName.put(field.getFieldName(), field);
         }
       }
 
       /**
        * Find the _Fields constant that matches fieldId, or null if its not found.
        */
       public static _Fields findByThriftId(int fieldId) {
         return byId.get(fieldId);
       }
 
       /**
        * Find the _Fields constant that matches fieldId, throwing an exception
        * if it is not found.
        */
       public static _Fields findByThriftIdOrThrow(int fieldId) {
         _Fields fields = findByThriftId(fieldId);
         if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
         return fields;
       }
 
       /**
        * Find the _Fields constant that matches name, or null if its not found.
        */
       public static _Fields findByName(String name) {
         return byName.get(name);
       }
 
       private final short _thriftId;
       private final String _fieldName;
 
       _Fields(short thriftId, String fieldName) {
         _thriftId = thriftId;
         _fieldName = fieldName;
       }
 
       public short getThriftFieldId() {
         return _thriftId;
       }
 
       public String getFieldName() {
         return _fieldName;
       }
     }
 
     // isset id assignments
 
     public static final Map<_Fields, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new EnumMap<_Fields, FieldMetaData>(_Fields.class) {{
       put(_Fields.IRE, new FieldMetaData("ire", TFieldRequirementType.DEFAULT, 
           new FieldValueMetaData(TType.STRUCT)));
     }});
 
     static {
       FieldMetaData.addStructMetaDataMap(system_drop_column_family_result.class, metaDataMap);
     }
 
     public system_drop_column_family_result() {
     }
 
     public system_drop_column_family_result(
       InvalidRequestException ire)
     {
       this();
       this.ire = ire;
     }
 
     /**
      * Performs a deep copy on <i>other</i>.
      */
     public system_drop_column_family_result(system_drop_column_family_result other) {
       if (other.isSetIre()) {
         this.ire = new InvalidRequestException(other.ire);
       }
     }
 
     public system_drop_column_family_result deepCopy() {
       return new system_drop_column_family_result(this);
     }
 
     @Deprecated
     public system_drop_column_family_result clone() {
       return new system_drop_column_family_result(this);
     }
 
     public InvalidRequestException getIre() {
       return this.ire;
     }
 
     public system_drop_column_family_result setIre(InvalidRequestException ire) {
       this.ire = ire;
       return this;
     }
 
     public void unsetIre() {
       this.ire = null;
     }
 
     /** Returns true if field ire is set (has been asigned a value) and false otherwise */
     public boolean isSetIre() {
       return this.ire != null;
     }
 
     public void setIreIsSet(boolean value) {
       if (!value) {
         this.ire = null;
       }
     }
 
     public void setFieldValue(_Fields field, Object value) {
       switch (field) {
       case IRE:
         if (value == null) {
           unsetIre();
         } else {
           setIre((InvalidRequestException)value);
         }
         break;
 
       }
     }
 
     public void setFieldValue(int fieldID, Object value) {
       setFieldValue(_Fields.findByThriftIdOrThrow(fieldID), value);
     }
 
     public Object getFieldValue(_Fields field) {
       switch (field) {
       case IRE:
         return getIre();
 
       }
       throw new IllegalStateException();
     }
 
     public Object getFieldValue(int fieldId) {
       return getFieldValue(_Fields.findByThriftIdOrThrow(fieldId));
     }
 
     /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
     public boolean isSet(_Fields field) {
       switch (field) {
       case IRE:
         return isSetIre();
       }
       throw new IllegalStateException();
     }
 
     public boolean isSet(int fieldID) {
       return isSet(_Fields.findByThriftIdOrThrow(fieldID));
     }
 
     @Override
     public boolean equals(Object that) {
       if (that == null)
         return false;
       if (that instanceof system_drop_column_family_result)
         return this.equals((system_drop_column_family_result)that);
       return false;
     }
 
     public boolean equals(system_drop_column_family_result that) {
       if (that == null)
         return false;
 
       boolean this_present_ire = true && this.isSetIre();
       boolean that_present_ire = true && that.isSetIre();
       if (this_present_ire || that_present_ire) {
         if (!(this_present_ire && that_present_ire))
           return false;
         if (!this.ire.equals(that.ire))
           return false;
       }
 
       return true;
     }
 
     @Override
     public int hashCode() {
       return 0;
     }
 
     public int compareTo(system_drop_column_family_result other) {
       if (!getClass().equals(other.getClass())) {
         return getClass().getName().compareTo(other.getClass().getName());
       }
 
       int lastComparison = 0;
       system_drop_column_family_result typedOther = (system_drop_column_family_result)other;
 
       lastComparison = Boolean.valueOf(isSetIre()).compareTo(typedOther.isSetIre());
       if (lastComparison != 0) {
         return lastComparison;
       }
       if (isSetIre()) {        lastComparison = TBaseHelper.compareTo(ire, typedOther.ire);
         if (lastComparison != 0) {
           return lastComparison;
         }
       }
       return 0;
     }
 
     public void read(TProtocol iprot) throws TException {
       TField field;
       iprot.readStructBegin();
       while (true)
       {
         field = iprot.readFieldBegin();
         if (field.type == TType.STOP) { 
           break;
         }
         switch (field.id) {
           case 1: // IRE
             if (field.type == TType.STRUCT) {
               this.ire = new InvalidRequestException();
               this.ire.read(iprot);
             } else { 
               TProtocolUtil.skip(iprot, field.type);
             }
             break;
           default:
             TProtocolUtil.skip(iprot, field.type);
         }
         iprot.readFieldEnd();
       }
       iprot.readStructEnd();
 
       // check for required fields of primitive type, which can't be checked in the validate method
       validate();
     }
 
     public void write(TProtocol oprot) throws TException {
       oprot.writeStructBegin(STRUCT_DESC);
 
       if (this.isSetIre()) {
         oprot.writeFieldBegin(IRE_FIELD_DESC);
         this.ire.write(oprot);
         oprot.writeFieldEnd();
       }
       oprot.writeFieldStop();
       oprot.writeStructEnd();
     }
 
     @Override
     public String toString() {
       StringBuilder sb = new StringBuilder("system_drop_column_family_result(");
       boolean first = true;
 
       sb.append("ire:");
       if (this.ire == null) {
         sb.append("null");
       } else {
         sb.append(this.ire);
       }
       first = false;
       sb.append(")");
       return sb.toString();
     }
 
     public void validate() throws TException {
       // check for required fields
     }
 
   }
 
   public static class system_rename_column_family_args implements TBase<system_rename_column_family_args._Fields>, java.io.Serializable, Cloneable, Comparable<system_rename_column_family_args>   {
     private static final TStruct STRUCT_DESC = new TStruct("system_rename_column_family_args");
 
     private static final TField KEYSPACE_FIELD_DESC = new TField("keyspace", TType.STRING, (short)1);
     private static final TField OLD_NAME_FIELD_DESC = new TField("old_name", TType.STRING, (short)2);
     private static final TField NEW_NAME_FIELD_DESC = new TField("new_name", TType.STRING, (short)3);
 
     public String keyspace;
     public String old_name;
     public String new_name;
 
     /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
     public enum _Fields implements TFieldIdEnum {
       KEYSPACE((short)1, "keyspace"),
       OLD_NAME((short)2, "old_name"),
       NEW_NAME((short)3, "new_name");
 
       private static final Map<Integer, _Fields> byId = new HashMap<Integer, _Fields>();
       private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();
 
       static {
         for (_Fields field : EnumSet.allOf(_Fields.class)) {
           byId.put((int)field._thriftId, field);
           byName.put(field.getFieldName(), field);
         }
       }
 
       /**
        * Find the _Fields constant that matches fieldId, or null if its not found.
        */
       public static _Fields findByThriftId(int fieldId) {
         return byId.get(fieldId);
       }
 
       /**
        * Find the _Fields constant that matches fieldId, throwing an exception
        * if it is not found.
        */
       public static _Fields findByThriftIdOrThrow(int fieldId) {
         _Fields fields = findByThriftId(fieldId);
         if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
         return fields;
       }
 
       /**
        * Find the _Fields constant that matches name, or null if its not found.
        */
       public static _Fields findByName(String name) {
         return byName.get(name);
       }
 
       private final short _thriftId;
       private final String _fieldName;
 
       _Fields(short thriftId, String fieldName) {
         _thriftId = thriftId;
         _fieldName = fieldName;
       }
 
       public short getThriftFieldId() {
         return _thriftId;
       }
 
       public String getFieldName() {
         return _fieldName;
       }
     }
 
     // isset id assignments
 
     public static final Map<_Fields, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new EnumMap<_Fields, FieldMetaData>(_Fields.class) {{
       put(_Fields.KEYSPACE, new FieldMetaData("keyspace", TFieldRequirementType.REQUIRED, 
           new FieldValueMetaData(TType.STRING)));
       put(_Fields.OLD_NAME, new FieldMetaData("old_name", TFieldRequirementType.REQUIRED, 
           new FieldValueMetaData(TType.STRING)));
       put(_Fields.NEW_NAME, new FieldMetaData("new_name", TFieldRequirementType.REQUIRED, 
           new FieldValueMetaData(TType.STRING)));
     }});
 
     static {
       FieldMetaData.addStructMetaDataMap(system_rename_column_family_args.class, metaDataMap);
     }
 
     public system_rename_column_family_args() {
     }
 
     public system_rename_column_family_args(
       String keyspace,
       String old_name,
       String new_name)
     {
       this();
       this.keyspace = keyspace;
       this.old_name = old_name;
       this.new_name = new_name;
     }
 
     /**
      * Performs a deep copy on <i>other</i>.
      */
     public system_rename_column_family_args(system_rename_column_family_args other) {
       if (other.isSetKeyspace()) {
         this.keyspace = other.keyspace;
       }
       if (other.isSetOld_name()) {
         this.old_name = other.old_name;
       }
       if (other.isSetNew_name()) {
         this.new_name = other.new_name;
       }
     }
 
     public system_rename_column_family_args deepCopy() {
       return new system_rename_column_family_args(this);
     }
 
     @Deprecated
     public system_rename_column_family_args clone() {
       return new system_rename_column_family_args(this);
     }
 
     public String getKeyspace() {
       return this.keyspace;
     }
 
     public system_rename_column_family_args setKeyspace(String keyspace) {
       this.keyspace = keyspace;
       return this;
     }
 
     public void unsetKeyspace() {
       this.keyspace = null;
     }
 
     /** Returns true if field keyspace is set (has been asigned a value) and false otherwise */
     public boolean isSetKeyspace() {
       return this.keyspace != null;
     }
 
     public void setKeyspaceIsSet(boolean value) {
       if (!value) {
         this.keyspace = null;
       }
     }
 
     public String getOld_name() {
       return this.old_name;
     }
 
     public system_rename_column_family_args setOld_name(String old_name) {
       this.old_name = old_name;
       return this;
     }
 
     public void unsetOld_name() {
       this.old_name = null;
     }
 
     /** Returns true if field old_name is set (has been asigned a value) and false otherwise */
     public boolean isSetOld_name() {
       return this.old_name != null;
     }
 
     public void setOld_nameIsSet(boolean value) {
       if (!value) {
         this.old_name = null;
       }
     }
 
     public String getNew_name() {
       return this.new_name;
     }
 
     public system_rename_column_family_args setNew_name(String new_name) {
       this.new_name = new_name;
       return this;
     }
 
     public void unsetNew_name() {
       this.new_name = null;
     }
 
     /** Returns true if field new_name is set (has been asigned a value) and false otherwise */
     public boolean isSetNew_name() {
       return this.new_name != null;
     }
 
     public void setNew_nameIsSet(boolean value) {
       if (!value) {
         this.new_name = null;
       }
     }
 
     public void setFieldValue(_Fields field, Object value) {
       switch (field) {
       case KEYSPACE:
         if (value == null) {
           unsetKeyspace();
         } else {
           setKeyspace((String)value);
         }
         break;
 
       case OLD_NAME:
         if (value == null) {
           unsetOld_name();
         } else {
           setOld_name((String)value);
         }
         break;
 
       case NEW_NAME:
         if (value == null) {
           unsetNew_name();
         } else {
           setNew_name((String)value);
         }
         break;
 
       }
     }
 
     public void setFieldValue(int fieldID, Object value) {
       setFieldValue(_Fields.findByThriftIdOrThrow(fieldID), value);
     }
 
     public Object getFieldValue(_Fields field) {
       switch (field) {
       case KEYSPACE:
         return getKeyspace();
 
       case OLD_NAME:
         return getOld_name();
 
       case NEW_NAME:
         return getNew_name();
 
       }
       throw new IllegalStateException();
     }
 
     public Object getFieldValue(int fieldId) {
       return getFieldValue(_Fields.findByThriftIdOrThrow(fieldId));
     }
 
     /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
     public boolean isSet(_Fields field) {
       switch (field) {
       case KEYSPACE:
         return isSetKeyspace();
       case OLD_NAME:
         return isSetOld_name();
       case NEW_NAME:
         return isSetNew_name();
       }
       throw new IllegalStateException();
     }
 
     public boolean isSet(int fieldID) {
       return isSet(_Fields.findByThriftIdOrThrow(fieldID));
     }
 
     @Override
     public boolean equals(Object that) {
       if (that == null)
         return false;
       if (that instanceof system_rename_column_family_args)
         return this.equals((system_rename_column_family_args)that);
       return false;
     }
 
     public boolean equals(system_rename_column_family_args that) {
       if (that == null)
         return false;
 
       boolean this_present_keyspace = true && this.isSetKeyspace();
       boolean that_present_keyspace = true && that.isSetKeyspace();
       if (this_present_keyspace || that_present_keyspace) {
         if (!(this_present_keyspace && that_present_keyspace))
           return false;
         if (!this.keyspace.equals(that.keyspace))
           return false;
       }
 
       boolean this_present_old_name = true && this.isSetOld_name();
       boolean that_present_old_name = true && that.isSetOld_name();
       if (this_present_old_name || that_present_old_name) {
         if (!(this_present_old_name && that_present_old_name))
           return false;
         if (!this.old_name.equals(that.old_name))
           return false;
       }
 
       boolean this_present_new_name = true && this.isSetNew_name();
       boolean that_present_new_name = true && that.isSetNew_name();
       if (this_present_new_name || that_present_new_name) {
         if (!(this_present_new_name && that_present_new_name))
           return false;
         if (!this.new_name.equals(that.new_name))
           return false;
       }
 
       return true;
     }
 
     @Override
     public int hashCode() {
       return 0;
     }
 
     public int compareTo(system_rename_column_family_args other) {
       if (!getClass().equals(other.getClass())) {
         return getClass().getName().compareTo(other.getClass().getName());
       }
 
       int lastComparison = 0;
       system_rename_column_family_args typedOther = (system_rename_column_family_args)other;
 
       lastComparison = Boolean.valueOf(isSetKeyspace()).compareTo(typedOther.isSetKeyspace());
       if (lastComparison != 0) {
         return lastComparison;
       }
       if (isSetKeyspace()) {        lastComparison = TBaseHelper.compareTo(keyspace, typedOther.keyspace);
         if (lastComparison != 0) {
           return lastComparison;
         }
       }
       lastComparison = Boolean.valueOf(isSetOld_name()).compareTo(typedOther.isSetOld_name());
       if (lastComparison != 0) {
         return lastComparison;
       }
       if (isSetOld_name()) {        lastComparison = TBaseHelper.compareTo(old_name, typedOther.old_name);
         if (lastComparison != 0) {
           return lastComparison;
         }
       }
       lastComparison = Boolean.valueOf(isSetNew_name()).compareTo(typedOther.isSetNew_name());
       if (lastComparison != 0) {
         return lastComparison;
       }
       if (isSetNew_name()) {        lastComparison = TBaseHelper.compareTo(new_name, typedOther.new_name);
         if (lastComparison != 0) {
           return lastComparison;
         }
       }
       return 0;
     }
 
     public void read(TProtocol iprot) throws TException {
       TField field;
       iprot.readStructBegin();
       while (true)
       {
         field = iprot.readFieldBegin();
         if (field.type == TType.STOP) { 
           break;
         }
         switch (field.id) {
           case 1: // KEYSPACE
             if (field.type == TType.STRING) {
               this.keyspace = iprot.readString();
             } else { 
               TProtocolUtil.skip(iprot, field.type);
             }
             break;
           case 2: // OLD_NAME
             if (field.type == TType.STRING) {
               this.old_name = iprot.readString();
             } else { 
               TProtocolUtil.skip(iprot, field.type);
             }
             break;
           case 3: // NEW_NAME
             if (field.type == TType.STRING) {
               this.new_name = iprot.readString();
             } else { 
               TProtocolUtil.skip(iprot, field.type);
             }
             break;
           default:
             TProtocolUtil.skip(iprot, field.type);
         }
         iprot.readFieldEnd();
       }
       iprot.readStructEnd();
 
       // check for required fields of primitive type, which can't be checked in the validate method
       validate();
     }
 
     public void write(TProtocol oprot) throws TException {
       validate();
 
       oprot.writeStructBegin(STRUCT_DESC);
       if (this.keyspace != null) {
         oprot.writeFieldBegin(KEYSPACE_FIELD_DESC);
         oprot.writeString(this.keyspace);
         oprot.writeFieldEnd();
       }
       if (this.old_name != null) {
         oprot.writeFieldBegin(OLD_NAME_FIELD_DESC);
         oprot.writeString(this.old_name);
         oprot.writeFieldEnd();
       }
       if (this.new_name != null) {
         oprot.writeFieldBegin(NEW_NAME_FIELD_DESC);
         oprot.writeString(this.new_name);
         oprot.writeFieldEnd();
       }
       oprot.writeFieldStop();
       oprot.writeStructEnd();
     }
 
     @Override
     public String toString() {
       StringBuilder sb = new StringBuilder("system_rename_column_family_args(");
       boolean first = true;
 
       sb.append("keyspace:");
       if (this.keyspace == null) {
         sb.append("null");
       } else {
         sb.append(this.keyspace);
       }
       first = false;
       if (!first) sb.append(", ");
       sb.append("old_name:");
       if (this.old_name == null) {
         sb.append("null");
       } else {
         sb.append(this.old_name);
       }
       first = false;
       if (!first) sb.append(", ");
       sb.append("new_name:");
       if (this.new_name == null) {
         sb.append("null");
       } else {
         sb.append(this.new_name);
       }
       first = false;
       sb.append(")");
       return sb.toString();
     }
 
     public void validate() throws TException {
       // check for required fields
       if (keyspace == null) {
         throw new TProtocolException("Required field 'keyspace' was not present! Struct: " + toString());
       }
       if (old_name == null) {
         throw new TProtocolException("Required field 'old_name' was not present! Struct: " + toString());
       }
       if (new_name == null) {
         throw new TProtocolException("Required field 'new_name' was not present! Struct: " + toString());
       }
     }
 
   }
 
   public static class system_rename_column_family_result implements TBase<system_rename_column_family_result._Fields>, java.io.Serializable, Cloneable, Comparable<system_rename_column_family_result>   {
     private static final TStruct STRUCT_DESC = new TStruct("system_rename_column_family_result");
 
     private static final TField IRE_FIELD_DESC = new TField("ire", TType.STRUCT, (short)1);
 
     public InvalidRequestException ire;
 
     /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
     public enum _Fields implements TFieldIdEnum {
       IRE((short)1, "ire");
 
       private static final Map<Integer, _Fields> byId = new HashMap<Integer, _Fields>();
       private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();
 
       static {
         for (_Fields field : EnumSet.allOf(_Fields.class)) {
           byId.put((int)field._thriftId, field);
           byName.put(field.getFieldName(), field);
         }
       }
 
       /**
        * Find the _Fields constant that matches fieldId, or null if its not found.
        */
       public static _Fields findByThriftId(int fieldId) {
         return byId.get(fieldId);
       }
 
       /**
        * Find the _Fields constant that matches fieldId, throwing an exception
        * if it is not found.
        */
       public static _Fields findByThriftIdOrThrow(int fieldId) {
         _Fields fields = findByThriftId(fieldId);
         if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
         return fields;
       }
 
       /**
        * Find the _Fields constant that matches name, or null if its not found.
        */
       public static _Fields findByName(String name) {
         return byName.get(name);
       }
 
       private final short _thriftId;
       private final String _fieldName;
 
       _Fields(short thriftId, String fieldName) {
         _thriftId = thriftId;
         _fieldName = fieldName;
       }
 
       public short getThriftFieldId() {
         return _thriftId;
       }
 
       public String getFieldName() {
         return _fieldName;
       }
     }
 
     // isset id assignments
 
     public static final Map<_Fields, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new EnumMap<_Fields, FieldMetaData>(_Fields.class) {{
       put(_Fields.IRE, new FieldMetaData("ire", TFieldRequirementType.DEFAULT, 
           new FieldValueMetaData(TType.STRUCT)));
     }});
 
     static {
       FieldMetaData.addStructMetaDataMap(system_rename_column_family_result.class, metaDataMap);
     }
 
     public system_rename_column_family_result() {
     }
 
     public system_rename_column_family_result(
       InvalidRequestException ire)
     {
       this();
       this.ire = ire;
     }
 
     /**
      * Performs a deep copy on <i>other</i>.
      */
     public system_rename_column_family_result(system_rename_column_family_result other) {
       if (other.isSetIre()) {
         this.ire = new InvalidRequestException(other.ire);
       }
     }
 
     public system_rename_column_family_result deepCopy() {
       return new system_rename_column_family_result(this);
     }
 
     @Deprecated
     public system_rename_column_family_result clone() {
       return new system_rename_column_family_result(this);
     }
 
     public InvalidRequestException getIre() {
       return this.ire;
     }
 
     public system_rename_column_family_result setIre(InvalidRequestException ire) {
       this.ire = ire;
       return this;
     }
 
     public void unsetIre() {
       this.ire = null;
     }
 
     /** Returns true if field ire is set (has been asigned a value) and false otherwise */
     public boolean isSetIre() {
       return this.ire != null;
     }
 
     public void setIreIsSet(boolean value) {
       if (!value) {
         this.ire = null;
       }
     }
 
     public void setFieldValue(_Fields field, Object value) {
       switch (field) {
       case IRE:
         if (value == null) {
           unsetIre();
         } else {
           setIre((InvalidRequestException)value);
         }
         break;
 
       }
     }
 
     public void setFieldValue(int fieldID, Object value) {
       setFieldValue(_Fields.findByThriftIdOrThrow(fieldID), value);
     }
 
     public Object getFieldValue(_Fields field) {
       switch (field) {
       case IRE:
         return getIre();
 
       }
       throw new IllegalStateException();
     }
 
     public Object getFieldValue(int fieldId) {
       return getFieldValue(_Fields.findByThriftIdOrThrow(fieldId));
     }
 
     /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
     public boolean isSet(_Fields field) {
       switch (field) {
       case IRE:
         return isSetIre();
       }
       throw new IllegalStateException();
     }
 
     public boolean isSet(int fieldID) {
       return isSet(_Fields.findByThriftIdOrThrow(fieldID));
     }
 
     @Override
     public boolean equals(Object that) {
       if (that == null)
         return false;
       if (that instanceof system_rename_column_family_result)
         return this.equals((system_rename_column_family_result)that);
       return false;
     }
 
     public boolean equals(system_rename_column_family_result that) {
       if (that == null)
         return false;
 
       boolean this_present_ire = true && this.isSetIre();
       boolean that_present_ire = true && that.isSetIre();
       if (this_present_ire || that_present_ire) {
         if (!(this_present_ire && that_present_ire))
           return false;
         if (!this.ire.equals(that.ire))
           return false;
       }
 
       return true;
     }
 
     @Override
     public int hashCode() {
       return 0;
     }
 
     public int compareTo(system_rename_column_family_result other) {
       if (!getClass().equals(other.getClass())) {
         return getClass().getName().compareTo(other.getClass().getName());
       }
 
       int lastComparison = 0;
       system_rename_column_family_result typedOther = (system_rename_column_family_result)other;
 
       lastComparison = Boolean.valueOf(isSetIre()).compareTo(typedOther.isSetIre());
       if (lastComparison != 0) {
         return lastComparison;
       }
       if (isSetIre()) {        lastComparison = TBaseHelper.compareTo(ire, typedOther.ire);
         if (lastComparison != 0) {
           return lastComparison;
         }
       }
       return 0;
     }
 
     public void read(TProtocol iprot) throws TException {
       TField field;
       iprot.readStructBegin();
       while (true)
       {
         field = iprot.readFieldBegin();
         if (field.type == TType.STOP) { 
           break;
         }
         switch (field.id) {
           case 1: // IRE
             if (field.type == TType.STRUCT) {
               this.ire = new InvalidRequestException();
               this.ire.read(iprot);
             } else { 
               TProtocolUtil.skip(iprot, field.type);
             }
             break;
           default:
             TProtocolUtil.skip(iprot, field.type);
         }
         iprot.readFieldEnd();
       }
       iprot.readStructEnd();
 
       // check for required fields of primitive type, which can't be checked in the validate method
       validate();
     }
 
     public void write(TProtocol oprot) throws TException {
       oprot.writeStructBegin(STRUCT_DESC);
 
       if (this.isSetIre()) {
         oprot.writeFieldBegin(IRE_FIELD_DESC);
         this.ire.write(oprot);
         oprot.writeFieldEnd();
       }
       oprot.writeFieldStop();
       oprot.writeStructEnd();
     }
 
     @Override
     public String toString() {
       StringBuilder sb = new StringBuilder("system_rename_column_family_result(");
       boolean first = true;
 
       sb.append("ire:");
       if (this.ire == null) {
         sb.append("null");
       } else {
         sb.append(this.ire);
       }
       first = false;
       sb.append(")");
       return sb.toString();
     }
 
     public void validate() throws TException {
       // check for required fields
     }
 
   }
 
   public static class system_add_keyspace_args implements TBase<system_add_keyspace_args._Fields>, java.io.Serializable, Cloneable, Comparable<system_add_keyspace_args>   {
     private static final TStruct STRUCT_DESC = new TStruct("system_add_keyspace_args");
 
     private static final TField KS_DEF_FIELD_DESC = new TField("ks_def", TType.STRUCT, (short)1);
 
     public KsDef ks_def;
 
     /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
     public enum _Fields implements TFieldIdEnum {
       KS_DEF((short)1, "ks_def");
 
       private static final Map<Integer, _Fields> byId = new HashMap<Integer, _Fields>();
       private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();
 
       static {
         for (_Fields field : EnumSet.allOf(_Fields.class)) {
           byId.put((int)field._thriftId, field);
           byName.put(field.getFieldName(), field);
         }
       }
 
       /**
        * Find the _Fields constant that matches fieldId, or null if its not found.
        */
       public static _Fields findByThriftId(int fieldId) {
         return byId.get(fieldId);
       }
 
       /**
        * Find the _Fields constant that matches fieldId, throwing an exception
        * if it is not found.
        */
       public static _Fields findByThriftIdOrThrow(int fieldId) {
         _Fields fields = findByThriftId(fieldId);
         if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
         return fields;
       }
 
       /**
        * Find the _Fields constant that matches name, or null if its not found.
        */
       public static _Fields findByName(String name) {
         return byName.get(name);
       }
 
       private final short _thriftId;
       private final String _fieldName;
 
       _Fields(short thriftId, String fieldName) {
         _thriftId = thriftId;
         _fieldName = fieldName;
       }
 
       public short getThriftFieldId() {
         return _thriftId;
       }
 
       public String getFieldName() {
         return _fieldName;
       }
     }
 
     // isset id assignments
 
     public static final Map<_Fields, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new EnumMap<_Fields, FieldMetaData>(_Fields.class) {{
       put(_Fields.KS_DEF, new FieldMetaData("ks_def", TFieldRequirementType.REQUIRED, 
           new StructMetaData(TType.STRUCT, KsDef.class)));
     }});
 
     static {
       FieldMetaData.addStructMetaDataMap(system_add_keyspace_args.class, metaDataMap);
     }
 
     public system_add_keyspace_args() {
     }
 
     public system_add_keyspace_args(
       KsDef ks_def)
     {
       this();
       this.ks_def = ks_def;
     }
 
     /**
      * Performs a deep copy on <i>other</i>.
      */
     public system_add_keyspace_args(system_add_keyspace_args other) {
       if (other.isSetKs_def()) {
         this.ks_def = new KsDef(other.ks_def);
       }
     }
 
     public system_add_keyspace_args deepCopy() {
       return new system_add_keyspace_args(this);
     }
 
     @Deprecated
     public system_add_keyspace_args clone() {
       return new system_add_keyspace_args(this);
     }
 
     public KsDef getKs_def() {
       return this.ks_def;
     }
 
     public system_add_keyspace_args setKs_def(KsDef ks_def) {
       this.ks_def = ks_def;
       return this;
     }
 
     public void unsetKs_def() {
       this.ks_def = null;
     }
 
     /** Returns true if field ks_def is set (has been asigned a value) and false otherwise */
     public boolean isSetKs_def() {
       return this.ks_def != null;
     }
 
     public void setKs_defIsSet(boolean value) {
       if (!value) {
         this.ks_def = null;
       }
     }
 
     public void setFieldValue(_Fields field, Object value) {
       switch (field) {
       case KS_DEF:
         if (value == null) {
           unsetKs_def();
         } else {
           setKs_def((KsDef)value);
         }
         break;
 
       }
     }
 
     public void setFieldValue(int fieldID, Object value) {
       setFieldValue(_Fields.findByThriftIdOrThrow(fieldID), value);
     }
 
     public Object getFieldValue(_Fields field) {
       switch (field) {
       case KS_DEF:
         return getKs_def();
 
       }
       throw new IllegalStateException();
     }
 
     public Object getFieldValue(int fieldId) {
       return getFieldValue(_Fields.findByThriftIdOrThrow(fieldId));
     }
 
     /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
     public boolean isSet(_Fields field) {
       switch (field) {
       case KS_DEF:
         return isSetKs_def();
       }
       throw new IllegalStateException();
     }
 
     public boolean isSet(int fieldID) {
       return isSet(_Fields.findByThriftIdOrThrow(fieldID));
     }
 
     @Override
     public boolean equals(Object that) {
       if (that == null)
         return false;
       if (that instanceof system_add_keyspace_args)
         return this.equals((system_add_keyspace_args)that);
       return false;
     }
 
     public boolean equals(system_add_keyspace_args that) {
       if (that == null)
         return false;
 
       boolean this_present_ks_def = true && this.isSetKs_def();
       boolean that_present_ks_def = true && that.isSetKs_def();
       if (this_present_ks_def || that_present_ks_def) {
         if (!(this_present_ks_def && that_present_ks_def))
           return false;
         if (!this.ks_def.equals(that.ks_def))
           return false;
       }
 
       return true;
     }
 
     @Override
     public int hashCode() {
       return 0;
     }
 
     public int compareTo(system_add_keyspace_args other) {
       if (!getClass().equals(other.getClass())) {
         return getClass().getName().compareTo(other.getClass().getName());
       }
 
       int lastComparison = 0;
       system_add_keyspace_args typedOther = (system_add_keyspace_args)other;
 
       lastComparison = Boolean.valueOf(isSetKs_def()).compareTo(typedOther.isSetKs_def());
       if (lastComparison != 0) {
         return lastComparison;
       }
       if (isSetKs_def()) {        lastComparison = TBaseHelper.compareTo(ks_def, typedOther.ks_def);
         if (lastComparison != 0) {
           return lastComparison;
         }
       }
       return 0;
     }
 
     public void read(TProtocol iprot) throws TException {
       TField field;
       iprot.readStructBegin();
       while (true)
       {
         field = iprot.readFieldBegin();
         if (field.type == TType.STOP) { 
           break;
         }
         switch (field.id) {
           case 1: // KS_DEF
             if (field.type == TType.STRUCT) {
               this.ks_def = new KsDef();
               this.ks_def.read(iprot);
             } else { 
               TProtocolUtil.skip(iprot, field.type);
             }
             break;
           default:
             TProtocolUtil.skip(iprot, field.type);
         }
         iprot.readFieldEnd();
       }
       iprot.readStructEnd();
 
       // check for required fields of primitive type, which can't be checked in the validate method
       validate();
     }
 
     public void write(TProtocol oprot) throws TException {
       validate();
 
       oprot.writeStructBegin(STRUCT_DESC);
       if (this.ks_def != null) {
         oprot.writeFieldBegin(KS_DEF_FIELD_DESC);
         this.ks_def.write(oprot);
         oprot.writeFieldEnd();
       }
       oprot.writeFieldStop();
       oprot.writeStructEnd();
     }
 
     @Override
     public String toString() {
       StringBuilder sb = new StringBuilder("system_add_keyspace_args(");
       boolean first = true;
 
       sb.append("ks_def:");
       if (this.ks_def == null) {
         sb.append("null");
       } else {
         sb.append(this.ks_def);
       }
       first = false;
       sb.append(")");
       return sb.toString();
     }
 
     public void validate() throws TException {
       // check for required fields
       if (ks_def == null) {
         throw new TProtocolException("Required field 'ks_def' was not present! Struct: " + toString());
       }
     }
 
   }
 
   public static class system_add_keyspace_result implements TBase<system_add_keyspace_result._Fields>, java.io.Serializable, Cloneable, Comparable<system_add_keyspace_result>   {
     private static final TStruct STRUCT_DESC = new TStruct("system_add_keyspace_result");
 
     private static final TField IRE_FIELD_DESC = new TField("ire", TType.STRUCT, (short)1);
 
     public InvalidRequestException ire;
 
     /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
     public enum _Fields implements TFieldIdEnum {
       IRE((short)1, "ire");
 
       private static final Map<Integer, _Fields> byId = new HashMap<Integer, _Fields>();
       private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();
 
       static {
         for (_Fields field : EnumSet.allOf(_Fields.class)) {
           byId.put((int)field._thriftId, field);
           byName.put(field.getFieldName(), field);
         }
       }
 
       /**
        * Find the _Fields constant that matches fieldId, or null if its not found.
        */
       public static _Fields findByThriftId(int fieldId) {
         return byId.get(fieldId);
       }
 
       /**
        * Find the _Fields constant that matches fieldId, throwing an exception
        * if it is not found.
        */
       public static _Fields findByThriftIdOrThrow(int fieldId) {
         _Fields fields = findByThriftId(fieldId);
         if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
         return fields;
       }
 
       /**
        * Find the _Fields constant that matches name, or null if its not found.
        */
       public static _Fields findByName(String name) {
         return byName.get(name);
       }
 
       private final short _thriftId;
       private final String _fieldName;
 
       _Fields(short thriftId, String fieldName) {
         _thriftId = thriftId;
         _fieldName = fieldName;
       }
 
       public short getThriftFieldId() {
         return _thriftId;
       }
 
       public String getFieldName() {
         return _fieldName;
       }
     }
 
     // isset id assignments
 
     public static final Map<_Fields, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new EnumMap<_Fields, FieldMetaData>(_Fields.class) {{
       put(_Fields.IRE, new FieldMetaData("ire", TFieldRequirementType.DEFAULT, 
           new FieldValueMetaData(TType.STRUCT)));
     }});
 
     static {
       FieldMetaData.addStructMetaDataMap(system_add_keyspace_result.class, metaDataMap);
     }
 
     public system_add_keyspace_result() {
     }
 
     public system_add_keyspace_result(
       InvalidRequestException ire)
     {
       this();
       this.ire = ire;
     }
 
     /**
      * Performs a deep copy on <i>other</i>.
      */
     public system_add_keyspace_result(system_add_keyspace_result other) {
       if (other.isSetIre()) {
         this.ire = new InvalidRequestException(other.ire);
       }
     }
 
     public system_add_keyspace_result deepCopy() {
       return new system_add_keyspace_result(this);
     }
 
     @Deprecated
     public system_add_keyspace_result clone() {
       return new system_add_keyspace_result(this);
     }
 
     public InvalidRequestException getIre() {
       return this.ire;
     }
 
     public system_add_keyspace_result setIre(InvalidRequestException ire) {
       this.ire = ire;
       return this;
     }
 
     public void unsetIre() {
       this.ire = null;
     }
 
     /** Returns true if field ire is set (has been asigned a value) and false otherwise */
     public boolean isSetIre() {
       return this.ire != null;
     }
 
     public void setIreIsSet(boolean value) {
       if (!value) {
         this.ire = null;
       }
     }
 
     public void setFieldValue(_Fields field, Object value) {
       switch (field) {
       case IRE:
         if (value == null) {
           unsetIre();
         } else {
           setIre((InvalidRequestException)value);
         }
         break;
 
       }
     }
 
     public void setFieldValue(int fieldID, Object value) {
       setFieldValue(_Fields.findByThriftIdOrThrow(fieldID), value);
     }
 
     public Object getFieldValue(_Fields field) {
       switch (field) {
       case IRE:
         return getIre();
 
       }
       throw new IllegalStateException();
     }
 
     public Object getFieldValue(int fieldId) {
       return getFieldValue(_Fields.findByThriftIdOrThrow(fieldId));
     }
 
     /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
     public boolean isSet(_Fields field) {
       switch (field) {
       case IRE:
         return isSetIre();
       }
       throw new IllegalStateException();
     }
 
     public boolean isSet(int fieldID) {
       return isSet(_Fields.findByThriftIdOrThrow(fieldID));
     }
 
     @Override
     public boolean equals(Object that) {
       if (that == null)
         return false;
       if (that instanceof system_add_keyspace_result)
         return this.equals((system_add_keyspace_result)that);
       return false;
     }
 
     public boolean equals(system_add_keyspace_result that) {
       if (that == null)
         return false;
 
       boolean this_present_ire = true && this.isSetIre();
       boolean that_present_ire = true && that.isSetIre();
       if (this_present_ire || that_present_ire) {
         if (!(this_present_ire && that_present_ire))
           return false;
         if (!this.ire.equals(that.ire))
           return false;
       }
 
       return true;
     }
 
     @Override
     public int hashCode() {
       return 0;
     }
 
     public int compareTo(system_add_keyspace_result other) {
       if (!getClass().equals(other.getClass())) {
         return getClass().getName().compareTo(other.getClass().getName());
       }
 
       int lastComparison = 0;
       system_add_keyspace_result typedOther = (system_add_keyspace_result)other;
 
       lastComparison = Boolean.valueOf(isSetIre()).compareTo(typedOther.isSetIre());
       if (lastComparison != 0) {
         return lastComparison;
       }
       if (isSetIre()) {        lastComparison = TBaseHelper.compareTo(ire, typedOther.ire);
         if (lastComparison != 0) {
           return lastComparison;
         }
       }
       return 0;
     }
 
     public void read(TProtocol iprot) throws TException {
       TField field;
       iprot.readStructBegin();
       while (true)
       {
         field = iprot.readFieldBegin();
         if (field.type == TType.STOP) { 
           break;
         }
         switch (field.id) {
           case 1: // IRE
             if (field.type == TType.STRUCT) {
               this.ire = new InvalidRequestException();
               this.ire.read(iprot);
             } else { 
               TProtocolUtil.skip(iprot, field.type);
             }
             break;
           default:
             TProtocolUtil.skip(iprot, field.type);
         }
         iprot.readFieldEnd();
       }
       iprot.readStructEnd();
 
       // check for required fields of primitive type, which can't be checked in the validate method
       validate();
     }
 
     public void write(TProtocol oprot) throws TException {
       oprot.writeStructBegin(STRUCT_DESC);
 
       if (this.isSetIre()) {
         oprot.writeFieldBegin(IRE_FIELD_DESC);
         this.ire.write(oprot);
         oprot.writeFieldEnd();
       }
       oprot.writeFieldStop();
       oprot.writeStructEnd();
     }
 
     @Override
     public String toString() {
       StringBuilder sb = new StringBuilder("system_add_keyspace_result(");
       boolean first = true;
 
       sb.append("ire:");
       if (this.ire == null) {
         sb.append("null");
       } else {
         sb.append(this.ire);
       }
       first = false;
       sb.append(")");
       return sb.toString();
     }
 
     public void validate() throws TException {
       // check for required fields
     }
 
   }
 
   public static class system_drop_keyspace_args implements TBase<system_drop_keyspace_args._Fields>, java.io.Serializable, Cloneable, Comparable<system_drop_keyspace_args>   {
     private static final TStruct STRUCT_DESC = new TStruct("system_drop_keyspace_args");
 
     private static final TField KEYSPACE_FIELD_DESC = new TField("keyspace", TType.STRING, (short)1);
 
     public String keyspace;
 
     /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
     public enum _Fields implements TFieldIdEnum {
       KEYSPACE((short)1, "keyspace");
 
       private static final Map<Integer, _Fields> byId = new HashMap<Integer, _Fields>();
       private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();
 
       static {
         for (_Fields field : EnumSet.allOf(_Fields.class)) {
           byId.put((int)field._thriftId, field);
           byName.put(field.getFieldName(), field);
         }
       }
 
       /**
        * Find the _Fields constant that matches fieldId, or null if its not found.
        */
       public static _Fields findByThriftId(int fieldId) {
         return byId.get(fieldId);
       }
 
       /**
        * Find the _Fields constant that matches fieldId, throwing an exception
        * if it is not found.
        */
       public static _Fields findByThriftIdOrThrow(int fieldId) {
         _Fields fields = findByThriftId(fieldId);
         if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
         return fields;
       }
 
       /**
        * Find the _Fields constant that matches name, or null if its not found.
        */
       public static _Fields findByName(String name) {
         return byName.get(name);
       }
 
       private final short _thriftId;
       private final String _fieldName;
 
       _Fields(short thriftId, String fieldName) {
         _thriftId = thriftId;
         _fieldName = fieldName;
       }
 
       public short getThriftFieldId() {
         return _thriftId;
       }
 
       public String getFieldName() {
         return _fieldName;
       }
     }
 
     // isset id assignments
 
     public static final Map<_Fields, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new EnumMap<_Fields, FieldMetaData>(_Fields.class) {{
       put(_Fields.KEYSPACE, new FieldMetaData("keyspace", TFieldRequirementType.REQUIRED, 
           new FieldValueMetaData(TType.STRING)));
     }});
 
     static {
       FieldMetaData.addStructMetaDataMap(system_drop_keyspace_args.class, metaDataMap);
     }
 
     public system_drop_keyspace_args() {
     }
 
     public system_drop_keyspace_args(
       String keyspace)
     {
       this();
       this.keyspace = keyspace;
     }
 
     /**
      * Performs a deep copy on <i>other</i>.
      */
     public system_drop_keyspace_args(system_drop_keyspace_args other) {
       if (other.isSetKeyspace()) {
         this.keyspace = other.keyspace;
       }
     }
 
     public system_drop_keyspace_args deepCopy() {
       return new system_drop_keyspace_args(this);
     }
 
     @Deprecated
     public system_drop_keyspace_args clone() {
       return new system_drop_keyspace_args(this);
     }
 
     public String getKeyspace() {
       return this.keyspace;
     }
 
     public system_drop_keyspace_args setKeyspace(String keyspace) {
       this.keyspace = keyspace;
       return this;
     }
 
     public void unsetKeyspace() {
       this.keyspace = null;
     }
 
     /** Returns true if field keyspace is set (has been asigned a value) and false otherwise */
     public boolean isSetKeyspace() {
       return this.keyspace != null;
     }
 
     public void setKeyspaceIsSet(boolean value) {
       if (!value) {
         this.keyspace = null;
       }
     }
 
     public void setFieldValue(_Fields field, Object value) {
       switch (field) {
       case KEYSPACE:
         if (value == null) {
           unsetKeyspace();
         } else {
           setKeyspace((String)value);
         }
         break;
 
       }
     }
 
     public void setFieldValue(int fieldID, Object value) {
       setFieldValue(_Fields.findByThriftIdOrThrow(fieldID), value);
     }
 
     public Object getFieldValue(_Fields field) {
       switch (field) {
       case KEYSPACE:
         return getKeyspace();
 
       }
       throw new IllegalStateException();
     }
 
     public Object getFieldValue(int fieldId) {
       return getFieldValue(_Fields.findByThriftIdOrThrow(fieldId));
     }
 
     /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
     public boolean isSet(_Fields field) {
       switch (field) {
       case KEYSPACE:
         return isSetKeyspace();
       }
       throw new IllegalStateException();
     }
 
     public boolean isSet(int fieldID) {
       return isSet(_Fields.findByThriftIdOrThrow(fieldID));
     }
 
     @Override
     public boolean equals(Object that) {
       if (that == null)
         return false;
       if (that instanceof system_drop_keyspace_args)
         return this.equals((system_drop_keyspace_args)that);
       return false;
     }
 
     public boolean equals(system_drop_keyspace_args that) {
       if (that == null)
         return false;
 
       boolean this_present_keyspace = true && this.isSetKeyspace();
       boolean that_present_keyspace = true && that.isSetKeyspace();
       if (this_present_keyspace || that_present_keyspace) {
         if (!(this_present_keyspace && that_present_keyspace))
           return false;
         if (!this.keyspace.equals(that.keyspace))
           return false;
       }
 
       return true;
     }
 
     @Override
     public int hashCode() {
       return 0;
     }
 
     public int compareTo(system_drop_keyspace_args other) {
       if (!getClass().equals(other.getClass())) {
         return getClass().getName().compareTo(other.getClass().getName());
       }
 
       int lastComparison = 0;
       system_drop_keyspace_args typedOther = (system_drop_keyspace_args)other;
 
       lastComparison = Boolean.valueOf(isSetKeyspace()).compareTo(typedOther.isSetKeyspace());
       if (lastComparison != 0) {
         return lastComparison;
       }
       if (isSetKeyspace()) {        lastComparison = TBaseHelper.compareTo(keyspace, typedOther.keyspace);
         if (lastComparison != 0) {
           return lastComparison;
         }
       }
       return 0;
     }
 
     public void read(TProtocol iprot) throws TException {
       TField field;
       iprot.readStructBegin();
       while (true)
       {
         field = iprot.readFieldBegin();
         if (field.type == TType.STOP) { 
           break;
         }
         switch (field.id) {
           case 1: // KEYSPACE
             if (field.type == TType.STRING) {
               this.keyspace = iprot.readString();
             } else { 
               TProtocolUtil.skip(iprot, field.type);
             }
             break;
           default:
             TProtocolUtil.skip(iprot, field.type);
         }
         iprot.readFieldEnd();
       }
       iprot.readStructEnd();
 
       // check for required fields of primitive type, which can't be checked in the validate method
       validate();
     }
 
     public void write(TProtocol oprot) throws TException {
       validate();
 
       oprot.writeStructBegin(STRUCT_DESC);
       if (this.keyspace != null) {
         oprot.writeFieldBegin(KEYSPACE_FIELD_DESC);
         oprot.writeString(this.keyspace);
         oprot.writeFieldEnd();
       }
       oprot.writeFieldStop();
       oprot.writeStructEnd();
     }
 
     @Override
     public String toString() {
       StringBuilder sb = new StringBuilder("system_drop_keyspace_args(");
       boolean first = true;
 
       sb.append("keyspace:");
       if (this.keyspace == null) {
         sb.append("null");
       } else {
         sb.append(this.keyspace);
       }
       first = false;
       sb.append(")");
       return sb.toString();
     }
 
     public void validate() throws TException {
       // check for required fields
       if (keyspace == null) {
         throw new TProtocolException("Required field 'keyspace' was not present! Struct: " + toString());
       }
     }
 
   }
 
   public static class system_drop_keyspace_result implements TBase<system_drop_keyspace_result._Fields>, java.io.Serializable, Cloneable, Comparable<system_drop_keyspace_result>   {
     private static final TStruct STRUCT_DESC = new TStruct("system_drop_keyspace_result");
 
     private static final TField IRE_FIELD_DESC = new TField("ire", TType.STRUCT, (short)1);
 
     public InvalidRequestException ire;
 
     /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
     public enum _Fields implements TFieldIdEnum {
       IRE((short)1, "ire");
 
       private static final Map<Integer, _Fields> byId = new HashMap<Integer, _Fields>();
       private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();
 
       static {
         for (_Fields field : EnumSet.allOf(_Fields.class)) {
           byId.put((int)field._thriftId, field);
           byName.put(field.getFieldName(), field);
         }
       }
 
       /**
        * Find the _Fields constant that matches fieldId, or null if its not found.
        */
       public static _Fields findByThriftId(int fieldId) {
         return byId.get(fieldId);
       }
 
       /**
        * Find the _Fields constant that matches fieldId, throwing an exception
        * if it is not found.
        */
       public static _Fields findByThriftIdOrThrow(int fieldId) {
         _Fields fields = findByThriftId(fieldId);
         if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
         return fields;
       }
 
       /**
        * Find the _Fields constant that matches name, or null if its not found.
        */
       public static _Fields findByName(String name) {
         return byName.get(name);
       }
 
       private final short _thriftId;
       private final String _fieldName;
 
       _Fields(short thriftId, String fieldName) {
         _thriftId = thriftId;
         _fieldName = fieldName;
       }
 
       public short getThriftFieldId() {
         return _thriftId;
       }
 
       public String getFieldName() {
         return _fieldName;
       }
     }
 
     // isset id assignments
 
     public static final Map<_Fields, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new EnumMap<_Fields, FieldMetaData>(_Fields.class) {{
       put(_Fields.IRE, new FieldMetaData("ire", TFieldRequirementType.DEFAULT, 
           new FieldValueMetaData(TType.STRUCT)));
     }});
 
     static {
       FieldMetaData.addStructMetaDataMap(system_drop_keyspace_result.class, metaDataMap);
     }
 
     public system_drop_keyspace_result() {
     }
 
     public system_drop_keyspace_result(
       InvalidRequestException ire)
     {
       this();
       this.ire = ire;
     }
 
     /**
      * Performs a deep copy on <i>other</i>.
      */
     public system_drop_keyspace_result(system_drop_keyspace_result other) {
       if (other.isSetIre()) {
         this.ire = new InvalidRequestException(other.ire);
       }
     }
 
     public system_drop_keyspace_result deepCopy() {
       return new system_drop_keyspace_result(this);
     }
 
     @Deprecated
     public system_drop_keyspace_result clone() {
       return new system_drop_keyspace_result(this);
     }
 
     public InvalidRequestException getIre() {
       return this.ire;
     }
 
     public system_drop_keyspace_result setIre(InvalidRequestException ire) {
       this.ire = ire;
       return this;
     }
 
     public void unsetIre() {
       this.ire = null;
     }
 
     /** Returns true if field ire is set (has been asigned a value) and false otherwise */
     public boolean isSetIre() {
       return this.ire != null;
     }
 
     public void setIreIsSet(boolean value) {
       if (!value) {
         this.ire = null;
       }
     }
 
     public void setFieldValue(_Fields field, Object value) {
       switch (field) {
       case IRE:
         if (value == null) {
           unsetIre();
         } else {
           setIre((InvalidRequestException)value);
         }
         break;
 
       }
     }
 
     public void setFieldValue(int fieldID, Object value) {
       setFieldValue(_Fields.findByThriftIdOrThrow(fieldID), value);
     }
 
     public Object getFieldValue(_Fields field) {
       switch (field) {
       case IRE:
         return getIre();
 
       }
       throw new IllegalStateException();
     }
 
     public Object getFieldValue(int fieldId) {
       return getFieldValue(_Fields.findByThriftIdOrThrow(fieldId));
     }
 
     /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
     public boolean isSet(_Fields field) {
       switch (field) {
       case IRE:
         return isSetIre();
       }
       throw new IllegalStateException();
     }
 
     public boolean isSet(int fieldID) {
       return isSet(_Fields.findByThriftIdOrThrow(fieldID));
     }
 
     @Override
     public boolean equals(Object that) {
       if (that == null)
         return false;
       if (that instanceof system_drop_keyspace_result)
         return this.equals((system_drop_keyspace_result)that);
       return false;
     }
 
     public boolean equals(system_drop_keyspace_result that) {
       if (that == null)
         return false;
 
       boolean this_present_ire = true && this.isSetIre();
       boolean that_present_ire = true && that.isSetIre();
       if (this_present_ire || that_present_ire) {
         if (!(this_present_ire && that_present_ire))
           return false;
         if (!this.ire.equals(that.ire))
           return false;
       }
 
       return true;
     }
 
     @Override
     public int hashCode() {
       return 0;
     }
 
     public int compareTo(system_drop_keyspace_result other) {
       if (!getClass().equals(other.getClass())) {
         return getClass().getName().compareTo(other.getClass().getName());
       }
 
       int lastComparison = 0;
       system_drop_keyspace_result typedOther = (system_drop_keyspace_result)other;
 
       lastComparison = Boolean.valueOf(isSetIre()).compareTo(typedOther.isSetIre());
       if (lastComparison != 0) {
         return lastComparison;
       }
       if (isSetIre()) {        lastComparison = TBaseHelper.compareTo(ire, typedOther.ire);
         if (lastComparison != 0) {
           return lastComparison;
         }
       }
       return 0;
     }
 
     public void read(TProtocol iprot) throws TException {
       TField field;
       iprot.readStructBegin();
       while (true)
       {
         field = iprot.readFieldBegin();
         if (field.type == TType.STOP) { 
           break;
         }
         switch (field.id) {
           case 1: // IRE
             if (field.type == TType.STRUCT) {
               this.ire = new InvalidRequestException();
               this.ire.read(iprot);
             } else { 
               TProtocolUtil.skip(iprot, field.type);
             }
             break;
           default:
             TProtocolUtil.skip(iprot, field.type);
         }
         iprot.readFieldEnd();
       }
       iprot.readStructEnd();
 
       // check for required fields of primitive type, which can't be checked in the validate method
       validate();
     }
 
     public void write(TProtocol oprot) throws TException {
       oprot.writeStructBegin(STRUCT_DESC);
 
       if (this.isSetIre()) {
         oprot.writeFieldBegin(IRE_FIELD_DESC);
         this.ire.write(oprot);
         oprot.writeFieldEnd();
       }
       oprot.writeFieldStop();
       oprot.writeStructEnd();
     }
 
     @Override
     public String toString() {
       StringBuilder sb = new StringBuilder("system_drop_keyspace_result(");
       boolean first = true;
 
       sb.append("ire:");
       if (this.ire == null) {
         sb.append("null");
       } else {
         sb.append(this.ire);
       }
       first = false;
       sb.append(")");
       return sb.toString();
     }
 
     public void validate() throws TException {
       // check for required fields
     }
 
   }
 
   public static class system_rename_keyspace_args implements TBase<system_rename_keyspace_args._Fields>, java.io.Serializable, Cloneable, Comparable<system_rename_keyspace_args>   {
     private static final TStruct STRUCT_DESC = new TStruct("system_rename_keyspace_args");
 
     private static final TField OLD_NAME_FIELD_DESC = new TField("old_name", TType.STRING, (short)1);
     private static final TField NEW_NAME_FIELD_DESC = new TField("new_name", TType.STRING, (short)2);
 
     public String old_name;
     public String new_name;
 
     /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
     public enum _Fields implements TFieldIdEnum {
       OLD_NAME((short)1, "old_name"),
       NEW_NAME((short)2, "new_name");
 
       private static final Map<Integer, _Fields> byId = new HashMap<Integer, _Fields>();
       private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();
 
       static {
         for (_Fields field : EnumSet.allOf(_Fields.class)) {
           byId.put((int)field._thriftId, field);
           byName.put(field.getFieldName(), field);
         }
       }
 
       /**
        * Find the _Fields constant that matches fieldId, or null if its not found.
        */
       public static _Fields findByThriftId(int fieldId) {
         return byId.get(fieldId);
       }
 
       /**
        * Find the _Fields constant that matches fieldId, throwing an exception
        * if it is not found.
        */
       public static _Fields findByThriftIdOrThrow(int fieldId) {
         _Fields fields = findByThriftId(fieldId);
         if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
         return fields;
       }
 
       /**
        * Find the _Fields constant that matches name, or null if its not found.
        */
       public static _Fields findByName(String name) {
         return byName.get(name);
       }
 
       private final short _thriftId;
       private final String _fieldName;
 
       _Fields(short thriftId, String fieldName) {
         _thriftId = thriftId;
         _fieldName = fieldName;
       }
 
       public short getThriftFieldId() {
         return _thriftId;
       }
 
       public String getFieldName() {
         return _fieldName;
       }
     }
 
     // isset id assignments
 
     public static final Map<_Fields, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new EnumMap<_Fields, FieldMetaData>(_Fields.class) {{
       put(_Fields.OLD_NAME, new FieldMetaData("old_name", TFieldRequirementType.REQUIRED, 
           new FieldValueMetaData(TType.STRING)));
       put(_Fields.NEW_NAME, new FieldMetaData("new_name", TFieldRequirementType.REQUIRED, 
           new FieldValueMetaData(TType.STRING)));
     }});
 
     static {
       FieldMetaData.addStructMetaDataMap(system_rename_keyspace_args.class, metaDataMap);
     }
 
     public system_rename_keyspace_args() {
     }
 
     public system_rename_keyspace_args(
       String old_name,
       String new_name)
     {
       this();
       this.old_name = old_name;
       this.new_name = new_name;
     }
 
     /**
      * Performs a deep copy on <i>other</i>.
      */
     public system_rename_keyspace_args(system_rename_keyspace_args other) {
       if (other.isSetOld_name()) {
         this.old_name = other.old_name;
       }
       if (other.isSetNew_name()) {
         this.new_name = other.new_name;
       }
     }
 
     public system_rename_keyspace_args deepCopy() {
       return new system_rename_keyspace_args(this);
     }
 
     @Deprecated
     public system_rename_keyspace_args clone() {
       return new system_rename_keyspace_args(this);
     }
 
     public String getOld_name() {
       return this.old_name;
     }
 
     public system_rename_keyspace_args setOld_name(String old_name) {
       this.old_name = old_name;
       return this;
     }
 
     public void unsetOld_name() {
       this.old_name = null;
     }
 
     /** Returns true if field old_name is set (has been asigned a value) and false otherwise */
     public boolean isSetOld_name() {
       return this.old_name != null;
     }
 
     public void setOld_nameIsSet(boolean value) {
       if (!value) {
         this.old_name = null;
       }
     }
 
     public String getNew_name() {
       return this.new_name;
     }
 
     public system_rename_keyspace_args setNew_name(String new_name) {
       this.new_name = new_name;
       return this;
     }
 
     public void unsetNew_name() {
       this.new_name = null;
     }
 
     /** Returns true if field new_name is set (has been asigned a value) and false otherwise */
     public boolean isSetNew_name() {
       return this.new_name != null;
     }
 
     public void setNew_nameIsSet(boolean value) {
       if (!value) {
         this.new_name = null;
       }
     }
 
     public void setFieldValue(_Fields field, Object value) {
       switch (field) {
       case OLD_NAME:
         if (value == null) {
           unsetOld_name();
         } else {
           setOld_name((String)value);
         }
         break;
 
       case NEW_NAME:
         if (value == null) {
           unsetNew_name();
         } else {
           setNew_name((String)value);
         }
         break;
 
       }
     }
 
     public void setFieldValue(int fieldID, Object value) {
       setFieldValue(_Fields.findByThriftIdOrThrow(fieldID), value);
     }
 
     public Object getFieldValue(_Fields field) {
       switch (field) {
       case OLD_NAME:
         return getOld_name();
 
       case NEW_NAME:
         return getNew_name();
 
       }
       throw new IllegalStateException();
     }
 
     public Object getFieldValue(int fieldId) {
       return getFieldValue(_Fields.findByThriftIdOrThrow(fieldId));
     }
 
     /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
     public boolean isSet(_Fields field) {
       switch (field) {
       case OLD_NAME:
         return isSetOld_name();
       case NEW_NAME:
         return isSetNew_name();
       }
       throw new IllegalStateException();
     }
 
     public boolean isSet(int fieldID) {
       return isSet(_Fields.findByThriftIdOrThrow(fieldID));
     }
 
     @Override
     public boolean equals(Object that) {
       if (that == null)
         return false;
       if (that instanceof system_rename_keyspace_args)
         return this.equals((system_rename_keyspace_args)that);
       return false;
     }
 
     public boolean equals(system_rename_keyspace_args that) {
       if (that == null)
         return false;
 
       boolean this_present_old_name = true && this.isSetOld_name();
       boolean that_present_old_name = true && that.isSetOld_name();
       if (this_present_old_name || that_present_old_name) {
         if (!(this_present_old_name && that_present_old_name))
           return false;
         if (!this.old_name.equals(that.old_name))
           return false;
       }
 
       boolean this_present_new_name = true && this.isSetNew_name();
       boolean that_present_new_name = true && that.isSetNew_name();
       if (this_present_new_name || that_present_new_name) {
         if (!(this_present_new_name && that_present_new_name))
           return false;
         if (!this.new_name.equals(that.new_name))
           return false;
       }
 
       return true;
     }
 
     @Override
     public int hashCode() {
       return 0;
     }
 
     public int compareTo(system_rename_keyspace_args other) {
       if (!getClass().equals(other.getClass())) {
         return getClass().getName().compareTo(other.getClass().getName());
       }
 
       int lastComparison = 0;
       system_rename_keyspace_args typedOther = (system_rename_keyspace_args)other;
 
       lastComparison = Boolean.valueOf(isSetOld_name()).compareTo(typedOther.isSetOld_name());
       if (lastComparison != 0) {
         return lastComparison;
       }
       if (isSetOld_name()) {        lastComparison = TBaseHelper.compareTo(old_name, typedOther.old_name);
         if (lastComparison != 0) {
           return lastComparison;
         }
       }
       lastComparison = Boolean.valueOf(isSetNew_name()).compareTo(typedOther.isSetNew_name());
       if (lastComparison != 0) {
         return lastComparison;
       }
       if (isSetNew_name()) {        lastComparison = TBaseHelper.compareTo(new_name, typedOther.new_name);
         if (lastComparison != 0) {
           return lastComparison;
         }
       }
       return 0;
     }
 
     public void read(TProtocol iprot) throws TException {
       TField field;
       iprot.readStructBegin();
       while (true)
       {
         field = iprot.readFieldBegin();
         if (field.type == TType.STOP) { 
           break;
         }
         switch (field.id) {
           case 1: // OLD_NAME
             if (field.type == TType.STRING) {
               this.old_name = iprot.readString();
             } else { 
               TProtocolUtil.skip(iprot, field.type);
             }
             break;
           case 2: // NEW_NAME
             if (field.type == TType.STRING) {
               this.new_name = iprot.readString();
             } else { 
               TProtocolUtil.skip(iprot, field.type);
             }
             break;
           default:
             TProtocolUtil.skip(iprot, field.type);
         }
         iprot.readFieldEnd();
       }
       iprot.readStructEnd();
 
       // check for required fields of primitive type, which can't be checked in the validate method
       validate();
     }
 
     public void write(TProtocol oprot) throws TException {
       validate();
 
       oprot.writeStructBegin(STRUCT_DESC);
       if (this.old_name != null) {
         oprot.writeFieldBegin(OLD_NAME_FIELD_DESC);
         oprot.writeString(this.old_name);
         oprot.writeFieldEnd();
       }
       if (this.new_name != null) {
         oprot.writeFieldBegin(NEW_NAME_FIELD_DESC);
         oprot.writeString(this.new_name);
         oprot.writeFieldEnd();
       }
       oprot.writeFieldStop();
       oprot.writeStructEnd();
     }
 
     @Override
     public String toString() {
       StringBuilder sb = new StringBuilder("system_rename_keyspace_args(");
       boolean first = true;
 
       sb.append("old_name:");
       if (this.old_name == null) {
         sb.append("null");
       } else {
         sb.append(this.old_name);
       }
       first = false;
       if (!first) sb.append(", ");
       sb.append("new_name:");
       if (this.new_name == null) {
         sb.append("null");
       } else {
         sb.append(this.new_name);
       }
       first = false;
       sb.append(")");
       return sb.toString();
     }
 
     public void validate() throws TException {
       // check for required fields
       if (old_name == null) {
         throw new TProtocolException("Required field 'old_name' was not present! Struct: " + toString());
       }
       if (new_name == null) {
         throw new TProtocolException("Required field 'new_name' was not present! Struct: " + toString());
       }
     }
 
   }
 
   public static class system_rename_keyspace_result implements TBase<system_rename_keyspace_result._Fields>, java.io.Serializable, Cloneable, Comparable<system_rename_keyspace_result>   {
     private static final TStruct STRUCT_DESC = new TStruct("system_rename_keyspace_result");
 
     private static final TField IRE_FIELD_DESC = new TField("ire", TType.STRUCT, (short)1);
 
     public InvalidRequestException ire;
 
     /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
     public enum _Fields implements TFieldIdEnum {
       IRE((short)1, "ire");
 
       private static final Map<Integer, _Fields> byId = new HashMap<Integer, _Fields>();
       private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();
 
       static {
         for (_Fields field : EnumSet.allOf(_Fields.class)) {
           byId.put((int)field._thriftId, field);
           byName.put(field.getFieldName(), field);
         }
       }
 
       /**
        * Find the _Fields constant that matches fieldId, or null if its not found.
        */
       public static _Fields findByThriftId(int fieldId) {
         return byId.get(fieldId);
       }
 
       /**
        * Find the _Fields constant that matches fieldId, throwing an exception
        * if it is not found.
        */
       public static _Fields findByThriftIdOrThrow(int fieldId) {
         _Fields fields = findByThriftId(fieldId);
         if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
         return fields;
       }
 
       /**
        * Find the _Fields constant that matches name, or null if its not found.
        */
       public static _Fields findByName(String name) {
         return byName.get(name);
       }
 
       private final short _thriftId;
       private final String _fieldName;
 
       _Fields(short thriftId, String fieldName) {
         _thriftId = thriftId;
         _fieldName = fieldName;
       }
 
       public short getThriftFieldId() {
         return _thriftId;
       }
 
       public String getFieldName() {
         return _fieldName;
       }
     }
 
     // isset id assignments
 
     public static final Map<_Fields, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new EnumMap<_Fields, FieldMetaData>(_Fields.class) {{
       put(_Fields.IRE, new FieldMetaData("ire", TFieldRequirementType.DEFAULT, 
           new FieldValueMetaData(TType.STRUCT)));
     }});
 
     static {
       FieldMetaData.addStructMetaDataMap(system_rename_keyspace_result.class, metaDataMap);
     }
 
     public system_rename_keyspace_result() {
     }
 
     public system_rename_keyspace_result(
       InvalidRequestException ire)
     {
       this();
       this.ire = ire;
     }
 
     /**
      * Performs a deep copy on <i>other</i>.
      */
     public system_rename_keyspace_result(system_rename_keyspace_result other) {
       if (other.isSetIre()) {
         this.ire = new InvalidRequestException(other.ire);
       }
     }
 
     public system_rename_keyspace_result deepCopy() {
       return new system_rename_keyspace_result(this);
     }
 
     @Deprecated
     public system_rename_keyspace_result clone() {
       return new system_rename_keyspace_result(this);
     }
 
     public InvalidRequestException getIre() {
       return this.ire;
     }
 
     public system_rename_keyspace_result setIre(InvalidRequestException ire) {
       this.ire = ire;
       return this;
     }
 
     public void unsetIre() {
       this.ire = null;
     }
 
     /** Returns true if field ire is set (has been asigned a value) and false otherwise */
     public boolean isSetIre() {
       return this.ire != null;
     }
 
     public void setIreIsSet(boolean value) {
       if (!value) {
         this.ire = null;
       }
     }
 
     public void setFieldValue(_Fields field, Object value) {
       switch (field) {
       case IRE:
         if (value == null) {
           unsetIre();
         } else {
           setIre((InvalidRequestException)value);
         }
         break;
 
       }
     }
 
     public void setFieldValue(int fieldID, Object value) {
       setFieldValue(_Fields.findByThriftIdOrThrow(fieldID), value);
     }
 
     public Object getFieldValue(_Fields field) {
       switch (field) {
       case IRE:
         return getIre();
 
       }
       throw new IllegalStateException();
     }
 
     public Object getFieldValue(int fieldId) {
       return getFieldValue(_Fields.findByThriftIdOrThrow(fieldId));
     }
 
     /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
     public boolean isSet(_Fields field) {
       switch (field) {
       case IRE:
         return isSetIre();
       }
       throw new IllegalStateException();
     }
 
     public boolean isSet(int fieldID) {
       return isSet(_Fields.findByThriftIdOrThrow(fieldID));
     }
 
     @Override
     public boolean equals(Object that) {
       if (that == null)
         return false;
       if (that instanceof system_rename_keyspace_result)
         return this.equals((system_rename_keyspace_result)that);
       return false;
     }
 
     public boolean equals(system_rename_keyspace_result that) {
       if (that == null)
         return false;
 
       boolean this_present_ire = true && this.isSetIre();
       boolean that_present_ire = true && that.isSetIre();
       if (this_present_ire || that_present_ire) {
         if (!(this_present_ire && that_present_ire))
           return false;
         if (!this.ire.equals(that.ire))
           return false;
       }
 
       return true;
     }
 
     @Override
     public int hashCode() {
       return 0;
     }
 
     public int compareTo(system_rename_keyspace_result other) {
       if (!getClass().equals(other.getClass())) {
         return getClass().getName().compareTo(other.getClass().getName());
       }
 
       int lastComparison = 0;
       system_rename_keyspace_result typedOther = (system_rename_keyspace_result)other;
 
       lastComparison = Boolean.valueOf(isSetIre()).compareTo(typedOther.isSetIre());
       if (lastComparison != 0) {
         return lastComparison;
       }
       if (isSetIre()) {        lastComparison = TBaseHelper.compareTo(ire, typedOther.ire);
         if (lastComparison != 0) {
           return lastComparison;
         }
       }
       return 0;
     }
 
     public void read(TProtocol iprot) throws TException {
       TField field;
       iprot.readStructBegin();
       while (true)
       {
         field = iprot.readFieldBegin();
         if (field.type == TType.STOP) { 
           break;
         }
         switch (field.id) {
           case 1: // IRE
             if (field.type == TType.STRUCT) {
               this.ire = new InvalidRequestException();
               this.ire.read(iprot);
             } else { 
               TProtocolUtil.skip(iprot, field.type);
             }
             break;
           default:
             TProtocolUtil.skip(iprot, field.type);
         }
         iprot.readFieldEnd();
       }
       iprot.readStructEnd();
 
       // check for required fields of primitive type, which can't be checked in the validate method
       validate();
     }
 
     public void write(TProtocol oprot) throws TException {
       oprot.writeStructBegin(STRUCT_DESC);
 
       if (this.isSetIre()) {
         oprot.writeFieldBegin(IRE_FIELD_DESC);
         this.ire.write(oprot);
         oprot.writeFieldEnd();
       }
       oprot.writeFieldStop();
       oprot.writeStructEnd();
     }
 
     @Override
     public String toString() {
       StringBuilder sb = new StringBuilder("system_rename_keyspace_result(");
       boolean first = true;
 
       sb.append("ire:");
       if (this.ire == null) {
         sb.append("null");
       } else {
         sb.append(this.ire);
       }
       first = false;
       sb.append(")");
       return sb.toString();
     }
 
     public void validate() throws TException {
       // check for required fields
     }
 
   }
 
 }
